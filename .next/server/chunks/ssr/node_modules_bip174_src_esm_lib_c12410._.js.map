{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bip174/src/esm/lib/typeFields.js"],"sourcesContent":["export var GlobalTypes;\n(function(GlobalTypes) {\n  GlobalTypes[(GlobalTypes['UNSIGNED_TX'] = 0)] = 'UNSIGNED_TX';\n  GlobalTypes[(GlobalTypes['GLOBAL_XPUB'] = 1)] = 'GLOBAL_XPUB';\n})(GlobalTypes || (GlobalTypes = {}));\nexport const GLOBAL_TYPE_NAMES = ['unsignedTx', 'globalXpub'];\nexport var InputTypes;\n(function(InputTypes) {\n  InputTypes[(InputTypes['NON_WITNESS_UTXO'] = 0)] = 'NON_WITNESS_UTXO';\n  InputTypes[(InputTypes['WITNESS_UTXO'] = 1)] = 'WITNESS_UTXO';\n  InputTypes[(InputTypes['PARTIAL_SIG'] = 2)] = 'PARTIAL_SIG';\n  InputTypes[(InputTypes['SIGHASH_TYPE'] = 3)] = 'SIGHASH_TYPE';\n  InputTypes[(InputTypes['REDEEM_SCRIPT'] = 4)] = 'REDEEM_SCRIPT';\n  InputTypes[(InputTypes['WITNESS_SCRIPT'] = 5)] = 'WITNESS_SCRIPT';\n  InputTypes[(InputTypes['BIP32_DERIVATION'] = 6)] = 'BIP32_DERIVATION';\n  InputTypes[(InputTypes['FINAL_SCRIPTSIG'] = 7)] = 'FINAL_SCRIPTSIG';\n  InputTypes[(InputTypes['FINAL_SCRIPTWITNESS'] = 8)] = 'FINAL_SCRIPTWITNESS';\n  InputTypes[(InputTypes['POR_COMMITMENT'] = 9)] = 'POR_COMMITMENT';\n  InputTypes[(InputTypes['TAP_KEY_SIG'] = 19)] = 'TAP_KEY_SIG';\n  InputTypes[(InputTypes['TAP_SCRIPT_SIG'] = 20)] = 'TAP_SCRIPT_SIG';\n  InputTypes[(InputTypes['TAP_LEAF_SCRIPT'] = 21)] = 'TAP_LEAF_SCRIPT';\n  InputTypes[(InputTypes['TAP_BIP32_DERIVATION'] = 22)] =\n    'TAP_BIP32_DERIVATION';\n  InputTypes[(InputTypes['TAP_INTERNAL_KEY'] = 23)] = 'TAP_INTERNAL_KEY';\n  InputTypes[(InputTypes['TAP_MERKLE_ROOT'] = 24)] = 'TAP_MERKLE_ROOT';\n})(InputTypes || (InputTypes = {}));\nexport const INPUT_TYPE_NAMES = [\n  'nonWitnessUtxo',\n  'witnessUtxo',\n  'partialSig',\n  'sighashType',\n  'redeemScript',\n  'witnessScript',\n  'bip32Derivation',\n  'finalScriptSig',\n  'finalScriptWitness',\n  'porCommitment',\n  'tapKeySig',\n  'tapScriptSig',\n  'tapLeafScript',\n  'tapBip32Derivation',\n  'tapInternalKey',\n  'tapMerkleRoot',\n];\nexport var OutputTypes;\n(function(OutputTypes) {\n  OutputTypes[(OutputTypes['REDEEM_SCRIPT'] = 0)] = 'REDEEM_SCRIPT';\n  OutputTypes[(OutputTypes['WITNESS_SCRIPT'] = 1)] = 'WITNESS_SCRIPT';\n  OutputTypes[(OutputTypes['BIP32_DERIVATION'] = 2)] = 'BIP32_DERIVATION';\n  OutputTypes[(OutputTypes['TAP_INTERNAL_KEY'] = 5)] = 'TAP_INTERNAL_KEY';\n  OutputTypes[(OutputTypes['TAP_TREE'] = 6)] = 'TAP_TREE';\n  OutputTypes[(OutputTypes['TAP_BIP32_DERIVATION'] = 7)] =\n    'TAP_BIP32_DERIVATION';\n})(OutputTypes || (OutputTypes = {}));\nexport const OUTPUT_TYPE_NAMES = [\n  'redeemScript',\n  'witnessScript',\n  'bip32Derivation',\n  'tapInternalKey',\n  'tapTree',\n  'tapBip32Derivation',\n];\n"],"names":[],"mappings":";;;;;;;;AAAO,IAAI;AACX,CAAC,SAAS,WAAW;IACnB,WAAW,CAAE,WAAW,CAAC,cAAc,GAAG,EAAG,GAAG;IAChD,WAAW,CAAE,WAAW,CAAC,cAAc,GAAG,EAAG,GAAG;AAClD,CAAC,EAAE,eAAe,CAAC,cAAc,CAAC,CAAC;AAC5B,MAAM,oBAAoB;IAAC;IAAc;CAAa;AACtD,IAAI;AACX,CAAC,SAAS,UAAU;IAClB,UAAU,CAAE,UAAU,CAAC,mBAAmB,GAAG,EAAG,GAAG;IACnD,UAAU,CAAE,UAAU,CAAC,eAAe,GAAG,EAAG,GAAG;IAC/C,UAAU,CAAE,UAAU,CAAC,cAAc,GAAG,EAAG,GAAG;IAC9C,UAAU,CAAE,UAAU,CAAC,eAAe,GAAG,EAAG,GAAG;IAC/C,UAAU,CAAE,UAAU,CAAC,gBAAgB,GAAG,EAAG,GAAG;IAChD,UAAU,CAAE,UAAU,CAAC,iBAAiB,GAAG,EAAG,GAAG;IACjD,UAAU,CAAE,UAAU,CAAC,mBAAmB,GAAG,EAAG,GAAG;IACnD,UAAU,CAAE,UAAU,CAAC,kBAAkB,GAAG,EAAG,GAAG;IAClD,UAAU,CAAE,UAAU,CAAC,sBAAsB,GAAG,EAAG,GAAG;IACtD,UAAU,CAAE,UAAU,CAAC,iBAAiB,GAAG,EAAG,GAAG;IACjD,UAAU,CAAE,UAAU,CAAC,cAAc,GAAG,GAAI,GAAG;IAC/C,UAAU,CAAE,UAAU,CAAC,iBAAiB,GAAG,GAAI,GAAG;IAClD,UAAU,CAAE,UAAU,CAAC,kBAAkB,GAAG,GAAI,GAAG;IACnD,UAAU,CAAE,UAAU,CAAC,uBAAuB,GAAG,GAAI,GACnD;IACF,UAAU,CAAE,UAAU,CAAC,mBAAmB,GAAG,GAAI,GAAG;IACpD,UAAU,CAAE,UAAU,CAAC,kBAAkB,GAAG,GAAI,GAAG;AACrD,CAAC,EAAE,cAAc,CAAC,aAAa,CAAC,CAAC;AAC1B,MAAM,mBAAmB;IAC9B;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACD;AACM,IAAI;AACX,CAAC,SAAS,WAAW;IACnB,WAAW,CAAE,WAAW,CAAC,gBAAgB,GAAG,EAAG,GAAG;IAClD,WAAW,CAAE,WAAW,CAAC,iBAAiB,GAAG,EAAG,GAAG;IACnD,WAAW,CAAE,WAAW,CAAC,mBAAmB,GAAG,EAAG,GAAG;IACrD,WAAW,CAAE,WAAW,CAAC,mBAAmB,GAAG,EAAG,GAAG;IACrD,WAAW,CAAE,WAAW,CAAC,WAAW,GAAG,EAAG,GAAG;IAC7C,WAAW,CAAE,WAAW,CAAC,uBAAuB,GAAG,EAAG,GACpD;AACJ,CAAC,EAAE,eAAe,CAAC,cAAc,CAAC,CAAC;AAC5B,MAAM,oBAAoB;IAC/B;IACA;IACA;IACA;IACA;IACA;CACD","ignoreList":[0]}},
    {"offset": {"line": 78, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 84, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bip174/src/esm/lib/converter/global/globalXpub.js"],"sourcesContent":["import { GlobalTypes } from '../../typeFields.js';\nimport * as tools from 'uint8array-tools';\nconst range = n => [...Array(n).keys()];\nexport function decode(keyVal) {\n  if (keyVal.key[0] !== GlobalTypes.GLOBAL_XPUB) {\n    throw new Error(\n      'Decode Error: could not decode globalXpub with key 0x' +\n        tools.toHex(keyVal.key),\n    );\n  }\n  if (keyVal.key.length !== 79 || ![2, 3].includes(keyVal.key[46])) {\n    throw new Error(\n      'Decode Error: globalXpub has invalid extended pubkey in key 0x' +\n        tools.toHex(keyVal.key),\n    );\n  }\n  if ((keyVal.value.length / 4) % 1 !== 0) {\n    throw new Error(\n      'Decode Error: Global GLOBAL_XPUB value length should be multiple of 4',\n    );\n  }\n  const extendedPubkey = keyVal.key.slice(1);\n  const data = {\n    masterFingerprint: keyVal.value.slice(0, 4),\n    extendedPubkey,\n    path: 'm',\n  };\n  for (const i of range(keyVal.value.length / 4 - 1)) {\n    const val = tools.readUInt32(keyVal.value, i * 4 + 4, 'LE');\n    const isHard = !!(val & 0x80000000);\n    const idx = val & 0x7fffffff;\n    data.path += '/' + idx.toString(10) + (isHard ? \"'\" : '');\n  }\n  return data;\n}\nexport function encode(data) {\n  const head = new Uint8Array([GlobalTypes.GLOBAL_XPUB]);\n  const key = tools.concat([head, data.extendedPubkey]);\n  const splitPath = data.path.split('/');\n  const value = new Uint8Array(splitPath.length * 4);\n  value.set(data.masterFingerprint, 0);\n  let offset = 4;\n  splitPath.slice(1).forEach(level => {\n    const isHard = level.slice(-1) === \"'\";\n    let num = 0x7fffffff & parseInt(isHard ? level.slice(0, -1) : level, 10);\n    if (isHard) num += 0x80000000;\n    tools.writeUInt32(value, offset, num, 'LE');\n    offset += 4;\n  });\n  return {\n    key,\n    value,\n  };\n}\nexport const expected =\n  '{ masterFingerprint: Uint8Array; extendedPubkey: Uint8Array; path: string; }';\nexport function check(data) {\n  const epk = data.extendedPubkey;\n  const mfp = data.masterFingerprint;\n  const p = data.path;\n  return (\n    epk instanceof Uint8Array &&\n    epk.length === 78 &&\n    [2, 3].indexOf(epk[45]) > -1 &&\n    mfp instanceof Uint8Array &&\n    mfp.length === 4 &&\n    typeof p === 'string' &&\n    !!p.match(/^m(\\/\\d+'?)*$/)\n  );\n}\nexport function canAddToArray(array, item, dupeSet) {\n  const dupeString = tools.toHex(item.extendedPubkey);\n  if (dupeSet.has(dupeString)) return false;\n  dupeSet.add(dupeString);\n  return (\n    array.filter(v => tools.compare(v.extendedPubkey, item.extendedPubkey))\n      .length === 0\n  );\n}\n"],"names":[],"mappings":";;;;;;;AAAA;AACA;;;AACA,MAAM,QAAQ,CAAA,IAAK;WAAI,MAAM,GAAG,IAAI;KAAG;AAChC,SAAS,OAAO,MAAM;IAC3B,IAAI,OAAO,GAAG,CAAC,EAAE,KAAK,yJAAA,CAAA,cAAW,CAAC,WAAW,EAAE;QAC7C,MAAM,IAAI,MACR,0DACE,2JAAM,KAAK,CAAC,OAAO,GAAG;IAE5B;IACA,IAAI,OAAO,GAAG,CAAC,MAAM,KAAK,MAAM,CAAC;QAAC;QAAG;KAAE,CAAC,QAAQ,CAAC,OAAO,GAAG,CAAC,GAAG,GAAG;QAChE,MAAM,IAAI,MACR,mEACE,2JAAM,KAAK,CAAC,OAAO,GAAG;IAE5B;IACA,IAAI,AAAC,OAAO,KAAK,CAAC,MAAM,GAAG,IAAK,MAAM,GAAG;QACvC,MAAM,IAAI,MACR;IAEJ;IACA,MAAM,iBAAiB,OAAO,GAAG,CAAC,KAAK,CAAC;IACxC,MAAM,OAAO;QACX,mBAAmB,OAAO,KAAK,CAAC,KAAK,CAAC,GAAG;QACzC;QACA,MAAM;IACR;IACA,KAAK,MAAM,KAAK,MAAM,OAAO,KAAK,CAAC,MAAM,GAAG,IAAI,GAAI;QAClD,MAAM,MAAM,2JAAM,UAAU,CAAC,OAAO,KAAK,EAAE,IAAI,IAAI,GAAG;QACtD,MAAM,SAAS,CAAC,CAAC,CAAC,MAAM,UAAU;QAClC,MAAM,MAAM,MAAM;QAClB,KAAK,IAAI,IAAI,MAAM,IAAI,QAAQ,CAAC,MAAM,CAAC,SAAS,MAAM,EAAE;IAC1D;IACA,OAAO;AACT;AACO,SAAS,OAAO,IAAI;IACzB,MAAM,OAAO,IAAI,WAAW;QAAC,yJAAA,CAAA,cAAW,CAAC,WAAW;KAAC;IACrD,MAAM,MAAM,2JAAM,MAAM,CAAC;QAAC;QAAM,KAAK,cAAc;KAAC;IACpD,MAAM,YAAY,KAAK,IAAI,CAAC,KAAK,CAAC;IAClC,MAAM,QAAQ,IAAI,WAAW,UAAU,MAAM,GAAG;IAChD,MAAM,GAAG,CAAC,KAAK,iBAAiB,EAAE;IAClC,IAAI,SAAS;IACb,UAAU,KAAK,CAAC,GAAG,OAAO,CAAC,CAAA;QACzB,MAAM,SAAS,MAAM,KAAK,CAAC,CAAC,OAAO;QACnC,IAAI,MAAM,aAAa,SAAS,SAAS,MAAM,KAAK,CAAC,GAAG,CAAC,KAAK,OAAO;QACrE,IAAI,QAAQ,OAAO;QACnB,2JAAM,WAAW,CAAC,OAAO,QAAQ,KAAK;QACtC,UAAU;IACZ;IACA,OAAO;QACL;QACA;IACF;AACF;AACO,MAAM,WACX;AACK,SAAS,MAAM,IAAI;IACxB,MAAM,MAAM,KAAK,cAAc;IAC/B,MAAM,MAAM,KAAK,iBAAiB;IAClC,MAAM,IAAI,KAAK,IAAI;IACnB,OACE,eAAe,cACf,IAAI,MAAM,KAAK,MACf;QAAC;QAAG;KAAE,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,KAC3B,eAAe,cACf,IAAI,MAAM,KAAK,KACf,OAAO,MAAM,YACb,CAAC,CAAC,EAAE,KAAK,CAAC;AAEd;AACO,SAAS,cAAc,KAAK,EAAE,IAAI,EAAE,OAAO;IAChD,MAAM,aAAa,2JAAM,KAAK,CAAC,KAAK,cAAc;IAClD,IAAI,QAAQ,GAAG,CAAC,aAAa,OAAO;IACpC,QAAQ,GAAG,CAAC;IACZ,OACE,MAAM,MAAM,CAAC,CAAA,IAAK,2JAAM,OAAO,CAAC,EAAE,cAAc,EAAE,KAAK,cAAc,GAClE,MAAM,KAAK;AAElB","ignoreList":[0]}},
    {"offset": {"line": 165, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 171, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bip174/src/esm/lib/converter/global/unsignedTx.js"],"sourcesContent":["import { GlobalTypes } from '../../typeFields.js';\nexport function encode(data) {\n  return {\n    key: new Uint8Array([GlobalTypes.UNSIGNED_TX]),\n    value: data.toBuffer(),\n  };\n}\n"],"names":[],"mappings":";;;AAAA;;AACO,SAAS,OAAO,IAAI;IACzB,OAAO;QACL,KAAK,IAAI,WAAW;YAAC,yJAAA,CAAA,cAAW,CAAC,WAAW;SAAC;QAC7C,OAAO,KAAK,QAAQ;IACtB;AACF","ignoreList":[0]}},
    {"offset": {"line": 184, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 190, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bip174/src/esm/lib/converter/input/finalScriptSig.js"],"sourcesContent":["import { InputTypes } from '../../typeFields.js';\nimport * as tools from 'uint8array-tools';\nexport function decode(keyVal) {\n  if (keyVal.key[0] !== InputTypes.FINAL_SCRIPTSIG) {\n    throw new Error(\n      'Decode Error: could not decode finalScriptSig with key 0x' +\n        tools.toHex(keyVal.key),\n    );\n  }\n  return keyVal.value;\n}\nexport function encode(data) {\n  const key = new Uint8Array([InputTypes.FINAL_SCRIPTSIG]);\n  return {\n    key,\n    value: data,\n  };\n}\nexport const expected = 'Uint8Array';\nexport function check(data) {\n  return data instanceof Uint8Array;\n}\nexport function canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.finalScriptSig === undefined;\n}\n"],"names":[],"mappings":";;;;;;;AAAA;AACA;;;AACO,SAAS,OAAO,MAAM;IAC3B,IAAI,OAAO,GAAG,CAAC,EAAE,KAAK,yJAAA,CAAA,aAAU,CAAC,eAAe,EAAE;QAChD,MAAM,IAAI,MACR,8DACE,2JAAM,KAAK,CAAC,OAAO,GAAG;IAE5B;IACA,OAAO,OAAO,KAAK;AACrB;AACO,SAAS,OAAO,IAAI;IACzB,MAAM,MAAM,IAAI,WAAW;QAAC,yJAAA,CAAA,aAAU,CAAC,eAAe;KAAC;IACvD,OAAO;QACL;QACA,OAAO;IACT;AACF;AACO,MAAM,WAAW;AACjB,SAAS,MAAM,IAAI;IACxB,OAAO,gBAAgB;AACzB;AACO,SAAS,OAAO,WAAW,EAAE,OAAO;IACzC,OAAO,CAAC,CAAC,eAAe,CAAC,CAAC,WAAW,YAAY,cAAc,KAAK;AACtE","ignoreList":[0]}},
    {"offset": {"line": 223, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 229, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bip174/src/esm/lib/converter/input/finalScriptWitness.js"],"sourcesContent":["import { InputTypes } from '../../typeFields.js';\nimport * as tools from 'uint8array-tools';\nexport function decode(keyVal) {\n  if (keyVal.key[0] !== InputTypes.FINAL_SCRIPTWITNESS) {\n    throw new Error(\n      'Decode Error: could not decode finalScriptWitness with key 0x' +\n        tools.toHex(keyVal.key),\n    );\n  }\n  return keyVal.value;\n}\nexport function encode(data) {\n  const key = new Uint8Array([InputTypes.FINAL_SCRIPTWITNESS]);\n  return {\n    key,\n    value: data,\n  };\n}\nexport const expected = 'Uint8Array';\nexport function check(data) {\n  return data instanceof Uint8Array;\n}\nexport function canAdd(currentData, newData) {\n  return (\n    !!currentData && !!newData && currentData.finalScriptWitness === undefined\n  );\n}\n"],"names":[],"mappings":";;;;;;;AAAA;AACA;;;AACO,SAAS,OAAO,MAAM;IAC3B,IAAI,OAAO,GAAG,CAAC,EAAE,KAAK,yJAAA,CAAA,aAAU,CAAC,mBAAmB,EAAE;QACpD,MAAM,IAAI,MACR,kEACE,2JAAM,KAAK,CAAC,OAAO,GAAG;IAE5B;IACA,OAAO,OAAO,KAAK;AACrB;AACO,SAAS,OAAO,IAAI;IACzB,MAAM,MAAM,IAAI,WAAW;QAAC,yJAAA,CAAA,aAAU,CAAC,mBAAmB;KAAC;IAC3D,OAAO;QACL;QACA,OAAO;IACT;AACF;AACO,MAAM,WAAW;AACjB,SAAS,MAAM,IAAI;IACxB,OAAO,gBAAgB;AACzB;AACO,SAAS,OAAO,WAAW,EAAE,OAAO;IACzC,OACE,CAAC,CAAC,eAAe,CAAC,CAAC,WAAW,YAAY,kBAAkB,KAAK;AAErE","ignoreList":[0]}},
    {"offset": {"line": 262, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 268, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bip174/src/esm/lib/converter/input/nonWitnessUtxo.js"],"sourcesContent":["import { InputTypes } from '../../typeFields.js';\nimport * as tools from 'uint8array-tools';\nexport function decode(keyVal) {\n  if (keyVal.key[0] !== InputTypes.NON_WITNESS_UTXO) {\n    throw new Error(\n      'Decode Error: could not decode nonWitnessUtxo with key 0x' +\n        tools.toHex(keyVal.key),\n    );\n  }\n  return keyVal.value;\n}\nexport function encode(data) {\n  return {\n    key: new Uint8Array([InputTypes.NON_WITNESS_UTXO]),\n    value: data,\n  };\n}\nexport const expected = 'Uint8Array';\nexport function check(data) {\n  return data instanceof Uint8Array;\n}\nexport function canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.nonWitnessUtxo === undefined;\n}\n"],"names":[],"mappings":";;;;;;;AAAA;AACA;;;AACO,SAAS,OAAO,MAAM;IAC3B,IAAI,OAAO,GAAG,CAAC,EAAE,KAAK,yJAAA,CAAA,aAAU,CAAC,gBAAgB,EAAE;QACjD,MAAM,IAAI,MACR,8DACE,2JAAM,KAAK,CAAC,OAAO,GAAG;IAE5B;IACA,OAAO,OAAO,KAAK;AACrB;AACO,SAAS,OAAO,IAAI;IACzB,OAAO;QACL,KAAK,IAAI,WAAW;YAAC,yJAAA,CAAA,aAAU,CAAC,gBAAgB;SAAC;QACjD,OAAO;IACT;AACF;AACO,MAAM,WAAW;AACjB,SAAS,MAAM,IAAI;IACxB,OAAO,gBAAgB;AACzB;AACO,SAAS,OAAO,WAAW,EAAE,OAAO;IACzC,OAAO,CAAC,CAAC,eAAe,CAAC,CAAC,WAAW,YAAY,cAAc,KAAK;AACtE","ignoreList":[0]}},
    {"offset": {"line": 300, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 306, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bip174/src/esm/lib/converter/input/partialSig.js"],"sourcesContent":["import { InputTypes } from '../../typeFields.js';\nimport * as tools from 'uint8array-tools';\nexport function decode(keyVal) {\n  if (keyVal.key[0] !== InputTypes.PARTIAL_SIG) {\n    throw new Error(\n      'Decode Error: could not decode partialSig with key 0x' +\n        tools.toHex(keyVal.key),\n    );\n  }\n  if (\n    !(keyVal.key.length === 34 || keyVal.key.length === 66) ||\n    ![2, 3, 4].includes(keyVal.key[1])\n  ) {\n    throw new Error(\n      'Decode Error: partialSig has invalid pubkey in key 0x' +\n        tools.toHex(keyVal.key),\n    );\n  }\n  const pubkey = keyVal.key.slice(1);\n  return {\n    pubkey,\n    signature: keyVal.value,\n  };\n}\nexport function encode(pSig) {\n  const head = new Uint8Array([InputTypes.PARTIAL_SIG]);\n  return {\n    key: tools.concat([head, pSig.pubkey]),\n    value: pSig.signature,\n  };\n}\nexport const expected = '{ pubkey: Uint8Array; signature: Uint8Array; }';\nexport function check(data) {\n  return (\n    data.pubkey instanceof Uint8Array &&\n    data.signature instanceof Uint8Array &&\n    [33, 65].includes(data.pubkey.length) &&\n    [2, 3, 4].includes(data.pubkey[0]) &&\n    isDerSigWithSighash(data.signature)\n  );\n}\nfunction isDerSigWithSighash(buf) {\n  if (!(buf instanceof Uint8Array) || buf.length < 9) return false;\n  if (buf[0] !== 0x30) return false;\n  if (buf.length !== buf[1] + 3) return false;\n  if (buf[2] !== 0x02) return false;\n  const rLen = buf[3];\n  if (rLen > 33 || rLen < 1) return false;\n  if (buf[3 + rLen + 1] !== 0x02) return false;\n  const sLen = buf[3 + rLen + 2];\n  if (sLen > 33 || sLen < 1) return false;\n  if (buf.length !== 3 + rLen + 2 + sLen + 2) return false;\n  return true;\n}\nexport function canAddToArray(array, item, dupeSet) {\n  const dupeString = tools.toHex(item.pubkey);\n  if (dupeSet.has(dupeString)) return false;\n  dupeSet.add(dupeString);\n  return (\n    array.filter(v => tools.compare(v.pubkey, item.pubkey) === 0).length === 0\n  );\n}\n"],"names":[],"mappings":";;;;;;;AAAA;AACA;;;AACO,SAAS,OAAO,MAAM;IAC3B,IAAI,OAAO,GAAG,CAAC,EAAE,KAAK,yJAAA,CAAA,aAAU,CAAC,WAAW,EAAE;QAC5C,MAAM,IAAI,MACR,0DACE,2JAAM,KAAK,CAAC,OAAO,GAAG;IAE5B;IACA,IACE,CAAC,CAAC,OAAO,GAAG,CAAC,MAAM,KAAK,MAAM,OAAO,GAAG,CAAC,MAAM,KAAK,EAAE,KACtD,CAAC;QAAC;QAAG;QAAG;KAAE,CAAC,QAAQ,CAAC,OAAO,GAAG,CAAC,EAAE,GACjC;QACA,MAAM,IAAI,MACR,0DACE,2JAAM,KAAK,CAAC,OAAO,GAAG;IAE5B;IACA,MAAM,SAAS,OAAO,GAAG,CAAC,KAAK,CAAC;IAChC,OAAO;QACL;QACA,WAAW,OAAO,KAAK;IACzB;AACF;AACO,SAAS,OAAO,IAAI;IACzB,MAAM,OAAO,IAAI,WAAW;QAAC,yJAAA,CAAA,aAAU,CAAC,WAAW;KAAC;IACpD,OAAO;QACL,KAAK,2JAAM,MAAM,CAAC;YAAC;YAAM,KAAK,MAAM;SAAC;QACrC,OAAO,KAAK,SAAS;IACvB;AACF;AACO,MAAM,WAAW;AACjB,SAAS,MAAM,IAAI;IACxB,OACE,KAAK,MAAM,YAAY,cACvB,KAAK,SAAS,YAAY,cAC1B;QAAC;QAAI;KAAG,CAAC,QAAQ,CAAC,KAAK,MAAM,CAAC,MAAM,KACpC;QAAC;QAAG;QAAG;KAAE,CAAC,QAAQ,CAAC,KAAK,MAAM,CAAC,EAAE,KACjC,oBAAoB,KAAK,SAAS;AAEtC;AACA,SAAS,oBAAoB,GAAG;IAC9B,IAAI,CAAC,CAAC,eAAe,UAAU,KAAK,IAAI,MAAM,GAAG,GAAG,OAAO;IAC3D,IAAI,GAAG,CAAC,EAAE,KAAK,MAAM,OAAO;IAC5B,IAAI,IAAI,MAAM,KAAK,GAAG,CAAC,EAAE,GAAG,GAAG,OAAO;IACtC,IAAI,GAAG,CAAC,EAAE,KAAK,MAAM,OAAO;IAC5B,MAAM,OAAO,GAAG,CAAC,EAAE;IACnB,IAAI,OAAO,MAAM,OAAO,GAAG,OAAO;IAClC,IAAI,GAAG,CAAC,IAAI,OAAO,EAAE,KAAK,MAAM,OAAO;IACvC,MAAM,OAAO,GAAG,CAAC,IAAI,OAAO,EAAE;IAC9B,IAAI,OAAO,MAAM,OAAO,GAAG,OAAO;IAClC,IAAI,IAAI,MAAM,KAAK,IAAI,OAAO,IAAI,OAAO,GAAG,OAAO;IACnD,OAAO;AACT;AACO,SAAS,cAAc,KAAK,EAAE,IAAI,EAAE,OAAO;IAChD,MAAM,aAAa,2JAAM,KAAK,CAAC,KAAK,MAAM;IAC1C,IAAI,QAAQ,GAAG,CAAC,aAAa,OAAO;IACpC,QAAQ,GAAG,CAAC;IACZ,OACE,MAAM,MAAM,CAAC,CAAA,IAAK,2JAAM,OAAO,CAAC,EAAE,MAAM,EAAE,KAAK,MAAM,MAAM,GAAG,MAAM,KAAK;AAE7E","ignoreList":[0]}},
    {"offset": {"line": 376, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 382, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bip174/src/esm/lib/converter/input/porCommitment.js"],"sourcesContent":["import { InputTypes } from '../../typeFields.js';\nimport * as tools from 'uint8array-tools';\nexport function decode(keyVal) {\n  if (keyVal.key[0] !== InputTypes.POR_COMMITMENT) {\n    throw new Error(\n      'Decode Error: could not decode porCommitment with key 0x' +\n        tools.toHex(keyVal.key),\n    );\n  }\n  return tools.toUtf8(keyVal.value);\n}\nexport function encode(data) {\n  const key = new Uint8Array([InputTypes.POR_COMMITMENT]);\n  return {\n    key,\n    value: tools.fromUtf8(data),\n  };\n}\nexport const expected = 'string';\nexport function check(data) {\n  return typeof data === 'string';\n}\nexport function canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.porCommitment === undefined;\n}\n"],"names":[],"mappings":";;;;;;;AAAA;AACA;;;AACO,SAAS,OAAO,MAAM;IAC3B,IAAI,OAAO,GAAG,CAAC,EAAE,KAAK,yJAAA,CAAA,aAAU,CAAC,cAAc,EAAE;QAC/C,MAAM,IAAI,MACR,6DACE,2JAAM,KAAK,CAAC,OAAO,GAAG;IAE5B;IACA,OAAO,2JAAM,MAAM,CAAC,OAAO,KAAK;AAClC;AACO,SAAS,OAAO,IAAI;IACzB,MAAM,MAAM,IAAI,WAAW;QAAC,yJAAA,CAAA,aAAU,CAAC,cAAc;KAAC;IACtD,OAAO;QACL;QACA,OAAO,2JAAM,QAAQ,CAAC;IACxB;AACF;AACO,MAAM,WAAW;AACjB,SAAS,MAAM,IAAI;IACxB,OAAO,OAAO,SAAS;AACzB;AACO,SAAS,OAAO,WAAW,EAAE,OAAO;IACzC,OAAO,CAAC,CAAC,eAAe,CAAC,CAAC,WAAW,YAAY,aAAa,KAAK;AACrE","ignoreList":[0]}},
    {"offset": {"line": 415, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 421, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bip174/src/esm/lib/converter/input/sighashType.js"],"sourcesContent":["import { InputTypes } from '../../typeFields.js';\nimport * as tools from 'uint8array-tools';\nexport function decode(keyVal) {\n  if (keyVal.key[0] !== InputTypes.SIGHASH_TYPE) {\n    throw new Error(\n      'Decode Error: could not decode sighashType with key 0x' +\n        tools.toHex(keyVal.key),\n    );\n  }\n  return Number(tools.readUInt32(keyVal.value, 0, 'LE'));\n}\nexport function encode(data) {\n  const key = Uint8Array.from([InputTypes.SIGHASH_TYPE]);\n  const value = new Uint8Array(4);\n  tools.writeUInt32(value, 0, data, 'LE');\n  return {\n    key,\n    value,\n  };\n}\nexport const expected = 'number';\nexport function check(data) {\n  return typeof data === 'number';\n}\nexport function canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.sighashType === undefined;\n}\n"],"names":[],"mappings":";;;;;;;AAAA;AACA;;;AACO,SAAS,OAAO,MAAM;IAC3B,IAAI,OAAO,GAAG,CAAC,EAAE,KAAK,yJAAA,CAAA,aAAU,CAAC,YAAY,EAAE;QAC7C,MAAM,IAAI,MACR,2DACE,2JAAM,KAAK,CAAC,OAAO,GAAG;IAE5B;IACA,OAAO,OAAO,2JAAM,UAAU,CAAC,OAAO,KAAK,EAAE,GAAG;AAClD;AACO,SAAS,OAAO,IAAI;IACzB,MAAM,MAAM,WAAW,IAAI,CAAC;QAAC,yJAAA,CAAA,aAAU,CAAC,YAAY;KAAC;IACrD,MAAM,QAAQ,IAAI,WAAW;IAC7B,2JAAM,WAAW,CAAC,OAAO,GAAG,MAAM;IAClC,OAAO;QACL;QACA;IACF;AACF;AACO,MAAM,WAAW;AACjB,SAAS,MAAM,IAAI;IACxB,OAAO,OAAO,SAAS;AACzB;AACO,SAAS,OAAO,WAAW,EAAE,OAAO;IACzC,OAAO,CAAC,CAAC,eAAe,CAAC,CAAC,WAAW,YAAY,WAAW,KAAK;AACnE","ignoreList":[0]}},
    {"offset": {"line": 456, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 462, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bip174/src/esm/lib/converter/input/tapKeySig.js"],"sourcesContent":["import { InputTypes } from '../../typeFields.js';\nimport * as tools from 'uint8array-tools';\nexport function decode(keyVal) {\n  if (keyVal.key[0] !== InputTypes.TAP_KEY_SIG || keyVal.key.length !== 1) {\n    throw new Error(\n      'Decode Error: could not decode tapKeySig with key 0x' +\n        tools.toHex(keyVal.key),\n    );\n  }\n  if (!check(keyVal.value)) {\n    throw new Error(\n      'Decode Error: tapKeySig not a valid 64-65-byte BIP340 signature',\n    );\n  }\n  return keyVal.value;\n}\nexport function encode(value) {\n  const key = Uint8Array.from([InputTypes.TAP_KEY_SIG]);\n  return { key, value };\n}\nexport const expected = 'Uint8Array';\nexport function check(data) {\n  return (\n    data instanceof Uint8Array && (data.length === 64 || data.length === 65)\n  );\n}\nexport function canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.tapKeySig === undefined;\n}\n"],"names":[],"mappings":";;;;;;;AAAA;AACA;;;AACO,SAAS,OAAO,MAAM;IAC3B,IAAI,OAAO,GAAG,CAAC,EAAE,KAAK,yJAAA,CAAA,aAAU,CAAC,WAAW,IAAI,OAAO,GAAG,CAAC,MAAM,KAAK,GAAG;QACvE,MAAM,IAAI,MACR,yDACE,2JAAM,KAAK,CAAC,OAAO,GAAG;IAE5B;IACA,IAAI,CAAC,MAAM,OAAO,KAAK,GAAG;QACxB,MAAM,IAAI,MACR;IAEJ;IACA,OAAO,OAAO,KAAK;AACrB;AACO,SAAS,OAAO,KAAK;IAC1B,MAAM,MAAM,WAAW,IAAI,CAAC;QAAC,yJAAA,CAAA,aAAU,CAAC,WAAW;KAAC;IACpD,OAAO;QAAE;QAAK;IAAM;AACtB;AACO,MAAM,WAAW;AACjB,SAAS,MAAM,IAAI;IACxB,OACE,gBAAgB,cAAc,CAAC,KAAK,MAAM,KAAK,MAAM,KAAK,MAAM,KAAK,EAAE;AAE3E;AACO,SAAS,OAAO,WAAW,EAAE,OAAO;IACzC,OAAO,CAAC,CAAC,eAAe,CAAC,CAAC,WAAW,YAAY,SAAS,KAAK;AACjE","ignoreList":[0]}},
    {"offset": {"line": 498, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 504, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bip174/src/esm/lib/converter/input/tapLeafScript.js"],"sourcesContent":["import { InputTypes } from '../../typeFields.js';\nimport * as tools from 'uint8array-tools';\nexport function decode(keyVal) {\n  if (keyVal.key[0] !== InputTypes.TAP_LEAF_SCRIPT) {\n    throw new Error(\n      'Decode Error: could not decode tapLeafScript with key 0x' +\n        tools.toHex(keyVal.key),\n    );\n  }\n  if ((keyVal.key.length - 2) % 32 !== 0) {\n    throw new Error(\n      'Decode Error: tapLeafScript has invalid control block in key 0x' +\n        tools.toHex(keyVal.key),\n    );\n  }\n  const leafVersion = keyVal.value[keyVal.value.length - 1];\n  if ((keyVal.key[1] & 0xfe) !== leafVersion) {\n    throw new Error(\n      'Decode Error: tapLeafScript bad leaf version in key 0x' +\n        tools.toHex(keyVal.key),\n    );\n  }\n  const script = keyVal.value.slice(0, -1);\n  const controlBlock = keyVal.key.slice(1);\n  return { controlBlock, script, leafVersion };\n}\nexport function encode(tScript) {\n  const head = Uint8Array.from([InputTypes.TAP_LEAF_SCRIPT]);\n  const verBuf = Uint8Array.from([tScript.leafVersion]);\n  return {\n    key: tools.concat([head, tScript.controlBlock]),\n    value: tools.concat([tScript.script, verBuf]),\n  };\n}\nexport const expected =\n  '{ controlBlock: Uint8Array; leafVersion: number, script: Uint8Array; }';\nexport function check(data) {\n  return (\n    data.controlBlock instanceof Uint8Array &&\n    (data.controlBlock.length - 1) % 32 === 0 &&\n    (data.controlBlock[0] & 0xfe) === data.leafVersion &&\n    data.script instanceof Uint8Array\n  );\n}\nexport function canAddToArray(array, item, dupeSet) {\n  const dupeString = tools.toHex(item.controlBlock);\n  if (dupeSet.has(dupeString)) return false;\n  dupeSet.add(dupeString);\n  return (\n    array.filter(v => tools.compare(v.controlBlock, item.controlBlock) === 0)\n      .length === 0\n  );\n}\n"],"names":[],"mappings":";;;;;;;AAAA;AACA;;;AACO,SAAS,OAAO,MAAM;IAC3B,IAAI,OAAO,GAAG,CAAC,EAAE,KAAK,yJAAA,CAAA,aAAU,CAAC,eAAe,EAAE;QAChD,MAAM,IAAI,MACR,6DACE,2JAAM,KAAK,CAAC,OAAO,GAAG;IAE5B;IACA,IAAI,CAAC,OAAO,GAAG,CAAC,MAAM,GAAG,CAAC,IAAI,OAAO,GAAG;QACtC,MAAM,IAAI,MACR,oEACE,2JAAM,KAAK,CAAC,OAAO,GAAG;IAE5B;IACA,MAAM,cAAc,OAAO,KAAK,CAAC,OAAO,KAAK,CAAC,MAAM,GAAG,EAAE;IACzD,IAAI,CAAC,OAAO,GAAG,CAAC,EAAE,GAAG,IAAI,MAAM,aAAa;QAC1C,MAAM,IAAI,MACR,2DACE,2JAAM,KAAK,CAAC,OAAO,GAAG;IAE5B;IACA,MAAM,SAAS,OAAO,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC;IACtC,MAAM,eAAe,OAAO,GAAG,CAAC,KAAK,CAAC;IACtC,OAAO;QAAE;QAAc;QAAQ;IAAY;AAC7C;AACO,SAAS,OAAO,OAAO;IAC5B,MAAM,OAAO,WAAW,IAAI,CAAC;QAAC,yJAAA,CAAA,aAAU,CAAC,eAAe;KAAC;IACzD,MAAM,SAAS,WAAW,IAAI,CAAC;QAAC,QAAQ,WAAW;KAAC;IACpD,OAAO;QACL,KAAK,2JAAM,MAAM,CAAC;YAAC;YAAM,QAAQ,YAAY;SAAC;QAC9C,OAAO,2JAAM,MAAM,CAAC;YAAC,QAAQ,MAAM;YAAE;SAAO;IAC9C;AACF;AACO,MAAM,WACX;AACK,SAAS,MAAM,IAAI;IACxB,OACE,KAAK,YAAY,YAAY,cAC7B,CAAC,KAAK,YAAY,CAAC,MAAM,GAAG,CAAC,IAAI,OAAO,KACxC,CAAC,KAAK,YAAY,CAAC,EAAE,GAAG,IAAI,MAAM,KAAK,WAAW,IAClD,KAAK,MAAM,YAAY;AAE3B;AACO,SAAS,cAAc,KAAK,EAAE,IAAI,EAAE,OAAO;IAChD,MAAM,aAAa,2JAAM,KAAK,CAAC,KAAK,YAAY;IAChD,IAAI,QAAQ,GAAG,CAAC,aAAa,OAAO;IACpC,QAAQ,GAAG,CAAC;IACZ,OACE,MAAM,MAAM,CAAC,CAAA,IAAK,2JAAM,OAAO,CAAC,EAAE,YAAY,EAAE,KAAK,YAAY,MAAM,GACpE,MAAM,KAAK;AAElB","ignoreList":[0]}},
    {"offset": {"line": 562, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 568, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bip174/src/esm/lib/converter/input/tapMerkleRoot.js"],"sourcesContent":["import { InputTypes } from '../../typeFields.js';\nimport * as tools from 'uint8array-tools';\nexport function decode(keyVal) {\n  if (keyVal.key[0] !== InputTypes.TAP_MERKLE_ROOT || keyVal.key.length !== 1) {\n    throw new Error(\n      'Decode Error: could not decode tapMerkleRoot with key 0x' +\n        tools.toHex(keyVal.key),\n    );\n  }\n  if (!check(keyVal.value)) {\n    throw new Error('Decode Error: tapMerkleRoot not a 32-byte hash');\n  }\n  return keyVal.value;\n}\nexport function encode(value) {\n  const key = Uint8Array.from([InputTypes.TAP_MERKLE_ROOT]);\n  return { key, value };\n}\nexport const expected = 'Uint8Array';\nexport function check(data) {\n  return data instanceof Uint8Array && data.length === 32;\n}\nexport function canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.tapMerkleRoot === undefined;\n}\n"],"names":[],"mappings":";;;;;;;AAAA;AACA;;;AACO,SAAS,OAAO,MAAM;IAC3B,IAAI,OAAO,GAAG,CAAC,EAAE,KAAK,yJAAA,CAAA,aAAU,CAAC,eAAe,IAAI,OAAO,GAAG,CAAC,MAAM,KAAK,GAAG;QAC3E,MAAM,IAAI,MACR,6DACE,2JAAM,KAAK,CAAC,OAAO,GAAG;IAE5B;IACA,IAAI,CAAC,MAAM,OAAO,KAAK,GAAG;QACxB,MAAM,IAAI,MAAM;IAClB;IACA,OAAO,OAAO,KAAK;AACrB;AACO,SAAS,OAAO,KAAK;IAC1B,MAAM,MAAM,WAAW,IAAI,CAAC;QAAC,yJAAA,CAAA,aAAU,CAAC,eAAe;KAAC;IACxD,OAAO;QAAE;QAAK;IAAM;AACtB;AACO,MAAM,WAAW;AACjB,SAAS,MAAM,IAAI;IACxB,OAAO,gBAAgB,cAAc,KAAK,MAAM,KAAK;AACvD;AACO,SAAS,OAAO,WAAW,EAAE,OAAO;IACzC,OAAO,CAAC,CAAC,eAAe,CAAC,CAAC,WAAW,YAAY,aAAa,KAAK;AACrE","ignoreList":[0]}},
    {"offset": {"line": 604, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 610, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bip174/src/esm/lib/converter/input/tapScriptSig.js"],"sourcesContent":["import { InputTypes } from '../../typeFields.js';\nimport * as tools from 'uint8array-tools';\nexport function decode(keyVal) {\n  if (keyVal.key[0] !== InputTypes.TAP_SCRIPT_SIG) {\n    throw new Error(\n      'Decode Error: could not decode tapScriptSig with key 0x' +\n        tools.toHex(keyVal.key),\n    );\n  }\n  if (keyVal.key.length !== 65) {\n    throw new Error(\n      'Decode Error: tapScriptSig has invalid key 0x' + tools.toHex(keyVal.key),\n    );\n  }\n  if (keyVal.value.length !== 64 && keyVal.value.length !== 65) {\n    throw new Error(\n      'Decode Error: tapScriptSig has invalid signature in key 0x' +\n        tools.toHex(keyVal.key),\n    );\n  }\n  const pubkey = keyVal.key.slice(1, 33);\n  const leafHash = keyVal.key.slice(33);\n  return {\n    pubkey,\n    leafHash,\n    signature: keyVal.value,\n  };\n}\nexport function encode(tSig) {\n  const head = Uint8Array.from([InputTypes.TAP_SCRIPT_SIG]);\n  return {\n    key: tools.concat([head, tSig.pubkey, tSig.leafHash]),\n    value: tSig.signature,\n  };\n}\nexport const expected =\n  '{ pubkey: Uint8Array; leafHash: Uint8Array; signature: Uint8Array; }';\nexport function check(data) {\n  return (\n    data.pubkey instanceof Uint8Array &&\n    data.leafHash instanceof Uint8Array &&\n    data.signature instanceof Uint8Array &&\n    data.pubkey.length === 32 &&\n    data.leafHash.length === 32 &&\n    (data.signature.length === 64 || data.signature.length === 65)\n  );\n}\nexport function canAddToArray(array, item, dupeSet) {\n  const dupeString = tools.toHex(item.pubkey) + tools.toHex(item.leafHash);\n  if (dupeSet.has(dupeString)) return false;\n  dupeSet.add(dupeString);\n  return (\n    array.filter(\n      v =>\n        tools.compare(v.pubkey, item.pubkey) === 0 &&\n        tools.compare(v.leafHash, item.leafHash) === 0,\n    ).length === 0\n  );\n}\n"],"names":[],"mappings":";;;;;;;AAAA;AACA;;;AACO,SAAS,OAAO,MAAM;IAC3B,IAAI,OAAO,GAAG,CAAC,EAAE,KAAK,yJAAA,CAAA,aAAU,CAAC,cAAc,EAAE;QAC/C,MAAM,IAAI,MACR,4DACE,2JAAM,KAAK,CAAC,OAAO,GAAG;IAE5B;IACA,IAAI,OAAO,GAAG,CAAC,MAAM,KAAK,IAAI;QAC5B,MAAM,IAAI,MACR,kDAAkD,2JAAM,KAAK,CAAC,OAAO,GAAG;IAE5E;IACA,IAAI,OAAO,KAAK,CAAC,MAAM,KAAK,MAAM,OAAO,KAAK,CAAC,MAAM,KAAK,IAAI;QAC5D,MAAM,IAAI,MACR,+DACE,2JAAM,KAAK,CAAC,OAAO,GAAG;IAE5B;IACA,MAAM,SAAS,OAAO,GAAG,CAAC,KAAK,CAAC,GAAG;IACnC,MAAM,WAAW,OAAO,GAAG,CAAC,KAAK,CAAC;IAClC,OAAO;QACL;QACA;QACA,WAAW,OAAO,KAAK;IACzB;AACF;AACO,SAAS,OAAO,IAAI;IACzB,MAAM,OAAO,WAAW,IAAI,CAAC;QAAC,yJAAA,CAAA,aAAU,CAAC,cAAc;KAAC;IACxD,OAAO;QACL,KAAK,2JAAM,MAAM,CAAC;YAAC;YAAM,KAAK,MAAM;YAAE,KAAK,QAAQ;SAAC;QACpD,OAAO,KAAK,SAAS;IACvB;AACF;AACO,MAAM,WACX;AACK,SAAS,MAAM,IAAI;IACxB,OACE,KAAK,MAAM,YAAY,cACvB,KAAK,QAAQ,YAAY,cACzB,KAAK,SAAS,YAAY,cAC1B,KAAK,MAAM,CAAC,MAAM,KAAK,MACvB,KAAK,QAAQ,CAAC,MAAM,KAAK,MACzB,CAAC,KAAK,SAAS,CAAC,MAAM,KAAK,MAAM,KAAK,SAAS,CAAC,MAAM,KAAK,EAAE;AAEjE;AACO,SAAS,cAAc,KAAK,EAAE,IAAI,EAAE,OAAO;IAChD,MAAM,aAAa,2JAAM,KAAK,CAAC,KAAK,MAAM,IAAI,2JAAM,KAAK,CAAC,KAAK,QAAQ;IACvE,IAAI,QAAQ,GAAG,CAAC,aAAa,OAAO;IACpC,QAAQ,GAAG,CAAC;IACZ,OACE,MAAM,MAAM,CACV,CAAA,IACE,2JAAM,OAAO,CAAC,EAAE,MAAM,EAAE,KAAK,MAAM,MAAM,KACzC,2JAAM,OAAO,CAAC,EAAE,QAAQ,EAAE,KAAK,QAAQ,MAAM,GAC/C,MAAM,KAAK;AAEjB","ignoreList":[0]}},
    {"offset": {"line": 662, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 668, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bip174/src/esm/lib/converter/input/witnessUtxo.js"],"sourcesContent":["import { InputTypes } from '../../typeFields.js';\nimport * as tools from 'uint8array-tools';\nimport * as varuint from 'varuint-bitcoin';\nexport function decode(keyVal) {\n  if (keyVal.key[0] !== InputTypes.WITNESS_UTXO) {\n    throw new Error(\n      'Decode Error: could not decode witnessUtxo with key 0x' +\n        tools.toHex(keyVal.key),\n    );\n  }\n  const value = tools.readInt64(keyVal.value, 0, 'LE');\n  let _offset = 8;\n  const { numberValue: scriptLen, bytes } = varuint.decode(\n    keyVal.value,\n    _offset,\n  );\n  _offset += bytes;\n  const script = keyVal.value.slice(_offset);\n  if (script.length !== scriptLen) {\n    throw new Error('Decode Error: WITNESS_UTXO script is not proper length');\n  }\n  return {\n    script,\n    value,\n  };\n}\nexport function encode(data) {\n  const { script, value } = data;\n  const varuintlen = varuint.encodingLength(script.length);\n  const result = new Uint8Array(8 + varuintlen + script.length);\n  tools.writeInt64(result, 0, BigInt(value), 'LE');\n  varuint.encode(script.length, result, 8);\n  result.set(script, 8 + varuintlen);\n  return {\n    key: Uint8Array.from([InputTypes.WITNESS_UTXO]),\n    value: result,\n  };\n}\nexport const expected = '{ script: Uint8Array; value: bigint; }';\nexport function check(data) {\n  return data.script instanceof Uint8Array && typeof data.value === 'bigint';\n}\nexport function canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.witnessUtxo === undefined;\n}\n"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;;;;AACO,SAAS,OAAO,MAAM;IAC3B,IAAI,OAAO,GAAG,CAAC,EAAE,KAAK,yJAAA,CAAA,aAAU,CAAC,YAAY,EAAE;QAC7C,MAAM,IAAI,MACR,2DACE,2JAAM,KAAK,CAAC,OAAO,GAAG;IAE5B;IACA,MAAM,QAAQ,2JAAM,SAAS,CAAC,OAAO,KAAK,EAAE,GAAG;IAC/C,IAAI,UAAU;IACd,MAAM,EAAE,aAAa,SAAS,EAAE,KAAK,EAAE,GAAG,0JAAQ,MAAM,CACtD,OAAO,KAAK,EACZ;IAEF,WAAW;IACX,MAAM,SAAS,OAAO,KAAK,CAAC,KAAK,CAAC;IAClC,IAAI,OAAO,MAAM,KAAK,WAAW;QAC/B,MAAM,IAAI,MAAM;IAClB;IACA,OAAO;QACL;QACA;IACF;AACF;AACO,SAAS,OAAO,IAAI;IACzB,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,GAAG;IAC1B,MAAM,aAAa,0JAAQ,cAAc,CAAC,OAAO,MAAM;IACvD,MAAM,SAAS,IAAI,WAAW,IAAI,aAAa,OAAO,MAAM;IAC5D,2JAAM,UAAU,CAAC,QAAQ,GAAG,OAAO,QAAQ;IAC3C,0JAAQ,MAAM,CAAC,OAAO,MAAM,EAAE,QAAQ;IACtC,OAAO,GAAG,CAAC,QAAQ,IAAI;IACvB,OAAO;QACL,KAAK,WAAW,IAAI,CAAC;YAAC,yJAAA,CAAA,aAAU,CAAC,YAAY;SAAC;QAC9C,OAAO;IACT;AACF;AACO,MAAM,WAAW;AACjB,SAAS,MAAM,IAAI;IACxB,OAAO,KAAK,MAAM,YAAY,cAAc,OAAO,KAAK,KAAK,KAAK;AACpE;AACO,SAAS,OAAO,WAAW,EAAE,OAAO;IACzC,OAAO,CAAC,CAAC,eAAe,CAAC,CAAC,WAAW,YAAY,WAAW,KAAK;AACnE","ignoreList":[0]}},
    {"offset": {"line": 719, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 725, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bip174/src/esm/lib/converter/output/tapTree.js"],"sourcesContent":["import { OutputTypes } from '../../typeFields.js';\nimport * as varuint from 'varuint-bitcoin';\nimport * as tools from 'uint8array-tools';\nexport function decode(keyVal) {\n  if (keyVal.key[0] !== OutputTypes.TAP_TREE || keyVal.key.length !== 1) {\n    throw new Error(\n      'Decode Error: could not decode tapTree with key 0x' +\n        tools.toHex(keyVal.key),\n    );\n  }\n  let _offset = 0;\n  const data = [];\n  while (_offset < keyVal.value.length) {\n    const depth = keyVal.value[_offset++];\n    const leafVersion = keyVal.value[_offset++];\n    const { numberValue: scriptLen, bytes } = varuint.decode(\n      keyVal.value,\n      _offset,\n    );\n    _offset += bytes;\n    data.push({\n      depth,\n      leafVersion,\n      script: keyVal.value.slice(_offset, _offset + scriptLen),\n    });\n    _offset += scriptLen;\n  }\n  return { leaves: data };\n}\nexport function encode(tree) {\n  const key = Uint8Array.from([OutputTypes.TAP_TREE]);\n  const bufs = [].concat(\n    ...tree.leaves.map(tapLeaf => [\n      Uint8Array.of(tapLeaf.depth, tapLeaf.leafVersion),\n      varuint.encode(BigInt(tapLeaf.script.length)).buffer,\n      tapLeaf.script,\n    ]),\n  );\n  return {\n    key,\n    value: tools.concat(bufs),\n  };\n}\nexport const expected =\n  '{ leaves: [{ depth: number; leafVersion: number, script: Uint8Array; }] }';\nexport function check(data) {\n  return (\n    Array.isArray(data.leaves) &&\n    data.leaves.every(\n      tapLeaf =>\n        tapLeaf.depth >= 0 &&\n        tapLeaf.depth <= 128 &&\n        (tapLeaf.leafVersion & 0xfe) === tapLeaf.leafVersion &&\n        tapLeaf.script instanceof Uint8Array,\n    )\n  );\n}\nexport function canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.tapTree === undefined;\n}\n"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;;;;AACO,SAAS,OAAO,MAAM;IAC3B,IAAI,OAAO,GAAG,CAAC,EAAE,KAAK,yJAAA,CAAA,cAAW,CAAC,QAAQ,IAAI,OAAO,GAAG,CAAC,MAAM,KAAK,GAAG;QACrE,MAAM,IAAI,MACR,uDACE,2JAAM,KAAK,CAAC,OAAO,GAAG;IAE5B;IACA,IAAI,UAAU;IACd,MAAM,OAAO,EAAE;IACf,MAAO,UAAU,OAAO,KAAK,CAAC,MAAM,CAAE;QACpC,MAAM,QAAQ,OAAO,KAAK,CAAC,UAAU;QACrC,MAAM,cAAc,OAAO,KAAK,CAAC,UAAU;QAC3C,MAAM,EAAE,aAAa,SAAS,EAAE,KAAK,EAAE,GAAG,0JAAQ,MAAM,CACtD,OAAO,KAAK,EACZ;QAEF,WAAW;QACX,KAAK,IAAI,CAAC;YACR;YACA;YACA,QAAQ,OAAO,KAAK,CAAC,KAAK,CAAC,SAAS,UAAU;QAChD;QACA,WAAW;IACb;IACA,OAAO;QAAE,QAAQ;IAAK;AACxB;AACO,SAAS,OAAO,IAAI;IACzB,MAAM,MAAM,WAAW,IAAI,CAAC;QAAC,yJAAA,CAAA,cAAW,CAAC,QAAQ;KAAC;IAClD,MAAM,OAAO,EAAE,CAAC,MAAM,IACjB,KAAK,MAAM,CAAC,GAAG,CAAC,CAAA,UAAW;YAC5B,WAAW,EAAE,CAAC,QAAQ,KAAK,EAAE,QAAQ,WAAW;YAChD,0JAAQ,MAAM,CAAC,OAAO,QAAQ,MAAM,CAAC,MAAM,GAAG,MAAM;YACpD,QAAQ,MAAM;SACf;IAEH,OAAO;QACL;QACA,OAAO,2JAAM,MAAM,CAAC;IACtB;AACF;AACO,MAAM,WACX;AACK,SAAS,MAAM,IAAI;IACxB,OACE,MAAM,OAAO,CAAC,KAAK,MAAM,KACzB,KAAK,MAAM,CAAC,KAAK,CACf,CAAA,UACE,QAAQ,KAAK,IAAI,KACjB,QAAQ,KAAK,IAAI,OACjB,CAAC,QAAQ,WAAW,GAAG,IAAI,MAAM,QAAQ,WAAW,IACpD,QAAQ,MAAM,YAAY;AAGlC;AACO,SAAS,OAAO,WAAW,EAAE,OAAO;IACzC,OAAO,CAAC,CAAC,eAAe,CAAC,CAAC,WAAW,YAAY,OAAO,KAAK;AAC/D","ignoreList":[0]}},
    {"offset": {"line": 781, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 787, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bip174/src/esm/lib/converter/shared/bip32Derivation.js"],"sourcesContent":["import * as tools from 'uint8array-tools';\nconst range = n => [...Array(n).keys()];\nconst isValidDERKey = pubkey =>\n  (pubkey.length === 33 && [2, 3].includes(pubkey[0])) ||\n  (pubkey.length === 65 && 4 === pubkey[0]);\nexport function makeConverter(TYPE_BYTE, isValidPubkey = isValidDERKey) {\n  function decode(keyVal) {\n    if (keyVal.key[0] !== TYPE_BYTE) {\n      throw new Error(\n        'Decode Error: could not decode bip32Derivation with key 0x' +\n          tools.toHex(keyVal.key),\n      );\n    }\n    const pubkey = keyVal.key.slice(1);\n    if (!isValidPubkey(pubkey)) {\n      throw new Error(\n        'Decode Error: bip32Derivation has invalid pubkey in key 0x' +\n          tools.toHex(keyVal.key),\n      );\n    }\n    if ((keyVal.value.length / 4) % 1 !== 0) {\n      throw new Error(\n        'Decode Error: Input BIP32_DERIVATION value length should be multiple of 4',\n      );\n    }\n    const data = {\n      masterFingerprint: keyVal.value.slice(0, 4),\n      pubkey,\n      path: 'm',\n    };\n    for (const i of range(keyVal.value.length / 4 - 1)) {\n      const val = tools.readUInt32(keyVal.value, i * 4 + 4, 'LE');\n      const isHard = !!(val & 0x80000000);\n      const idx = val & 0x7fffffff;\n      data.path += '/' + idx.toString(10) + (isHard ? \"'\" : '');\n    }\n    return data;\n  }\n  function encode(data) {\n    const head = Uint8Array.from([TYPE_BYTE]);\n    const key = tools.concat([head, data.pubkey]);\n    const splitPath = data.path.split('/');\n    const value = new Uint8Array(splitPath.length * 4);\n    value.set(data.masterFingerprint, 0);\n    let offset = 4;\n    splitPath.slice(1).forEach(level => {\n      const isHard = level.slice(-1) === \"'\";\n      let num = 0x7fffffff & parseInt(isHard ? level.slice(0, -1) : level, 10);\n      if (isHard) num += 0x80000000;\n      tools.writeUInt32(value, offset, num, 'LE');\n      offset += 4;\n    });\n    return {\n      key,\n      value,\n    };\n  }\n  const expected =\n    '{ masterFingerprint: Uint8Array; pubkey: Uint8Array; path: string; }';\n  function check(data) {\n    return (\n      data.pubkey instanceof Uint8Array &&\n      data.masterFingerprint instanceof Uint8Array &&\n      typeof data.path === 'string' &&\n      isValidPubkey(data.pubkey) &&\n      data.masterFingerprint.length === 4\n    );\n  }\n  function canAddToArray(array, item, dupeSet) {\n    const dupeString = tools.toHex(item.pubkey);\n    if (dupeSet.has(dupeString)) return false;\n    dupeSet.add(dupeString);\n    return (\n      array.filter(v => tools.compare(v.pubkey, item.pubkey) === 0).length === 0\n    );\n  }\n  return {\n    decode,\n    encode,\n    check,\n    expected,\n    canAddToArray,\n  };\n}\n"],"names":[],"mappings":";;;AAAA;;AACA,MAAM,QAAQ,CAAA,IAAK;WAAI,MAAM,GAAG,IAAI;KAAG;AACvC,MAAM,gBAAgB,CAAA,SACpB,AAAC,OAAO,MAAM,KAAK,MAAM;QAAC;QAAG;KAAE,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE,KACjD,OAAO,MAAM,KAAK,MAAM,MAAM,MAAM,CAAC,EAAE;AACnC,SAAS,cAAc,SAAS,EAAE,gBAAgB,aAAa;IACpE,SAAS,OAAO,MAAM;QACpB,IAAI,OAAO,GAAG,CAAC,EAAE,KAAK,WAAW;YAC/B,MAAM,IAAI,MACR,+DACE,2JAAM,KAAK,CAAC,OAAO,GAAG;QAE5B;QACA,MAAM,SAAS,OAAO,GAAG,CAAC,KAAK,CAAC;QAChC,IAAI,CAAC,cAAc,SAAS;YAC1B,MAAM,IAAI,MACR,+DACE,2JAAM,KAAK,CAAC,OAAO,GAAG;QAE5B;QACA,IAAI,AAAC,OAAO,KAAK,CAAC,MAAM,GAAG,IAAK,MAAM,GAAG;YACvC,MAAM,IAAI,MACR;QAEJ;QACA,MAAM,OAAO;YACX,mBAAmB,OAAO,KAAK,CAAC,KAAK,CAAC,GAAG;YACzC;YACA,MAAM;QACR;QACA,KAAK,MAAM,KAAK,MAAM,OAAO,KAAK,CAAC,MAAM,GAAG,IAAI,GAAI;YAClD,MAAM,MAAM,2JAAM,UAAU,CAAC,OAAO,KAAK,EAAE,IAAI,IAAI,GAAG;YACtD,MAAM,SAAS,CAAC,CAAC,CAAC,MAAM,UAAU;YAClC,MAAM,MAAM,MAAM;YAClB,KAAK,IAAI,IAAI,MAAM,IAAI,QAAQ,CAAC,MAAM,CAAC,SAAS,MAAM,EAAE;QAC1D;QACA,OAAO;IACT;IACA,SAAS,OAAO,IAAI;QAClB,MAAM,OAAO,WAAW,IAAI,CAAC;YAAC;SAAU;QACxC,MAAM,MAAM,2JAAM,MAAM,CAAC;YAAC;YAAM,KAAK,MAAM;SAAC;QAC5C,MAAM,YAAY,KAAK,IAAI,CAAC,KAAK,CAAC;QAClC,MAAM,QAAQ,IAAI,WAAW,UAAU,MAAM,GAAG;QAChD,MAAM,GAAG,CAAC,KAAK,iBAAiB,EAAE;QAClC,IAAI,SAAS;QACb,UAAU,KAAK,CAAC,GAAG,OAAO,CAAC,CAAA;YACzB,MAAM,SAAS,MAAM,KAAK,CAAC,CAAC,OAAO;YACnC,IAAI,MAAM,aAAa,SAAS,SAAS,MAAM,KAAK,CAAC,GAAG,CAAC,KAAK,OAAO;YACrE,IAAI,QAAQ,OAAO;YACnB,2JAAM,WAAW,CAAC,OAAO,QAAQ,KAAK;YACtC,UAAU;QACZ;QACA,OAAO;YACL;YACA;QACF;IACF;IACA,MAAM,WACJ;IACF,SAAS,MAAM,IAAI;QACjB,OACE,KAAK,MAAM,YAAY,cACvB,KAAK,iBAAiB,YAAY,cAClC,OAAO,KAAK,IAAI,KAAK,YACrB,cAAc,KAAK,MAAM,KACzB,KAAK,iBAAiB,CAAC,MAAM,KAAK;IAEtC;IACA,SAAS,cAAc,KAAK,EAAE,IAAI,EAAE,OAAO;QACzC,MAAM,aAAa,2JAAM,KAAK,CAAC,KAAK,MAAM;QAC1C,IAAI,QAAQ,GAAG,CAAC,aAAa,OAAO;QACpC,QAAQ,GAAG,CAAC;QACZ,OACE,MAAM,MAAM,CAAC,CAAA,IAAK,2JAAM,OAAO,CAAC,EAAE,MAAM,EAAE,KAAK,MAAM,MAAM,GAAG,MAAM,KAAK;IAE7E;IACA,OAAO;QACL;QACA;QACA;QACA;QACA;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 866, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 872, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bip174/src/esm/lib/converter/shared/checkPubkey.js"],"sourcesContent":["import * as tools from 'uint8array-tools';\nexport function makeChecker(pubkeyTypes) {\n  return checkPubkey;\n  function checkPubkey(keyVal) {\n    let pubkey;\n    if (pubkeyTypes.includes(keyVal.key[0])) {\n      pubkey = keyVal.key.slice(1);\n      if (\n        !(pubkey.length === 33 || pubkey.length === 65) ||\n        ![2, 3, 4].includes(pubkey[0])\n      ) {\n        throw new Error(\n          'Format Error: invalid pubkey in key 0x' + tools.toHex(keyVal.key),\n        );\n      }\n    }\n    return pubkey;\n  }\n}\n"],"names":[],"mappings":";;;AAAA;;AACO,SAAS,YAAY,WAAW;IACrC,OAAO;;IACP,SAAS,YAAY,MAAM;QACzB,IAAI;QACJ,IAAI,YAAY,QAAQ,CAAC,OAAO,GAAG,CAAC,EAAE,GAAG;YACvC,SAAS,OAAO,GAAG,CAAC,KAAK,CAAC;YAC1B,IACE,CAAC,CAAC,OAAO,MAAM,KAAK,MAAM,OAAO,MAAM,KAAK,EAAE,KAC9C,CAAC;gBAAC;gBAAG;gBAAG;aAAE,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE,GAC7B;gBACA,MAAM,IAAI,MACR,2CAA2C,2JAAM,KAAK,CAAC,OAAO,GAAG;YAErE;QACF;QACA,OAAO;IACT;AACF","ignoreList":[0]}},
    {"offset": {"line": 895, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 901, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bip174/src/esm/lib/converter/shared/redeemScript.js"],"sourcesContent":["import * as tools from 'uint8array-tools';\nexport function makeConverter(TYPE_BYTE) {\n  function decode(keyVal) {\n    if (keyVal.key[0] !== TYPE_BYTE) {\n      throw new Error(\n        'Decode Error: could not decode redeemScript with key 0x' +\n          tools.toHex(keyVal.key),\n      );\n    }\n    return keyVal.value;\n  }\n  function encode(data) {\n    const key = Uint8Array.from([TYPE_BYTE]);\n    return {\n      key,\n      value: data,\n    };\n  }\n  const expected = 'Uint8Array';\n  function check(data) {\n    return data instanceof Uint8Array;\n  }\n  function canAdd(currentData, newData) {\n    return !!currentData && !!newData && currentData.redeemScript === undefined;\n  }\n  return {\n    decode,\n    encode,\n    check,\n    expected,\n    canAdd,\n  };\n}\n"],"names":[],"mappings":";;;AAAA;;AACO,SAAS,cAAc,SAAS;IACrC,SAAS,OAAO,MAAM;QACpB,IAAI,OAAO,GAAG,CAAC,EAAE,KAAK,WAAW;YAC/B,MAAM,IAAI,MACR,4DACE,2JAAM,KAAK,CAAC,OAAO,GAAG;QAE5B;QACA,OAAO,OAAO,KAAK;IACrB;IACA,SAAS,OAAO,IAAI;QAClB,MAAM,MAAM,WAAW,IAAI,CAAC;YAAC;SAAU;QACvC,OAAO;YACL;YACA,OAAO;QACT;IACF;IACA,MAAM,WAAW;IACjB,SAAS,MAAM,IAAI;QACjB,OAAO,gBAAgB;IACzB;IACA,SAAS,OAAO,WAAW,EAAE,OAAO;QAClC,OAAO,CAAC,CAAC,eAAe,CAAC,CAAC,WAAW,YAAY,YAAY,KAAK;IACpE;IACA,OAAO;QACL;QACA;QACA;QACA;QACA;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 937, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 943, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bip174/src/esm/lib/converter/shared/tapBip32Derivation.js"],"sourcesContent":["import * as varuint from 'varuint-bitcoin';\nimport * as tools from 'uint8array-tools';\nimport * as bip32Derivation from './bip32Derivation.js';\nconst isValidBIP340Key = pubkey => pubkey.length === 32;\nexport function makeConverter(TYPE_BYTE) {\n  const parent = bip32Derivation.makeConverter(TYPE_BYTE, isValidBIP340Key);\n  function decode(keyVal) {\n    const { numberValue: nHashes, bytes: nHashesLen } = varuint.decode(\n      keyVal.value,\n    );\n    const base = parent.decode({\n      key: keyVal.key,\n      value: keyVal.value.slice(nHashesLen + Number(nHashes) * 32),\n    });\n    const leafHashes = new Array(Number(nHashes));\n    for (let i = 0, _offset = nHashesLen; i < nHashes; i++, _offset += 32) {\n      leafHashes[i] = keyVal.value.slice(_offset, _offset + 32);\n    }\n    return { ...base, leafHashes };\n  }\n  function encode(data) {\n    const base = parent.encode(data);\n    const nHashesLen = varuint.encodingLength(data.leafHashes.length);\n    const nHashesBuf = new Uint8Array(nHashesLen);\n    varuint.encode(data.leafHashes.length, nHashesBuf);\n    const value = tools.concat([nHashesBuf, ...data.leafHashes, base.value]);\n    return { ...base, value };\n  }\n  const expected =\n    '{ ' +\n    'masterFingerprint: Uint8Array; ' +\n    'pubkey: Uint8Array; ' +\n    'path: string; ' +\n    'leafHashes: Uint8Array[]; ' +\n    '}';\n  function check(data) {\n    return (\n      Array.isArray(data.leafHashes) &&\n      data.leafHashes.every(\n        leafHash => leafHash instanceof Uint8Array && leafHash.length === 32,\n      ) &&\n      parent.check(data)\n    );\n  }\n  return {\n    decode,\n    encode,\n    check,\n    expected,\n    canAddToArray: parent.canAddToArray,\n  };\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;;;;AACA,MAAM,mBAAmB,CAAA,SAAU,OAAO,MAAM,KAAK;AAC9C,SAAS,cAAc,SAAS;IACrC,MAAM,SAAS,sLAAgB,aAAa,CAAC,WAAW;IACxD,SAAS,OAAO,MAAM;QACpB,MAAM,EAAE,aAAa,OAAO,EAAE,OAAO,UAAU,EAAE,GAAG,0JAAQ,MAAM,CAChE,OAAO,KAAK;QAEd,MAAM,OAAO,OAAO,MAAM,CAAC;YACzB,KAAK,OAAO,GAAG;YACf,OAAO,OAAO,KAAK,CAAC,KAAK,CAAC,aAAa,OAAO,WAAW;QAC3D;QACA,MAAM,aAAa,IAAI,MAAM,OAAO;QACpC,IAAK,IAAI,IAAI,GAAG,UAAU,YAAY,IAAI,SAAS,KAAK,WAAW,GAAI;YACrE,UAAU,CAAC,EAAE,GAAG,OAAO,KAAK,CAAC,KAAK,CAAC,SAAS,UAAU;QACxD;QACA,OAAO;YAAE,GAAG,IAAI;YAAE;QAAW;IAC/B;IACA,SAAS,OAAO,IAAI;QAClB,MAAM,OAAO,OAAO,MAAM,CAAC;QAC3B,MAAM,aAAa,0JAAQ,cAAc,CAAC,KAAK,UAAU,CAAC,MAAM;QAChE,MAAM,aAAa,IAAI,WAAW;QAClC,0JAAQ,MAAM,CAAC,KAAK,UAAU,CAAC,MAAM,EAAE;QACvC,MAAM,QAAQ,2JAAM,MAAM,CAAC;YAAC;eAAe,KAAK,UAAU;YAAE,KAAK,KAAK;SAAC;QACvE,OAAO;YAAE,GAAG,IAAI;YAAE;QAAM;IAC1B;IACA,MAAM,WACJ,OACA,oCACA,yBACA,mBACA,+BACA;IACF,SAAS,MAAM,IAAI;QACjB,OACE,MAAM,OAAO,CAAC,KAAK,UAAU,KAC7B,KAAK,UAAU,CAAC,KAAK,CACnB,CAAA,WAAY,oBAAoB,cAAc,SAAS,MAAM,KAAK,OAEpE,OAAO,KAAK,CAAC;IAEjB;IACA,OAAO;QACL;QACA;QACA;QACA;QACA,eAAe,OAAO,aAAa;IACrC;AACF","ignoreList":[0]}},
    {"offset": {"line": 997, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1003, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bip174/src/esm/lib/converter/shared/tapInternalKey.js"],"sourcesContent":["import * as tools from 'uint8array-tools';\nexport function makeConverter(TYPE_BYTE) {\n  function decode(keyVal) {\n    if (keyVal.key[0] !== TYPE_BYTE || keyVal.key.length !== 1) {\n      throw new Error(\n        'Decode Error: could not decode tapInternalKey with key 0x' +\n          tools.toHex(keyVal.key),\n      );\n    }\n    if (keyVal.value.length !== 32) {\n      throw new Error(\n        'Decode Error: tapInternalKey not a 32-byte x-only pubkey',\n      );\n    }\n    return keyVal.value;\n  }\n  function encode(value) {\n    const key = Uint8Array.from([TYPE_BYTE]);\n    return { key, value };\n  }\n  const expected = 'Uint8Array';\n  function check(data) {\n    return data instanceof Uint8Array && data.length === 32;\n  }\n  function canAdd(currentData, newData) {\n    return (\n      !!currentData && !!newData && currentData.tapInternalKey === undefined\n    );\n  }\n  return {\n    decode,\n    encode,\n    check,\n    expected,\n    canAdd,\n  };\n}\n"],"names":[],"mappings":";;;AAAA;;AACO,SAAS,cAAc,SAAS;IACrC,SAAS,OAAO,MAAM;QACpB,IAAI,OAAO,GAAG,CAAC,EAAE,KAAK,aAAa,OAAO,GAAG,CAAC,MAAM,KAAK,GAAG;YAC1D,MAAM,IAAI,MACR,8DACE,2JAAM,KAAK,CAAC,OAAO,GAAG;QAE5B;QACA,IAAI,OAAO,KAAK,CAAC,MAAM,KAAK,IAAI;YAC9B,MAAM,IAAI,MACR;QAEJ;QACA,OAAO,OAAO,KAAK;IACrB;IACA,SAAS,OAAO,KAAK;QACnB,MAAM,MAAM,WAAW,IAAI,CAAC;YAAC;SAAU;QACvC,OAAO;YAAE;YAAK;QAAM;IACtB;IACA,MAAM,WAAW;IACjB,SAAS,MAAM,IAAI;QACjB,OAAO,gBAAgB,cAAc,KAAK,MAAM,KAAK;IACvD;IACA,SAAS,OAAO,WAAW,EAAE,OAAO;QAClC,OACE,CAAC,CAAC,eAAe,CAAC,CAAC,WAAW,YAAY,cAAc,KAAK;IAEjE;IACA,OAAO;QACL;QACA;QACA;QACA;QACA;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 1042, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1048, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bip174/src/esm/lib/converter/shared/witnessScript.js"],"sourcesContent":["import * as tools from 'uint8array-tools';\nexport function makeConverter(TYPE_BYTE) {\n  function decode(keyVal) {\n    if (keyVal.key[0] !== TYPE_BYTE) {\n      throw new Error(\n        'Decode Error: could not decode witnessScript with key 0x' +\n          tools.toHex(keyVal.key),\n      );\n    }\n    return keyVal.value;\n  }\n  function encode(data) {\n    const key = Uint8Array.from([TYPE_BYTE]);\n    return {\n      key,\n      value: data,\n    };\n  }\n  const expected = 'Uint8Array';\n  function check(data) {\n    return data instanceof Uint8Array;\n  }\n  function canAdd(currentData, newData) {\n    return (\n      !!currentData && !!newData && currentData.witnessScript === undefined\n    );\n  }\n  return {\n    decode,\n    encode,\n    check,\n    expected,\n    canAdd,\n  };\n}\n"],"names":[],"mappings":";;;AAAA;;AACO,SAAS,cAAc,SAAS;IACrC,SAAS,OAAO,MAAM;QACpB,IAAI,OAAO,GAAG,CAAC,EAAE,KAAK,WAAW;YAC/B,MAAM,IAAI,MACR,6DACE,2JAAM,KAAK,CAAC,OAAO,GAAG;QAE5B;QACA,OAAO,OAAO,KAAK;IACrB;IACA,SAAS,OAAO,IAAI;QAClB,MAAM,MAAM,WAAW,IAAI,CAAC;YAAC;SAAU;QACvC,OAAO;YACL;YACA,OAAO;QACT;IACF;IACA,MAAM,WAAW;IACjB,SAAS,MAAM,IAAI;QACjB,OAAO,gBAAgB;IACzB;IACA,SAAS,OAAO,WAAW,EAAE,OAAO;QAClC,OACE,CAAC,CAAC,eAAe,CAAC,CAAC,WAAW,YAAY,aAAa,KAAK;IAEhE;IACA,OAAO;QACL;QACA;QACA;QACA;QACA;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 1084, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1090, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bip174/src/esm/lib/converter/index.js"],"sourcesContent":["import { InputTypes, OutputTypes } from '../typeFields.js';\nimport * as globalXpub from './global/globalXpub.js';\nimport * as unsignedTx from './global/unsignedTx.js';\nimport * as finalScriptSig from './input/finalScriptSig.js';\nimport * as finalScriptWitness from './input/finalScriptWitness.js';\nimport * as nonWitnessUtxo from './input/nonWitnessUtxo.js';\nimport * as partialSig from './input/partialSig.js';\nimport * as porCommitment from './input/porCommitment.js';\nimport * as sighashType from './input/sighashType.js';\nimport * as tapKeySig from './input/tapKeySig.js';\nimport * as tapLeafScript from './input/tapLeafScript.js';\nimport * as tapMerkleRoot from './input/tapMerkleRoot.js';\nimport * as tapScriptSig from './input/tapScriptSig.js';\nimport * as witnessUtxo from './input/witnessUtxo.js';\nimport * as tapTree from './output/tapTree.js';\nimport * as bip32Derivation from './shared/bip32Derivation.js';\nimport * as checkPubkey from './shared/checkPubkey.js';\nimport * as redeemScript from './shared/redeemScript.js';\nimport * as tapBip32Derivation from './shared/tapBip32Derivation.js';\nimport * as tapInternalKey from './shared/tapInternalKey.js';\nimport * as witnessScript from './shared/witnessScript.js';\nconst globals = {\n  unsignedTx,\n  globalXpub,\n  // pass an Array of key bytes that require pubkey beside the key\n  checkPubkey: checkPubkey.makeChecker([]),\n};\nconst inputs = {\n  nonWitnessUtxo,\n  partialSig,\n  sighashType,\n  finalScriptSig,\n  finalScriptWitness,\n  porCommitment,\n  witnessUtxo,\n  bip32Derivation: bip32Derivation.makeConverter(InputTypes.BIP32_DERIVATION),\n  redeemScript: redeemScript.makeConverter(InputTypes.REDEEM_SCRIPT),\n  witnessScript: witnessScript.makeConverter(InputTypes.WITNESS_SCRIPT),\n  checkPubkey: checkPubkey.makeChecker([\n    InputTypes.PARTIAL_SIG,\n    InputTypes.BIP32_DERIVATION,\n  ]),\n  tapKeySig,\n  tapScriptSig,\n  tapLeafScript,\n  tapBip32Derivation: tapBip32Derivation.makeConverter(\n    InputTypes.TAP_BIP32_DERIVATION,\n  ),\n  tapInternalKey: tapInternalKey.makeConverter(InputTypes.TAP_INTERNAL_KEY),\n  tapMerkleRoot,\n};\nconst outputs = {\n  bip32Derivation: bip32Derivation.makeConverter(OutputTypes.BIP32_DERIVATION),\n  redeemScript: redeemScript.makeConverter(OutputTypes.REDEEM_SCRIPT),\n  witnessScript: witnessScript.makeConverter(OutputTypes.WITNESS_SCRIPT),\n  checkPubkey: checkPubkey.makeChecker([OutputTypes.BIP32_DERIVATION]),\n  tapBip32Derivation: tapBip32Derivation.makeConverter(\n    OutputTypes.TAP_BIP32_DERIVATION,\n  ),\n  tapTree,\n  tapInternalKey: tapInternalKey.makeConverter(OutputTypes.TAP_INTERNAL_KEY),\n};\nexport { globals, inputs, outputs };\n"],"names":[],"mappings":";;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AACA,MAAM,UAAU;IACd,YAAA;IACA,YAAA;IACA,gEAAgE;IAChE,aAAa,kLAAY,WAAW,CAAC,EAAE;AACzC;AACA,MAAM,SAAS;IACb,gBAAA;IACA,YAAA;IACA,aAAA;IACA,gBAAA;IACA,oBAAA;IACA,eAAA;IACA,aAAA;IACA,iBAAiB,sLAAgB,aAAa,CAAC,yJAAA,CAAA,aAAU,CAAC,gBAAgB;IAC1E,cAAc,mLAAa,aAAa,CAAC,yJAAA,CAAA,aAAU,CAAC,aAAa;IACjE,eAAe,oLAAc,aAAa,CAAC,yJAAA,CAAA,aAAU,CAAC,cAAc;IACpE,aAAa,kLAAY,WAAW,CAAC;QACnC,yJAAA,CAAA,aAAU,CAAC,WAAW;QACtB,yJAAA,CAAA,aAAU,CAAC,gBAAgB;KAC5B;IACD,WAAA;IACA,cAAA;IACA,eAAA;IACA,oBAAoB,yLAAmB,aAAa,CAClD,yJAAA,CAAA,aAAU,CAAC,oBAAoB;IAEjC,gBAAgB,qLAAe,aAAa,CAAC,yJAAA,CAAA,aAAU,CAAC,gBAAgB;IACxE,eAAA;AACF;AACA,MAAM,UAAU;IACd,iBAAiB,sLAAgB,aAAa,CAAC,yJAAA,CAAA,cAAW,CAAC,gBAAgB;IAC3E,cAAc,mLAAa,aAAa,CAAC,yJAAA,CAAA,cAAW,CAAC,aAAa;IAClE,eAAe,oLAAc,aAAa,CAAC,yJAAA,CAAA,cAAW,CAAC,cAAc;IACrE,aAAa,kLAAY,WAAW,CAAC;QAAC,yJAAA,CAAA,cAAW,CAAC,gBAAgB;KAAC;IACnE,oBAAoB,yLAAmB,aAAa,CAClD,yJAAA,CAAA,cAAW,CAAC,oBAAoB;IAElC,SAAA;IACA,gBAAgB,qLAAe,aAAa,CAAC,yJAAA,CAAA,cAAW,CAAC,gBAAgB;AAC3E","ignoreList":[0]}},
    {"offset": {"line": 1177, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1183, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bip174/src/esm/lib/converter/tools.js"],"sourcesContent":["import * as varuint from 'varuint-bitcoin';\nimport * as tools from 'uint8array-tools';\nexport const range = n => [...Array(n).keys()];\nexport function reverseBuffer(buffer) {\n  if (buffer.length < 1) return buffer;\n  let j = buffer.length - 1;\n  let tmp = 0;\n  for (let i = 0; i < buffer.length / 2; i++) {\n    tmp = buffer[i];\n    buffer[i] = buffer[j];\n    buffer[j] = tmp;\n    j--;\n  }\n  return buffer;\n}\nexport function keyValsToBuffer(keyVals) {\n  const buffers = keyVals.map(keyValToBuffer);\n  buffers.push(Uint8Array.from([0]));\n  return tools.concat(buffers);\n}\nexport function keyValToBuffer(keyVal) {\n  const keyLen = keyVal.key.length;\n  const valLen = keyVal.value.length;\n  const keyVarIntLen = varuint.encodingLength(keyLen);\n  const valVarIntLen = varuint.encodingLength(valLen);\n  const buffer = new Uint8Array(keyVarIntLen + keyLen + valVarIntLen + valLen);\n  varuint.encode(keyLen, buffer, 0);\n  buffer.set(keyVal.key, keyVarIntLen);\n  varuint.encode(valLen, buffer, keyVarIntLen + keyLen);\n  buffer.set(keyVal.value, keyVarIntLen + keyLen + valVarIntLen);\n  return buffer;\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;;;AACO,MAAM,QAAQ,CAAA,IAAK;WAAI,MAAM,GAAG,IAAI;KAAG;AACvC,SAAS,cAAc,MAAM;IAClC,IAAI,OAAO,MAAM,GAAG,GAAG,OAAO;IAC9B,IAAI,IAAI,OAAO,MAAM,GAAG;IACxB,IAAI,MAAM;IACV,IAAK,IAAI,IAAI,GAAG,IAAI,OAAO,MAAM,GAAG,GAAG,IAAK;QAC1C,MAAM,MAAM,CAAC,EAAE;QACf,MAAM,CAAC,EAAE,GAAG,MAAM,CAAC,EAAE;QACrB,MAAM,CAAC,EAAE,GAAG;QACZ;IACF;IACA,OAAO;AACT;AACO,SAAS,gBAAgB,OAAO;IACrC,MAAM,UAAU,QAAQ,GAAG,CAAC;IAC5B,QAAQ,IAAI,CAAC,WAAW,IAAI,CAAC;QAAC;KAAE;IAChC,OAAO,2JAAM,MAAM,CAAC;AACtB;AACO,SAAS,eAAe,MAAM;IACnC,MAAM,SAAS,OAAO,GAAG,CAAC,MAAM;IAChC,MAAM,SAAS,OAAO,KAAK,CAAC,MAAM;IAClC,MAAM,eAAe,0JAAQ,cAAc,CAAC;IAC5C,MAAM,eAAe,0JAAQ,cAAc,CAAC;IAC5C,MAAM,SAAS,IAAI,WAAW,eAAe,SAAS,eAAe;IACrE,0JAAQ,MAAM,CAAC,QAAQ,QAAQ;IAC/B,OAAO,GAAG,CAAC,OAAO,GAAG,EAAE;IACvB,0JAAQ,MAAM,CAAC,QAAQ,QAAQ,eAAe;IAC9C,OAAO,GAAG,CAAC,OAAO,KAAK,EAAE,eAAe,SAAS;IACjD,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 1227, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1233, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bip174/src/esm/lib/parser/fromBuffer.js"],"sourcesContent":["import * as convert from '../converter/index.js';\nimport { range } from '../converter/tools.js';\nimport * as varuint from 'varuint-bitcoin';\nimport * as tools from 'uint8array-tools';\nimport { GlobalTypes, InputTypes, OutputTypes } from '../typeFields.js';\nexport function psbtFromBuffer(buffer, txGetter) {\n  let offset = 0;\n  function varSlice() {\n    const { numberValue: keyLen, bytes } = varuint.decode(buffer, offset);\n    offset += bytes;\n    const key = buffer.slice(offset, offset + Number(keyLen));\n    offset += Number(keyLen);\n    return key;\n  }\n  function readUInt32BE() {\n    const num = tools.readUInt32(buffer, offset, 'BE');\n    offset += 4;\n    return num;\n  }\n  function readUInt8() {\n    const num = tools.readUInt8(buffer, offset);\n    offset += 1;\n    return num;\n  }\n  function getKeyValue() {\n    const key = varSlice();\n    const value = varSlice();\n    return {\n      key,\n      value,\n    };\n  }\n  function checkEndOfKeyValPairs() {\n    if (offset >= buffer.length) {\n      throw new Error('Format Error: Unexpected End of PSBT');\n    }\n    const isEnd = tools.readUInt8(buffer, offset) === 0;\n    if (isEnd) {\n      offset++;\n    }\n    return isEnd;\n  }\n  if (readUInt32BE() !== 0x70736274) {\n    throw new Error('Format Error: Invalid Magic Number');\n  }\n  if (readUInt8() !== 0xff) {\n    throw new Error(\n      'Format Error: Magic Number must be followed by 0xff separator',\n    );\n  }\n  const globalMapKeyVals = [];\n  const globalKeyIndex = {};\n  while (!checkEndOfKeyValPairs()) {\n    const keyVal = getKeyValue();\n    const hexKey = tools.toHex(keyVal.key);\n    if (globalKeyIndex[hexKey]) {\n      throw new Error(\n        'Format Error: Keys must be unique for global keymap: key ' + hexKey,\n      );\n    }\n    globalKeyIndex[hexKey] = 1;\n    globalMapKeyVals.push(keyVal);\n  }\n  const unsignedTxMaps = globalMapKeyVals.filter(\n    keyVal => keyVal.key[0] === GlobalTypes.UNSIGNED_TX,\n  );\n  if (unsignedTxMaps.length !== 1) {\n    throw new Error('Format Error: Only one UNSIGNED_TX allowed');\n  }\n  const unsignedTx = txGetter(unsignedTxMaps[0].value);\n  // Get input and output counts to loop the respective fields\n  const { inputCount, outputCount } = unsignedTx.getInputOutputCounts();\n  const inputKeyVals = [];\n  const outputKeyVals = [];\n  // Get input fields\n  for (const index of range(inputCount)) {\n    const inputKeyIndex = {};\n    const input = [];\n    while (!checkEndOfKeyValPairs()) {\n      const keyVal = getKeyValue();\n      const hexKey = tools.toHex(keyVal.key);\n      if (inputKeyIndex[hexKey]) {\n        throw new Error(\n          'Format Error: Keys must be unique for each input: ' +\n            'input index ' +\n            index +\n            ' key ' +\n            hexKey,\n        );\n      }\n      inputKeyIndex[hexKey] = 1;\n      input.push(keyVal);\n    }\n    inputKeyVals.push(input);\n  }\n  for (const index of range(outputCount)) {\n    const outputKeyIndex = {};\n    const output = [];\n    while (!checkEndOfKeyValPairs()) {\n      const keyVal = getKeyValue();\n      const hexKey = tools.toHex(keyVal.key);\n      if (outputKeyIndex[hexKey]) {\n        throw new Error(\n          'Format Error: Keys must be unique for each output: ' +\n            'output index ' +\n            index +\n            ' key ' +\n            hexKey,\n        );\n      }\n      outputKeyIndex[hexKey] = 1;\n      output.push(keyVal);\n    }\n    outputKeyVals.push(output);\n  }\n  return psbtFromKeyVals(unsignedTx, {\n    globalMapKeyVals,\n    inputKeyVals,\n    outputKeyVals,\n  });\n}\nexport function checkKeyBuffer(type, keyBuf, keyNum) {\n  if (tools.compare(keyBuf, Uint8Array.from([keyNum]))) {\n    throw new Error(\n      // `Format Error: Invalid ${type} key: ${keyBuf.toString('hex')}`,\n      `Format Error: Invalid ${type} key: ${tools.toHex(keyBuf)}`,\n    );\n  }\n}\nexport function psbtFromKeyVals(\n  unsignedTx,\n  { globalMapKeyVals, inputKeyVals, outputKeyVals },\n) {\n  // That was easy :-)\n  const globalMap = {\n    unsignedTx,\n  };\n  let txCount = 0;\n  for (const keyVal of globalMapKeyVals) {\n    // If a globalMap item needs pubkey, uncomment\n    // const pubkey = convert.globals.checkPubkey(keyVal);\n    switch (keyVal.key[0]) {\n      case GlobalTypes.UNSIGNED_TX:\n        checkKeyBuffer('global', keyVal.key, GlobalTypes.UNSIGNED_TX);\n        if (txCount > 0) {\n          throw new Error('Format Error: GlobalMap has multiple UNSIGNED_TX');\n        }\n        txCount++;\n        break;\n      case GlobalTypes.GLOBAL_XPUB:\n        if (globalMap.globalXpub === undefined) {\n          globalMap.globalXpub = [];\n        }\n        globalMap.globalXpub.push(convert.globals.globalXpub.decode(keyVal));\n        break;\n      default:\n        // This will allow inclusion during serialization.\n        if (!globalMap.unknownKeyVals) globalMap.unknownKeyVals = [];\n        globalMap.unknownKeyVals.push(keyVal);\n    }\n  }\n  // Get input and output counts to loop the respective fields\n  const inputCount = inputKeyVals.length;\n  const outputCount = outputKeyVals.length;\n  const inputs = [];\n  const outputs = [];\n  // Get input fields\n  for (const index of range(inputCount)) {\n    const input = {};\n    for (const keyVal of inputKeyVals[index]) {\n      convert.inputs.checkPubkey(keyVal);\n      switch (keyVal.key[0]) {\n        case InputTypes.NON_WITNESS_UTXO:\n          checkKeyBuffer('input', keyVal.key, InputTypes.NON_WITNESS_UTXO);\n          if (input.nonWitnessUtxo !== undefined) {\n            throw new Error(\n              'Format Error: Input has multiple NON_WITNESS_UTXO',\n            );\n          }\n          input.nonWitnessUtxo = convert.inputs.nonWitnessUtxo.decode(keyVal);\n          break;\n        case InputTypes.WITNESS_UTXO:\n          checkKeyBuffer('input', keyVal.key, InputTypes.WITNESS_UTXO);\n          if (input.witnessUtxo !== undefined) {\n            throw new Error('Format Error: Input has multiple WITNESS_UTXO');\n          }\n          input.witnessUtxo = convert.inputs.witnessUtxo.decode(keyVal);\n          break;\n        case InputTypes.PARTIAL_SIG:\n          if (input.partialSig === undefined) {\n            input.partialSig = [];\n          }\n          input.partialSig.push(convert.inputs.partialSig.decode(keyVal));\n          break;\n        case InputTypes.SIGHASH_TYPE:\n          checkKeyBuffer('input', keyVal.key, InputTypes.SIGHASH_TYPE);\n          if (input.sighashType !== undefined) {\n            throw new Error('Format Error: Input has multiple SIGHASH_TYPE');\n          }\n          input.sighashType = convert.inputs.sighashType.decode(keyVal);\n          break;\n        case InputTypes.REDEEM_SCRIPT:\n          checkKeyBuffer('input', keyVal.key, InputTypes.REDEEM_SCRIPT);\n          if (input.redeemScript !== undefined) {\n            throw new Error('Format Error: Input has multiple REDEEM_SCRIPT');\n          }\n          input.redeemScript = convert.inputs.redeemScript.decode(keyVal);\n          break;\n        case InputTypes.WITNESS_SCRIPT:\n          checkKeyBuffer('input', keyVal.key, InputTypes.WITNESS_SCRIPT);\n          if (input.witnessScript !== undefined) {\n            throw new Error('Format Error: Input has multiple WITNESS_SCRIPT');\n          }\n          input.witnessScript = convert.inputs.witnessScript.decode(keyVal);\n          break;\n        case InputTypes.BIP32_DERIVATION:\n          if (input.bip32Derivation === undefined) {\n            input.bip32Derivation = [];\n          }\n          input.bip32Derivation.push(\n            convert.inputs.bip32Derivation.decode(keyVal),\n          );\n          break;\n        case InputTypes.FINAL_SCRIPTSIG:\n          checkKeyBuffer('input', keyVal.key, InputTypes.FINAL_SCRIPTSIG);\n          input.finalScriptSig = convert.inputs.finalScriptSig.decode(keyVal);\n          break;\n        case InputTypes.FINAL_SCRIPTWITNESS:\n          checkKeyBuffer('input', keyVal.key, InputTypes.FINAL_SCRIPTWITNESS);\n          input.finalScriptWitness = convert.inputs.finalScriptWitness.decode(\n            keyVal,\n          );\n          break;\n        case InputTypes.POR_COMMITMENT:\n          checkKeyBuffer('input', keyVal.key, InputTypes.POR_COMMITMENT);\n          input.porCommitment = convert.inputs.porCommitment.decode(keyVal);\n          break;\n        case InputTypes.TAP_KEY_SIG:\n          checkKeyBuffer('input', keyVal.key, InputTypes.TAP_KEY_SIG);\n          input.tapKeySig = convert.inputs.tapKeySig.decode(keyVal);\n          break;\n        case InputTypes.TAP_SCRIPT_SIG:\n          if (input.tapScriptSig === undefined) {\n            input.tapScriptSig = [];\n          }\n          input.tapScriptSig.push(convert.inputs.tapScriptSig.decode(keyVal));\n          break;\n        case InputTypes.TAP_LEAF_SCRIPT:\n          if (input.tapLeafScript === undefined) {\n            input.tapLeafScript = [];\n          }\n          input.tapLeafScript.push(convert.inputs.tapLeafScript.decode(keyVal));\n          break;\n        case InputTypes.TAP_BIP32_DERIVATION:\n          if (input.tapBip32Derivation === undefined) {\n            input.tapBip32Derivation = [];\n          }\n          input.tapBip32Derivation.push(\n            convert.inputs.tapBip32Derivation.decode(keyVal),\n          );\n          break;\n        case InputTypes.TAP_INTERNAL_KEY:\n          checkKeyBuffer('input', keyVal.key, InputTypes.TAP_INTERNAL_KEY);\n          input.tapInternalKey = convert.inputs.tapInternalKey.decode(keyVal);\n          break;\n        case InputTypes.TAP_MERKLE_ROOT:\n          checkKeyBuffer('input', keyVal.key, InputTypes.TAP_MERKLE_ROOT);\n          input.tapMerkleRoot = convert.inputs.tapMerkleRoot.decode(keyVal);\n          break;\n        default:\n          // This will allow inclusion during serialization.\n          if (!input.unknownKeyVals) input.unknownKeyVals = [];\n          input.unknownKeyVals.push(keyVal);\n      }\n    }\n    inputs.push(input);\n  }\n  for (const index of range(outputCount)) {\n    const output = {};\n    for (const keyVal of outputKeyVals[index]) {\n      convert.outputs.checkPubkey(keyVal);\n      switch (keyVal.key[0]) {\n        case OutputTypes.REDEEM_SCRIPT:\n          checkKeyBuffer('output', keyVal.key, OutputTypes.REDEEM_SCRIPT);\n          if (output.redeemScript !== undefined) {\n            throw new Error('Format Error: Output has multiple REDEEM_SCRIPT');\n          }\n          output.redeemScript = convert.outputs.redeemScript.decode(keyVal);\n          break;\n        case OutputTypes.WITNESS_SCRIPT:\n          checkKeyBuffer('output', keyVal.key, OutputTypes.WITNESS_SCRIPT);\n          if (output.witnessScript !== undefined) {\n            throw new Error('Format Error: Output has multiple WITNESS_SCRIPT');\n          }\n          output.witnessScript = convert.outputs.witnessScript.decode(keyVal);\n          break;\n        case OutputTypes.BIP32_DERIVATION:\n          if (output.bip32Derivation === undefined) {\n            output.bip32Derivation = [];\n          }\n          output.bip32Derivation.push(\n            convert.outputs.bip32Derivation.decode(keyVal),\n          );\n          break;\n        case OutputTypes.TAP_INTERNAL_KEY:\n          checkKeyBuffer('output', keyVal.key, OutputTypes.TAP_INTERNAL_KEY);\n          output.tapInternalKey = convert.outputs.tapInternalKey.decode(keyVal);\n          break;\n        case OutputTypes.TAP_TREE:\n          checkKeyBuffer('output', keyVal.key, OutputTypes.TAP_TREE);\n          output.tapTree = convert.outputs.tapTree.decode(keyVal);\n          break;\n        case OutputTypes.TAP_BIP32_DERIVATION:\n          if (output.tapBip32Derivation === undefined) {\n            output.tapBip32Derivation = [];\n          }\n          output.tapBip32Derivation.push(\n            convert.outputs.tapBip32Derivation.decode(keyVal),\n          );\n          break;\n        default:\n          if (!output.unknownKeyVals) output.unknownKeyVals = [];\n          output.unknownKeyVals.push(keyVal);\n      }\n    }\n    outputs.push(output);\n  }\n  return { globalMap, inputs, outputs };\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1543, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1549, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bip174/src/esm/lib/parser/toBuffer.js"],"sourcesContent":["import * as convert from '../converter/index.js';\nimport { keyValsToBuffer } from '../converter/tools.js';\nimport * as tools from 'uint8array-tools';\nexport function psbtToBuffer({ globalMap, inputs, outputs }) {\n  const { globalKeyVals, inputKeyVals, outputKeyVals } = psbtToKeyVals({\n    globalMap,\n    inputs,\n    outputs,\n  });\n  const globalBuffer = keyValsToBuffer(globalKeyVals);\n  const keyValsOrEmptyToBuffer = keyVals =>\n    keyVals.length === 0\n      ? [Uint8Array.from([0])]\n      : keyVals.map(keyValsToBuffer);\n  const inputBuffers = keyValsOrEmptyToBuffer(inputKeyVals);\n  const outputBuffers = keyValsOrEmptyToBuffer(outputKeyVals);\n  const header = new Uint8Array(5);\n  header.set([0x70, 0x73, 0x62, 0x74, 0xff], 0);\n  return tools.concat(\n    [header, globalBuffer].concat(inputBuffers, outputBuffers),\n  );\n}\nconst sortKeyVals = (a, b) => {\n  return tools.compare(a.key, b.key);\n};\nfunction keyValsFromMap(keyValMap, converterFactory) {\n  const keyHexSet = new Set();\n  const keyVals = Object.entries(keyValMap).reduce((result, [key, value]) => {\n    if (key === 'unknownKeyVals') return result;\n    // We are checking for undefined anyways. So ignore TS error\n    // @ts-ignore\n    const converter = converterFactory[key];\n    if (converter === undefined) return result;\n    const encodedKeyVals = (Array.isArray(value) ? value : [value]).map(\n      converter.encode,\n    );\n    const keyHexes = encodedKeyVals.map(kv => tools.toHex(kv.key));\n    keyHexes.forEach(hex => {\n      if (keyHexSet.has(hex))\n        throw new Error('Serialize Error: Duplicate key: ' + hex);\n      keyHexSet.add(hex);\n    });\n    return result.concat(encodedKeyVals);\n  }, []);\n  // Get other keyVals that have not yet been gotten\n  const otherKeyVals = keyValMap.unknownKeyVals\n    ? keyValMap.unknownKeyVals.filter(keyVal => {\n        return !keyHexSet.has(tools.toHex(keyVal.key));\n      })\n    : [];\n  return keyVals.concat(otherKeyVals).sort(sortKeyVals);\n}\nexport function psbtToKeyVals({ globalMap, inputs, outputs }) {\n  // First parse the global keyVals\n  // Get any extra keyvals to pass along\n  return {\n    globalKeyVals: keyValsFromMap(globalMap, convert.globals),\n    inputKeyVals: inputs.map(i => keyValsFromMap(i, convert.inputs)),\n    outputKeyVals: outputs.map(o => keyValsFromMap(o, convert.outputs)),\n  };\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AACO,SAAS,aAAa,EAAE,SAAS,EAAE,MAAM,EAAE,OAAO,EAAE;IACzD,MAAM,EAAE,aAAa,EAAE,YAAY,EAAE,aAAa,EAAE,GAAG,cAAc;QACnE;QACA;QACA;IACF;IACA,MAAM,eAAe,CAAA,GAAA,iKAAA,CAAA,kBAAe,AAAD,EAAE;IACrC,MAAM,yBAAyB,CAAA,UAC7B,QAAQ,MAAM,KAAK,IACf;YAAC,WAAW,IAAI,CAAC;gBAAC;aAAE;SAAE,GACtB,QAAQ,GAAG,CAAC,iKAAA,CAAA,kBAAe;IACjC,MAAM,eAAe,uBAAuB;IAC5C,MAAM,gBAAgB,uBAAuB;IAC7C,MAAM,SAAS,IAAI,WAAW;IAC9B,OAAO,GAAG,CAAC;QAAC;QAAM;QAAM;QAAM;QAAM;KAAK,EAAE;IAC3C,OAAO,2JAAM,MAAM,CACjB;QAAC;QAAQ;KAAa,CAAC,MAAM,CAAC,cAAc;AAEhD;AACA,MAAM,cAAc,CAAC,GAAG;IACtB,OAAO,2JAAM,OAAO,CAAC,EAAE,GAAG,EAAE,EAAE,GAAG;AACnC;AACA,SAAS,eAAe,SAAS,EAAE,gBAAgB;IACjD,MAAM,YAAY,IAAI;IACtB,MAAM,UAAU,OAAO,OAAO,CAAC,WAAW,MAAM,CAAC,CAAC,QAAQ,CAAC,KAAK,MAAM;QACpE,IAAI,QAAQ,kBAAkB,OAAO;QACrC,4DAA4D;QAC5D,aAAa;QACb,MAAM,YAAY,gBAAgB,CAAC,IAAI;QACvC,IAAI,cAAc,WAAW,OAAO;QACpC,MAAM,iBAAiB,CAAC,MAAM,OAAO,CAAC,SAAS,QAAQ;YAAC;SAAM,EAAE,GAAG,CACjE,UAAU,MAAM;QAElB,MAAM,WAAW,eAAe,GAAG,CAAC,CAAA,KAAM,2JAAM,KAAK,CAAC,GAAG,GAAG;QAC5D,SAAS,OAAO,CAAC,CAAA;YACf,IAAI,UAAU,GAAG,CAAC,MAChB,MAAM,IAAI,MAAM,qCAAqC;YACvD,UAAU,GAAG,CAAC;QAChB;QACA,OAAO,OAAO,MAAM,CAAC;IACvB,GAAG,EAAE;IACL,kDAAkD;IAClD,MAAM,eAAe,UAAU,cAAc,GACzC,UAAU,cAAc,CAAC,MAAM,CAAC,CAAA;QAC9B,OAAO,CAAC,UAAU,GAAG,CAAC,2JAAM,KAAK,CAAC,OAAO,GAAG;IAC9C,KACA,EAAE;IACN,OAAO,QAAQ,MAAM,CAAC,cAAc,IAAI,CAAC;AAC3C;AACO,SAAS,cAAc,EAAE,SAAS,EAAE,MAAM,EAAE,OAAO,EAAE;IAC1D,iCAAiC;IACjC,sCAAsC;IACtC,OAAO;QACL,eAAe,eAAe,WAAW,kKAAQ,OAAO;QACxD,cAAc,OAAO,GAAG,CAAC,CAAA,IAAK,eAAe,GAAG,kKAAQ,MAAM;QAC9D,eAAe,QAAQ,GAAG,CAAC,CAAA,IAAK,eAAe,GAAG,kKAAQ,OAAO;IACnE;AACF","ignoreList":[0]}},
    {"offset": {"line": 1622, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1628, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 1631, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1647, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bip174/src/esm/lib/combiner/index.js"],"sourcesContent":["import { psbtFromKeyVals, psbtToKeyVals } from '../parser/index.js';\nimport * as tools from 'uint8array-tools';\nexport function combine(psbts) {\n  const self = psbts[0];\n  const selfKeyVals = psbtToKeyVals(self);\n  const others = psbts.slice(1);\n  if (others.length === 0) throw new Error('Combine: Nothing to combine');\n  const selfTx = getTx(self);\n  if (selfTx === undefined) {\n    throw new Error('Combine: Self missing transaction');\n  }\n  const selfGlobalSet = getKeySet(selfKeyVals.globalKeyVals);\n  const selfInputSets = selfKeyVals.inputKeyVals.map(getKeySet);\n  const selfOutputSets = selfKeyVals.outputKeyVals.map(getKeySet);\n  for (const other of others) {\n    const otherTx = getTx(other);\n    if (\n      otherTx === undefined ||\n      tools.compare(otherTx.toBuffer(), selfTx.toBuffer()) !== 0\n    ) {\n      throw new Error(\n        'Combine: One of the Psbts does not have the same transaction.',\n      );\n    }\n    const otherKeyVals = psbtToKeyVals(other);\n    const otherGlobalSet = getKeySet(otherKeyVals.globalKeyVals);\n    otherGlobalSet.forEach(\n      keyPusher(\n        selfGlobalSet,\n        selfKeyVals.globalKeyVals,\n        otherKeyVals.globalKeyVals,\n      ),\n    );\n    const otherInputSets = otherKeyVals.inputKeyVals.map(getKeySet);\n    otherInputSets.forEach((inputSet, idx) =>\n      inputSet.forEach(\n        keyPusher(\n          selfInputSets[idx],\n          selfKeyVals.inputKeyVals[idx],\n          otherKeyVals.inputKeyVals[idx],\n        ),\n      ),\n    );\n    const otherOutputSets = otherKeyVals.outputKeyVals.map(getKeySet);\n    otherOutputSets.forEach((outputSet, idx) =>\n      outputSet.forEach(\n        keyPusher(\n          selfOutputSets[idx],\n          selfKeyVals.outputKeyVals[idx],\n          otherKeyVals.outputKeyVals[idx],\n        ),\n      ),\n    );\n  }\n  return psbtFromKeyVals(selfTx, {\n    globalMapKeyVals: selfKeyVals.globalKeyVals,\n    inputKeyVals: selfKeyVals.inputKeyVals,\n    outputKeyVals: selfKeyVals.outputKeyVals,\n  });\n}\nfunction keyPusher(selfSet, selfKeyVals, otherKeyVals) {\n  return key => {\n    if (selfSet.has(key)) return;\n    const newKv = otherKeyVals.filter(kv => tools.toHex(kv.key) === key)[0];\n    selfKeyVals.push(newKv);\n    selfSet.add(key);\n  };\n}\nfunction getTx(psbt) {\n  return psbt.globalMap.unsignedTx;\n}\nfunction getKeySet(keyVals) {\n  const set = new Set();\n  keyVals.forEach(keyVal => {\n    const hex = tools.toHex(keyVal.key);\n    if (set.has(hex))\n      throw new Error('Combine: KeyValue Map keys should be unique');\n    set.add(hex);\n  });\n  return set;\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AADA;AAAA;;;AAEO,SAAS,QAAQ,KAAK;IAC3B,MAAM,OAAO,KAAK,CAAC,EAAE;IACrB,MAAM,cAAc,CAAA,GAAA,iKAAA,CAAA,gBAAa,AAAD,EAAE;IAClC,MAAM,SAAS,MAAM,KAAK,CAAC;IAC3B,IAAI,OAAO,MAAM,KAAK,GAAG,MAAM,IAAI,MAAM;IACzC,MAAM,SAAS,MAAM;IACrB,IAAI,WAAW,WAAW;QACxB,MAAM,IAAI,MAAM;IAClB;IACA,MAAM,gBAAgB,UAAU,YAAY,aAAa;IACzD,MAAM,gBAAgB,YAAY,YAAY,CAAC,GAAG,CAAC;IACnD,MAAM,iBAAiB,YAAY,aAAa,CAAC,GAAG,CAAC;IACrD,KAAK,MAAM,SAAS,OAAQ;QAC1B,MAAM,UAAU,MAAM;QACtB,IACE,YAAY,aACZ,2JAAM,OAAO,CAAC,QAAQ,QAAQ,IAAI,OAAO,QAAQ,QAAQ,GACzD;YACA,MAAM,IAAI,MACR;QAEJ;QACA,MAAM,eAAe,CAAA,GAAA,iKAAA,CAAA,gBAAa,AAAD,EAAE;QACnC,MAAM,iBAAiB,UAAU,aAAa,aAAa;QAC3D,eAAe,OAAO,CACpB,UACE,eACA,YAAY,aAAa,EACzB,aAAa,aAAa;QAG9B,MAAM,iBAAiB,aAAa,YAAY,CAAC,GAAG,CAAC;QACrD,eAAe,OAAO,CAAC,CAAC,UAAU,MAChC,SAAS,OAAO,CACd,UACE,aAAa,CAAC,IAAI,EAClB,YAAY,YAAY,CAAC,IAAI,EAC7B,aAAa,YAAY,CAAC,IAAI;QAIpC,MAAM,kBAAkB,aAAa,aAAa,CAAC,GAAG,CAAC;QACvD,gBAAgB,OAAO,CAAC,CAAC,WAAW,MAClC,UAAU,OAAO,CACf,UACE,cAAc,CAAC,IAAI,EACnB,YAAY,aAAa,CAAC,IAAI,EAC9B,aAAa,aAAa,CAAC,IAAI;IAIvC;IACA,OAAO,CAAA,GAAA,mKAAA,CAAA,kBAAe,AAAD,EAAE,QAAQ;QAC7B,kBAAkB,YAAY,aAAa;QAC3C,cAAc,YAAY,YAAY;QACtC,eAAe,YAAY,aAAa;IAC1C;AACF;AACA,SAAS,UAAU,OAAO,EAAE,WAAW,EAAE,YAAY;IACnD,OAAO,CAAA;QACL,IAAI,QAAQ,GAAG,CAAC,MAAM;QACtB,MAAM,QAAQ,aAAa,MAAM,CAAC,CAAA,KAAM,2JAAM,KAAK,CAAC,GAAG,GAAG,MAAM,IAAI,CAAC,EAAE;QACvE,YAAY,IAAI,CAAC;QACjB,QAAQ,GAAG,CAAC;IACd;AACF;AACA,SAAS,MAAM,IAAI;IACjB,OAAO,KAAK,SAAS,CAAC,UAAU;AAClC;AACA,SAAS,UAAU,OAAO;IACxB,MAAM,MAAM,IAAI;IAChB,QAAQ,OAAO,CAAC,CAAA;QACd,MAAM,MAAM,2JAAM,KAAK,CAAC,OAAO,GAAG;QAClC,IAAI,IAAI,GAAG,CAAC,MACV,MAAM,IAAI,MAAM;QAClB,IAAI,GAAG,CAAC;IACV;IACA,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 1707, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1713, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bip174/src/esm/lib/utils.js"],"sourcesContent":["import * as converter from './converter/index.js';\nimport * as tools from 'uint8array-tools';\nexport function checkForInput(inputs, inputIndex) {\n  const input = inputs[inputIndex];\n  if (input === undefined) throw new Error(`No input #${inputIndex}`);\n  return input;\n}\nexport function checkForOutput(outputs, outputIndex) {\n  const output = outputs[outputIndex];\n  if (output === undefined) throw new Error(`No output #${outputIndex}`);\n  return output;\n}\nexport function checkHasKey(checkKeyVal, keyVals, enumLength) {\n  if (checkKeyVal.key[0] < enumLength) {\n    throw new Error(\n      `Use the method for your specific key instead of addUnknownKeyVal*`,\n    );\n  }\n  if (\n    keyVals &&\n    keyVals.filter(kv => tools.compare(kv.key, checkKeyVal.key) === 0)\n      .length !== 0\n  ) {\n    throw new Error(`Duplicate Key: ${tools.toHex(checkKeyVal.key)}`);\n  }\n}\nexport function getEnumLength(myenum) {\n  let count = 0;\n  Object.keys(myenum).forEach(val => {\n    if (Number(isNaN(Number(val)))) {\n      count++;\n    }\n  });\n  return count;\n}\nexport function inputCheckUncleanFinalized(inputIndex, input) {\n  let result = false;\n  if (input.nonWitnessUtxo || input.witnessUtxo) {\n    const needScriptSig = !!input.redeemScript;\n    const needWitnessScript = !!input.witnessScript;\n    const scriptSigOK = !needScriptSig || !!input.finalScriptSig;\n    const witnessScriptOK = !needWitnessScript || !!input.finalScriptWitness;\n    const hasOneFinal = !!input.finalScriptSig || !!input.finalScriptWitness;\n    result = scriptSigOK && witnessScriptOK && hasOneFinal;\n  }\n  if (result === false) {\n    throw new Error(\n      `Input #${inputIndex} has too much or too little data to clean`,\n    );\n  }\n}\nfunction throwForUpdateMaker(typeName, name, expected, data) {\n  throw new Error(\n    `Data for ${typeName} key ${name} is incorrect: Expected ` +\n      `${expected} and got ${JSON.stringify(data)}`,\n  );\n}\nfunction updateMaker(typeName) {\n  return (updateData, mainData) => {\n    // @ts-ignore\n    for (const name of Object.keys(updateData)) {\n      // @ts-ignore\n      const data = updateData[name];\n      // @ts-ignore\n      const { canAdd, canAddToArray, check, expected } =\n        // @ts-ignore\n        converter[typeName + 's'][name] || {};\n      const isArray = !!canAddToArray;\n      // If unknown data. ignore and do not add\n      if (check) {\n        if (isArray) {\n          if (\n            !Array.isArray(data) ||\n            // @ts-ignore\n            (mainData[name] && !Array.isArray(mainData[name]))\n          ) {\n            throw new Error(`Key type ${name} must be an array`);\n          }\n          if (!data.every(check)) {\n            throwForUpdateMaker(typeName, name, expected, data);\n          }\n          // @ts-ignore\n          const arr = mainData[name] || [];\n          const dupeCheckSet = new Set();\n          if (!data.every(v => canAddToArray(arr, v, dupeCheckSet))) {\n            throw new Error('Can not add duplicate data to array');\n          }\n          // @ts-ignore\n          mainData[name] = arr.concat(data);\n        } else {\n          if (!check(data)) {\n            throwForUpdateMaker(typeName, name, expected, data);\n          }\n          if (!canAdd(mainData, data)) {\n            throw new Error(`Can not add duplicate data to ${typeName}`);\n          }\n          // @ts-ignore\n          mainData[name] = data;\n        }\n      }\n    }\n  };\n}\nexport const updateGlobal = updateMaker('global');\nexport const updateInput = updateMaker('input');\nexport const updateOutput = updateMaker('output');\nexport function addInputAttributes(inputs, data) {\n  const index = inputs.length - 1;\n  const input = checkForInput(inputs, index);\n  updateInput(data, input);\n}\nexport function addOutputAttributes(outputs, data) {\n  const index = outputs.length - 1;\n  const output = checkForOutput(outputs, index);\n  updateOutput(data, output);\n}\nexport function defaultVersionSetter(version, txBuf) {\n  if (!(txBuf instanceof Uint8Array) || txBuf.length < 4) {\n    throw new Error('Set Version: Invalid Transaction');\n  }\n  tools.writeUInt32(txBuf, 0, version, 'LE');\n  return txBuf;\n}\nexport function defaultLocktimeSetter(locktime, txBuf) {\n  if (!(txBuf instanceof Uint8Array) || txBuf.length < 4) {\n    throw new Error('Set Locktime: Invalid Transaction');\n  }\n  tools.writeUInt32(txBuf, txBuf.length - 4, locktime, 'LE');\n  return txBuf;\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1843, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1849, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bip174/src/esm/lib/psbt.js"],"sourcesContent":["import { combine } from './combiner/index.js';\nimport { psbtFromBuffer, psbtToBuffer } from './parser/index.js';\nimport { GlobalTypes, InputTypes, OutputTypes } from './typeFields.js';\nimport {\n  addInputAttributes,\n  addOutputAttributes,\n  checkForInput,\n  checkForOutput,\n  checkHasKey,\n  getEnumLength,\n  inputCheckUncleanFinalized,\n  updateGlobal,\n  updateInput,\n  updateOutput,\n} from './utils.js';\nimport * as tools from 'uint8array-tools';\nexport class Psbt {\n  constructor(tx) {\n    this.inputs = [];\n    this.outputs = [];\n    this.globalMap = {\n      unsignedTx: tx,\n    };\n  }\n  static fromBase64(data, txFromBuffer) {\n    const buffer = tools.fromBase64(data);\n    return this.fromBuffer(buffer, txFromBuffer);\n  }\n  static fromHex(data, txFromBuffer) {\n    const buffer = tools.fromHex(data);\n    return this.fromBuffer(buffer, txFromBuffer);\n  }\n  static fromBuffer(buffer, txFromBuffer) {\n    const results = psbtFromBuffer(buffer, txFromBuffer);\n    const psbt = new this(results.globalMap.unsignedTx);\n    Object.assign(psbt, results);\n    return psbt;\n  }\n  toBase64() {\n    const buffer = this.toBuffer();\n    return tools.toBase64(buffer);\n  }\n  toHex() {\n    const buffer = this.toBuffer();\n    return tools.toHex(buffer);\n  }\n  toBuffer() {\n    return psbtToBuffer(this);\n  }\n  updateGlobal(updateData) {\n    updateGlobal(updateData, this.globalMap);\n    return this;\n  }\n  updateInput(inputIndex, updateData) {\n    const input = checkForInput(this.inputs, inputIndex);\n    updateInput(updateData, input);\n    return this;\n  }\n  updateOutput(outputIndex, updateData) {\n    const output = checkForOutput(this.outputs, outputIndex);\n    updateOutput(updateData, output);\n    return this;\n  }\n  addUnknownKeyValToGlobal(keyVal) {\n    checkHasKey(\n      keyVal,\n      this.globalMap.unknownKeyVals,\n      getEnumLength(GlobalTypes),\n    );\n    if (!this.globalMap.unknownKeyVals) this.globalMap.unknownKeyVals = [];\n    this.globalMap.unknownKeyVals.push(keyVal);\n    return this;\n  }\n  addUnknownKeyValToInput(inputIndex, keyVal) {\n    const input = checkForInput(this.inputs, inputIndex);\n    checkHasKey(keyVal, input.unknownKeyVals, getEnumLength(InputTypes));\n    if (!input.unknownKeyVals) input.unknownKeyVals = [];\n    input.unknownKeyVals.push(keyVal);\n    return this;\n  }\n  addUnknownKeyValToOutput(outputIndex, keyVal) {\n    const output = checkForOutput(this.outputs, outputIndex);\n    checkHasKey(keyVal, output.unknownKeyVals, getEnumLength(OutputTypes));\n    if (!output.unknownKeyVals) output.unknownKeyVals = [];\n    output.unknownKeyVals.push(keyVal);\n    return this;\n  }\n  addInput(inputData) {\n    this.globalMap.unsignedTx.addInput(inputData);\n    this.inputs.push({\n      unknownKeyVals: [],\n    });\n    const addKeyVals = inputData.unknownKeyVals || [];\n    const inputIndex = this.inputs.length - 1;\n    if (!Array.isArray(addKeyVals)) {\n      throw new Error('unknownKeyVals must be an Array');\n    }\n    addKeyVals.forEach(keyVal =>\n      this.addUnknownKeyValToInput(inputIndex, keyVal),\n    );\n    addInputAttributes(this.inputs, inputData);\n    return this;\n  }\n  addOutput(outputData) {\n    this.globalMap.unsignedTx.addOutput(outputData);\n    this.outputs.push({\n      unknownKeyVals: [],\n    });\n    const addKeyVals = outputData.unknownKeyVals || [];\n    const outputIndex = this.outputs.length - 1;\n    if (!Array.isArray(addKeyVals)) {\n      throw new Error('unknownKeyVals must be an Array');\n    }\n    addKeyVals.forEach(keyVal =>\n      this.addUnknownKeyValToOutput(outputIndex, keyVal),\n    );\n    addOutputAttributes(this.outputs, outputData);\n    return this;\n  }\n  clearFinalizedInput(inputIndex) {\n    const input = checkForInput(this.inputs, inputIndex);\n    inputCheckUncleanFinalized(inputIndex, input);\n    for (const key of Object.keys(input)) {\n      if (\n        ![\n          'witnessUtxo',\n          'nonWitnessUtxo',\n          'finalScriptSig',\n          'finalScriptWitness',\n          'unknownKeyVals',\n        ].includes(key)\n      ) {\n        // @ts-ignore\n        delete input[key];\n      }\n    }\n    return this;\n  }\n  combine(...those) {\n    // Combine this with those.\n    // Return self for chaining.\n    const result = combine([this].concat(those));\n    Object.assign(this, result);\n    return this;\n  }\n  getTransaction() {\n    return this.globalMap.unsignedTx.toBuffer();\n  }\n}\nexport { checkForInput, checkForOutput } from './utils.js';\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1989, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}