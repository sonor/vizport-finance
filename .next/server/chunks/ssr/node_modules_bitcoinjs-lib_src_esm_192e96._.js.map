{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bitcoinjs-lib/src/esm/networks.js"],"sourcesContent":["// https://en.bitcoin.it/wiki/List_of_address_prefixes\n// Dogecoin BIP32 is a proposed standard: https://bitcointalk.org/index.php?topic=409731\n/**\n * Represents the Bitcoin network configuration.\n */\nexport const bitcoin = {\n  /**\n   * The message prefix used for signing Bitcoin messages.\n   */\n  messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n  /**\n   * The Bech32 prefix used for Bitcoin addresses.\n   */\n  bech32: 'bc',\n  /**\n   * The BIP32 key prefixes for Bitcoin.\n   */\n  bip32: {\n    /**\n     * The public key prefix for BIP32 extended public keys.\n     */\n    public: 0x0488b21e,\n    /**\n     * The private key prefix for BIP32 extended private keys.\n     */\n    private: 0x0488ade4,\n  },\n  /**\n   * The prefix for Bitcoin public key hashes.\n   */\n  pubKeyHash: 0x00,\n  /**\n   * The prefix for Bitcoin script hashes.\n   */\n  scriptHash: 0x05,\n  /**\n   * The prefix for Bitcoin Wallet Import Format (WIF) private keys.\n   */\n  wif: 0x80,\n};\n/**\n * Represents the regtest network configuration.\n */\nexport const regtest = {\n  messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n  bech32: 'bcrt',\n  bip32: {\n    public: 0x043587cf,\n    private: 0x04358394,\n  },\n  pubKeyHash: 0x6f,\n  scriptHash: 0xc4,\n  wif: 0xef,\n};\n/**\n * Represents the testnet network configuration.\n */\nexport const testnet = {\n  messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n  bech32: 'tb',\n  bip32: {\n    public: 0x043587cf,\n    private: 0x04358394,\n  },\n  pubKeyHash: 0x6f,\n  scriptHash: 0xc4,\n  wif: 0xef,\n};\n"],"names":[],"mappings":"AAAA,sDAAsD;AACtD,wFAAwF;AACxF;;CAEC;;;;;AACM,MAAM,UAAU;IACrB;;GAEC,GACD,eAAe;IACf;;GAEC,GACD,QAAQ;IACR;;GAEC,GACD,OAAO;QACL;;KAEC,GACD,QAAQ;QACR;;KAEC,GACD,SAAS;IACX;IACA;;GAEC,GACD,YAAY;IACZ;;GAEC,GACD,YAAY;IACZ;;GAEC,GACD,KAAK;AACP;AAIO,MAAM,UAAU;IACrB,eAAe;IACf,QAAQ;IACR,OAAO;QACL,QAAQ;QACR,SAAS;IACX;IACA,YAAY;IACZ,YAAY;IACZ,KAAK;AACP;AAIO,MAAM,UAAU;IACrB,eAAe;IACf,QAAQ;IACR,OAAO;QACL,QAAQ;QACR,SAAS;IACX;IACA,YAAY;IACZ,YAAY;IACZ,KAAK;AACP","ignoreList":[0]}},
    {"offset": {"line": 65, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 71, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bitcoinjs-lib/src/esm/bip66.js"],"sourcesContent":["// Reference https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki\n// Format: 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]\n// NOTE: SIGHASH byte ignored AND restricted, truncate before use\n/**\n * Checks if the given buffer is a valid BIP66-encoded signature.\n *\n * @param buffer - The buffer to check.\n * @returns A boolean indicating whether the buffer is a valid BIP66-encoded signature.\n */\nexport function check(buffer) {\n  if (buffer.length < 8) return false;\n  if (buffer.length > 72) return false;\n  if (buffer[0] !== 0x30) return false;\n  if (buffer[1] !== buffer.length - 2) return false;\n  if (buffer[2] !== 0x02) return false;\n  const lenR = buffer[3];\n  if (lenR === 0) return false;\n  if (5 + lenR >= buffer.length) return false;\n  if (buffer[4 + lenR] !== 0x02) return false;\n  const lenS = buffer[5 + lenR];\n  if (lenS === 0) return false;\n  if (6 + lenR + lenS !== buffer.length) return false;\n  if (buffer[4] & 0x80) return false;\n  if (lenR > 1 && buffer[4] === 0x00 && !(buffer[5] & 0x80)) return false;\n  if (buffer[lenR + 6] & 0x80) return false;\n  if (lenS > 1 && buffer[lenR + 6] === 0x00 && !(buffer[lenR + 7] & 0x80))\n    return false;\n  return true;\n}\n/**\n * Decodes a DER-encoded signature buffer and returns the R and S values.\n * @param buffer - The DER-encoded signature buffer.\n * @returns An object containing the R and S values.\n * @throws {Error} If the DER sequence length is too short, too long, or invalid.\n * @throws {Error} If the R or S length is zero or invalid.\n * @throws {Error} If the R or S value is negative or excessively padded.\n */\nexport function decode(buffer) {\n  if (buffer.length < 8) throw new Error('DER sequence length is too short');\n  if (buffer.length > 72) throw new Error('DER sequence length is too long');\n  if (buffer[0] !== 0x30) throw new Error('Expected DER sequence');\n  if (buffer[1] !== buffer.length - 2)\n    throw new Error('DER sequence length is invalid');\n  if (buffer[2] !== 0x02) throw new Error('Expected DER integer');\n  const lenR = buffer[3];\n  if (lenR === 0) throw new Error('R length is zero');\n  if (5 + lenR >= buffer.length) throw new Error('R length is too long');\n  if (buffer[4 + lenR] !== 0x02) throw new Error('Expected DER integer (2)');\n  const lenS = buffer[5 + lenR];\n  if (lenS === 0) throw new Error('S length is zero');\n  if (6 + lenR + lenS !== buffer.length) throw new Error('S length is invalid');\n  if (buffer[4] & 0x80) throw new Error('R value is negative');\n  if (lenR > 1 && buffer[4] === 0x00 && !(buffer[5] & 0x80))\n    throw new Error('R value excessively padded');\n  if (buffer[lenR + 6] & 0x80) throw new Error('S value is negative');\n  if (lenS > 1 && buffer[lenR + 6] === 0x00 && !(buffer[lenR + 7] & 0x80))\n    throw new Error('S value excessively padded');\n  // non-BIP66 - extract R, S values\n  return {\n    r: buffer.slice(4, 4 + lenR),\n    s: buffer.slice(6 + lenR),\n  };\n}\n/*\n * Expects r and s to be positive DER integers.\n *\n * The DER format uses the most significant bit as a sign bit (& 0x80).\n * If the significant bit is set AND the integer is positive, a 0x00 is prepended.\n *\n * Examples:\n *\n *      0 =>     0x00\n *      1 =>     0x01\n *     -1 =>     0xff\n *    127 =>     0x7f\n *   -127 =>     0x81\n *    128 =>   0x0080\n *   -128 =>     0x80\n *    255 =>   0x00ff\n *   -255 =>   0xff01\n *  16300 =>   0x3fac\n * -16300 =>   0xc054\n *  62300 => 0x00f35c\n * -62300 => 0xff0ca4\n */\nexport function encode(r, s) {\n  const lenR = r.length;\n  const lenS = s.length;\n  if (lenR === 0) throw new Error('R length is zero');\n  if (lenS === 0) throw new Error('S length is zero');\n  if (lenR > 33) throw new Error('R length is too long');\n  if (lenS > 33) throw new Error('S length is too long');\n  if (r[0] & 0x80) throw new Error('R value is negative');\n  if (s[0] & 0x80) throw new Error('S value is negative');\n  if (lenR > 1 && r[0] === 0x00 && !(r[1] & 0x80))\n    throw new Error('R value excessively padded');\n  if (lenS > 1 && s[0] === 0x00 && !(s[1] & 0x80))\n    throw new Error('S value excessively padded');\n  const signature = new Uint8Array(6 + lenR + lenS);\n  // 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]\n  signature[0] = 0x30;\n  signature[1] = signature.length - 2;\n  signature[2] = 0x02;\n  signature[3] = r.length;\n  signature.set(r, 4);\n  signature[4 + lenR] = 0x02;\n  signature[5 + lenR] = s.length;\n  signature.set(s, 6 + lenR);\n  return signature;\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 149, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 155, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bitcoinjs-lib/src/esm/ops.js"],"sourcesContent":["const OPS = {\n  OP_FALSE: 0,\n  OP_0: 0,\n  OP_PUSHDATA1: 76,\n  OP_PUSHDATA2: 77,\n  OP_PUSHDATA4: 78,\n  OP_1NEGATE: 79,\n  OP_RESERVED: 80,\n  OP_TRUE: 81,\n  OP_1: 81,\n  OP_2: 82,\n  OP_3: 83,\n  OP_4: 84,\n  OP_5: 85,\n  OP_6: 86,\n  OP_7: 87,\n  OP_8: 88,\n  OP_9: 89,\n  OP_10: 90,\n  OP_11: 91,\n  OP_12: 92,\n  OP_13: 93,\n  OP_14: 94,\n  OP_15: 95,\n  OP_16: 96,\n  OP_NOP: 97,\n  OP_VER: 98,\n  OP_IF: 99,\n  OP_NOTIF: 100,\n  OP_VERIF: 101,\n  OP_VERNOTIF: 102,\n  OP_ELSE: 103,\n  OP_ENDIF: 104,\n  OP_VERIFY: 105,\n  OP_RETURN: 106,\n  OP_TOALTSTACK: 107,\n  OP_FROMALTSTACK: 108,\n  OP_2DROP: 109,\n  OP_2DUP: 110,\n  OP_3DUP: 111,\n  OP_2OVER: 112,\n  OP_2ROT: 113,\n  OP_2SWAP: 114,\n  OP_IFDUP: 115,\n  OP_DEPTH: 116,\n  OP_DROP: 117,\n  OP_DUP: 118,\n  OP_NIP: 119,\n  OP_OVER: 120,\n  OP_PICK: 121,\n  OP_ROLL: 122,\n  OP_ROT: 123,\n  OP_SWAP: 124,\n  OP_TUCK: 125,\n  OP_CAT: 126,\n  OP_SUBSTR: 127,\n  OP_LEFT: 128,\n  OP_RIGHT: 129,\n  OP_SIZE: 130,\n  OP_INVERT: 131,\n  OP_AND: 132,\n  OP_OR: 133,\n  OP_XOR: 134,\n  OP_EQUAL: 135,\n  OP_EQUALVERIFY: 136,\n  OP_RESERVED1: 137,\n  OP_RESERVED2: 138,\n  OP_1ADD: 139,\n  OP_1SUB: 140,\n  OP_2MUL: 141,\n  OP_2DIV: 142,\n  OP_NEGATE: 143,\n  OP_ABS: 144,\n  OP_NOT: 145,\n  OP_0NOTEQUAL: 146,\n  OP_ADD: 147,\n  OP_SUB: 148,\n  OP_MUL: 149,\n  OP_DIV: 150,\n  OP_MOD: 151,\n  OP_LSHIFT: 152,\n  OP_RSHIFT: 153,\n  OP_BOOLAND: 154,\n  OP_BOOLOR: 155,\n  OP_NUMEQUAL: 156,\n  OP_NUMEQUALVERIFY: 157,\n  OP_NUMNOTEQUAL: 158,\n  OP_LESSTHAN: 159,\n  OP_GREATERTHAN: 160,\n  OP_LESSTHANOREQUAL: 161,\n  OP_GREATERTHANOREQUAL: 162,\n  OP_MIN: 163,\n  OP_MAX: 164,\n  OP_WITHIN: 165,\n  OP_RIPEMD160: 166,\n  OP_SHA1: 167,\n  OP_SHA256: 168,\n  OP_HASH160: 169,\n  OP_HASH256: 170,\n  OP_CODESEPARATOR: 171,\n  OP_CHECKSIG: 172,\n  OP_CHECKSIGVERIFY: 173,\n  OP_CHECKMULTISIG: 174,\n  OP_CHECKMULTISIGVERIFY: 175,\n  OP_NOP1: 176,\n  OP_NOP2: 177,\n  OP_CHECKLOCKTIMEVERIFY: 177,\n  OP_NOP3: 178,\n  OP_CHECKSEQUENCEVERIFY: 178,\n  OP_NOP4: 179,\n  OP_NOP5: 180,\n  OP_NOP6: 181,\n  OP_NOP7: 182,\n  OP_NOP8: 183,\n  OP_NOP9: 184,\n  OP_NOP10: 185,\n  OP_CHECKSIGADD: 186,\n  OP_PUBKEYHASH: 253,\n  OP_PUBKEY: 254,\n  OP_INVALIDOPCODE: 255,\n};\nconst REVERSE_OPS = {};\nfor (const op of Object.keys(OPS)) {\n  const code = OPS[op];\n  REVERSE_OPS[code] = op;\n}\nexport { OPS, REVERSE_OPS };\n"],"names":[],"mappings":";;;;AAAA,MAAM,MAAM;IACV,UAAU;IACV,MAAM;IACN,cAAc;IACd,cAAc;IACd,cAAc;IACd,YAAY;IACZ,aAAa;IACb,SAAS;IACT,MAAM;IACN,MAAM;IACN,MAAM;IACN,MAAM;IACN,MAAM;IACN,MAAM;IACN,MAAM;IACN,MAAM;IACN,MAAM;IACN,OAAO;IACP,OAAO;IACP,OAAO;IACP,OAAO;IACP,OAAO;IACP,OAAO;IACP,OAAO;IACP,QAAQ;IACR,QAAQ;IACR,OAAO;IACP,UAAU;IACV,UAAU;IACV,aAAa;IACb,SAAS;IACT,UAAU;IACV,WAAW;IACX,WAAW;IACX,eAAe;IACf,iBAAiB;IACjB,UAAU;IACV,SAAS;IACT,SAAS;IACT,UAAU;IACV,SAAS;IACT,UAAU;IACV,UAAU;IACV,UAAU;IACV,SAAS;IACT,QAAQ;IACR,QAAQ;IACR,SAAS;IACT,SAAS;IACT,SAAS;IACT,QAAQ;IACR,SAAS;IACT,SAAS;IACT,QAAQ;IACR,WAAW;IACX,SAAS;IACT,UAAU;IACV,SAAS;IACT,WAAW;IACX,QAAQ;IACR,OAAO;IACP,QAAQ;IACR,UAAU;IACV,gBAAgB;IAChB,cAAc;IACd,cAAc;IACd,SAAS;IACT,SAAS;IACT,SAAS;IACT,SAAS;IACT,WAAW;IACX,QAAQ;IACR,QAAQ;IACR,cAAc;IACd,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,QAAQ;IACR,WAAW;IACX,WAAW;IACX,YAAY;IACZ,WAAW;IACX,aAAa;IACb,mBAAmB;IACnB,gBAAgB;IAChB,aAAa;IACb,gBAAgB;IAChB,oBAAoB;IACpB,uBAAuB;IACvB,QAAQ;IACR,QAAQ;IACR,WAAW;IACX,cAAc;IACd,SAAS;IACT,WAAW;IACX,YAAY;IACZ,YAAY;IACZ,kBAAkB;IAClB,aAAa;IACb,mBAAmB;IACnB,kBAAkB;IAClB,wBAAwB;IACxB,SAAS;IACT,SAAS;IACT,wBAAwB;IACxB,SAAS;IACT,wBAAwB;IACxB,SAAS;IACT,SAAS;IACT,SAAS;IACT,SAAS;IACT,SAAS;IACT,SAAS;IACT,UAAU;IACV,gBAAgB;IAChB,eAAe;IACf,WAAW;IACX,kBAAkB;AACpB;AACA,MAAM,cAAc,CAAC;AACrB,KAAK,MAAM,MAAM,OAAO,IAAI,CAAC,KAAM;IACjC,MAAM,OAAO,GAAG,CAAC,GAAG;IACpB,WAAW,CAAC,KAAK,GAAG;AACtB","ignoreList":[0]}},
    {"offset": {"line": 286, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 292, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bitcoinjs-lib/src/esm/push_data.js"],"sourcesContent":["import { OPS } from './ops.js';\nimport * as tools from 'uint8array-tools';\n/**\n * Calculates the encoding length of a number used for push data in Bitcoin transactions.\n * @param i The number to calculate the encoding length for.\n * @returns The encoding length of the number.\n */\nexport function encodingLength(i) {\n  return i < OPS.OP_PUSHDATA1 ? 1 : i <= 0xff ? 2 : i <= 0xffff ? 3 : 5;\n}\n/**\n * Encodes a number into a buffer using a variable-length encoding scheme.\n * The encoded buffer is written starting at the specified offset.\n * Returns the size of the encoded buffer.\n *\n * @param buffer - The buffer to write the encoded data into.\n * @param num - The number to encode.\n * @param offset - The offset at which to start writing the encoded buffer.\n * @returns The size of the encoded buffer.\n */\nexport function encode(buffer, num, offset) {\n  const size = encodingLength(num);\n  // ~6 bit\n  if (size === 1) {\n    tools.writeUInt8(buffer, offset, num);\n    // 8 bit\n  } else if (size === 2) {\n    tools.writeUInt8(buffer, offset, OPS.OP_PUSHDATA1);\n    tools.writeUInt8(buffer, offset + 1, num);\n    // 16 bit\n  } else if (size === 3) {\n    tools.writeUInt8(buffer, offset, OPS.OP_PUSHDATA2);\n    tools.writeUInt16(buffer, offset + 1, num, 'LE');\n    // 32 bit\n  } else {\n    tools.writeUInt8(buffer, offset, OPS.OP_PUSHDATA4);\n    tools.writeUInt32(buffer, offset + 1, num, 'LE');\n  }\n  return size;\n}\n/**\n * Decodes a buffer and returns information about the opcode, number, and size.\n * @param buffer - The buffer to decode.\n * @param offset - The offset within the buffer to start decoding.\n * @returns An object containing the opcode, number, and size, or null if decoding fails.\n */\nexport function decode(buffer, offset) {\n  const opcode = tools.readUInt8(buffer, offset);\n  let num;\n  let size;\n  // ~6 bit\n  if (opcode < OPS.OP_PUSHDATA1) {\n    num = opcode;\n    size = 1;\n    // 8 bit\n  } else if (opcode === OPS.OP_PUSHDATA1) {\n    if (offset + 2 > buffer.length) return null;\n    num = tools.readUInt8(buffer, offset + 1);\n    size = 2;\n    // 16 bit\n  } else if (opcode === OPS.OP_PUSHDATA2) {\n    if (offset + 3 > buffer.length) return null;\n    num = tools.readUInt16(buffer, offset + 1, 'LE');\n    size = 3;\n    // 32 bit\n  } else {\n    if (offset + 5 > buffer.length) return null;\n    if (opcode !== OPS.OP_PUSHDATA4) throw new Error('Unexpected opcode');\n    num = tools.readUInt32(buffer, offset + 1, 'LE');\n    size = 5;\n  }\n  return {\n    opcode,\n    number: num,\n    size,\n  };\n}\n"],"names":[],"mappings":";;;;;AAAA;AACA;;;AAMO,SAAS,eAAe,CAAC;IAC9B,OAAO,IAAI,qJAAA,CAAA,MAAG,CAAC,YAAY,GAAG,IAAI,KAAK,OAAO,IAAI,KAAK,SAAS,IAAI;AACtE;AAWO,SAAS,OAAO,MAAM,EAAE,GAAG,EAAE,MAAM;IACxC,MAAM,OAAO,eAAe;IAC5B,SAAS;IACT,IAAI,SAAS,GAAG;QACd,2JAAM,UAAU,CAAC,QAAQ,QAAQ;IACjC,QAAQ;IACV,OAAO,IAAI,SAAS,GAAG;QACrB,2JAAM,UAAU,CAAC,QAAQ,QAAQ,qJAAA,CAAA,MAAG,CAAC,YAAY;QACjD,2JAAM,UAAU,CAAC,QAAQ,SAAS,GAAG;IACrC,SAAS;IACX,OAAO,IAAI,SAAS,GAAG;QACrB,2JAAM,UAAU,CAAC,QAAQ,QAAQ,qJAAA,CAAA,MAAG,CAAC,YAAY;QACjD,2JAAM,WAAW,CAAC,QAAQ,SAAS,GAAG,KAAK;IAC3C,SAAS;IACX,OAAO;QACL,2JAAM,UAAU,CAAC,QAAQ,QAAQ,qJAAA,CAAA,MAAG,CAAC,YAAY;QACjD,2JAAM,WAAW,CAAC,QAAQ,SAAS,GAAG,KAAK;IAC7C;IACA,OAAO;AACT;AAOO,SAAS,OAAO,MAAM,EAAE,MAAM;IACnC,MAAM,SAAS,2JAAM,SAAS,CAAC,QAAQ;IACvC,IAAI;IACJ,IAAI;IACJ,SAAS;IACT,IAAI,SAAS,qJAAA,CAAA,MAAG,CAAC,YAAY,EAAE;QAC7B,MAAM;QACN,OAAO;IACP,QAAQ;IACV,OAAO,IAAI,WAAW,qJAAA,CAAA,MAAG,CAAC,YAAY,EAAE;QACtC,IAAI,SAAS,IAAI,OAAO,MAAM,EAAE,OAAO;QACvC,MAAM,2JAAM,SAAS,CAAC,QAAQ,SAAS;QACvC,OAAO;IACP,SAAS;IACX,OAAO,IAAI,WAAW,qJAAA,CAAA,MAAG,CAAC,YAAY,EAAE;QACtC,IAAI,SAAS,IAAI,OAAO,MAAM,EAAE,OAAO;QACvC,MAAM,2JAAM,UAAU,CAAC,QAAQ,SAAS,GAAG;QAC3C,OAAO;IACP,SAAS;IACX,OAAO;QACL,IAAI,SAAS,IAAI,OAAO,MAAM,EAAE,OAAO;QACvC,IAAI,WAAW,qJAAA,CAAA,MAAG,CAAC,YAAY,EAAE,MAAM,IAAI,MAAM;QACjD,MAAM,2JAAM,UAAU,CAAC,QAAQ,SAAS,GAAG;QAC3C,OAAO;IACT;IACA,OAAO;QACL;QACA,QAAQ;QACR;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 355, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 361, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bitcoinjs-lib/src/esm/script_number.js"],"sourcesContent":["import * as tools from 'uint8array-tools';\n/**\n * Decodes a script number from a buffer.\n *\n * @param buffer - The buffer containing the script number.\n * @param maxLength - The maximum length of the script number. Defaults to 4.\n * @param minimal - Whether the script number should be minimal. Defaults to true.\n * @returns The decoded script number.\n * @throws {TypeError} If the script number overflows the maximum length.\n * @throws {Error} If the script number is not minimally encoded when minimal is true.\n */\nexport function decode(buffer, maxLength, minimal) {\n  maxLength = maxLength || 4;\n  minimal = minimal === undefined ? true : minimal;\n  const length = buffer.length;\n  if (length === 0) return 0;\n  if (length > maxLength) throw new TypeError('Script number overflow');\n  if (minimal) {\n    if ((buffer[length - 1] & 0x7f) === 0) {\n      if (length <= 1 || (buffer[length - 2] & 0x80) === 0)\n        throw new Error('Non-minimally encoded script number');\n    }\n  }\n  // 40-bit\n  if (length === 5) {\n    const a = tools.readUInt32(buffer, 0, 'LE');\n    const b = tools.readUInt8(buffer, 4);\n    if (b & 0x80) return -((b & ~0x80) * 0x100000000 + a);\n    return b * 0x100000000 + a;\n  }\n  // 32-bit / 24-bit / 16-bit / 8-bit\n  let result = 0;\n  for (let i = 0; i < length; ++i) {\n    result |= buffer[i] << (8 * i);\n  }\n  if (buffer[length - 1] & 0x80)\n    return -(result & ~(0x80 << (8 * (length - 1))));\n  return result;\n}\nfunction scriptNumSize(i) {\n  return i > 0x7fffffff\n    ? 5\n    : i > 0x7fffff\n      ? 4\n      : i > 0x7fff\n        ? 3\n        : i > 0x7f\n          ? 2\n          : i > 0x00\n            ? 1\n            : 0;\n}\n/**\n * Encodes a number into a Uint8Array using a specific format.\n *\n * @param _number - The number to encode.\n * @returns The encoded number as a Uint8Array.\n */\nexport function encode(_number) {\n  let value = Math.abs(_number);\n  const size = scriptNumSize(value);\n  const buffer = new Uint8Array(size);\n  const negative = _number < 0;\n  for (let i = 0; i < size; ++i) {\n    tools.writeUInt8(buffer, i, value & 0xff);\n    value >>= 8;\n  }\n  if (buffer[size - 1] & 0x80) {\n    tools.writeUInt8(buffer, size - 1, negative ? 0x80 : 0x00);\n  } else if (negative) {\n    buffer[size - 1] |= 0x80;\n  }\n  return buffer;\n}\n"],"names":[],"mappings":";;;;AAAA;;AAWO,SAAS,OAAO,MAAM,EAAE,SAAS,EAAE,OAAO;IAC/C,YAAY,aAAa;IACzB,UAAU,YAAY,YAAY,OAAO;IACzC,MAAM,SAAS,OAAO,MAAM;IAC5B,IAAI,WAAW,GAAG,OAAO;IACzB,IAAI,SAAS,WAAW,MAAM,IAAI,UAAU;IAC5C,IAAI,SAAS;QACX,IAAI,CAAC,MAAM,CAAC,SAAS,EAAE,GAAG,IAAI,MAAM,GAAG;YACrC,IAAI,UAAU,KAAK,CAAC,MAAM,CAAC,SAAS,EAAE,GAAG,IAAI,MAAM,GACjD,MAAM,IAAI,MAAM;QACpB;IACF;IACA,SAAS;IACT,IAAI,WAAW,GAAG;QAChB,MAAM,IAAI,2JAAM,UAAU,CAAC,QAAQ,GAAG;QACtC,MAAM,IAAI,2JAAM,SAAS,CAAC,QAAQ;QAClC,IAAI,IAAI,MAAM,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,IAAI,cAAc,CAAC;QACpD,OAAO,IAAI,cAAc;IAC3B;IACA,mCAAmC;IACnC,IAAI,SAAS;IACb,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,EAAE,EAAG;QAC/B,UAAU,MAAM,CAAC,EAAE,IAAK,IAAI;IAC9B;IACA,IAAI,MAAM,CAAC,SAAS,EAAE,GAAG,MACvB,OAAO,CAAC,CAAC,SAAS,CAAC,CAAC,QAAS,IAAI,CAAC,SAAS,CAAC,CAAE,CAAC;IACjD,OAAO;AACT;AACA,SAAS,cAAc,CAAC;IACtB,OAAO,IAAI,aACP,IACA,IAAI,WACF,IACA,IAAI,SACF,IACA,IAAI,OACF,IACA,IAAI,OACF,IACA;AACd;AAOO,SAAS,OAAO,OAAO;IAC5B,IAAI,QAAQ,KAAK,GAAG,CAAC;IACrB,MAAM,OAAO,cAAc;IAC3B,MAAM,SAAS,IAAI,WAAW;IAC9B,MAAM,WAAW,UAAU;IAC3B,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,EAAE,EAAG;QAC7B,2JAAM,UAAU,CAAC,QAAQ,GAAG,QAAQ;QACpC,UAAU;IACZ;IACA,IAAI,MAAM,CAAC,OAAO,EAAE,GAAG,MAAM;QAC3B,2JAAM,UAAU,CAAC,QAAQ,OAAO,GAAG,WAAW,OAAO;IACvD,OAAO,IAAI,UAAU;QACnB,MAAM,CAAC,OAAO,EAAE,IAAI;IACtB;IACA,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 412, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 418, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bitcoinjs-lib/src/esm/types.js"],"sourcesContent":["import * as tools from 'uint8array-tools';\nimport * as v from 'valibot';\nconst ZERO32 = new Uint8Array(32);\nconst EC_P = tools.fromHex(\n  'fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f',\n);\nexport const NBufferSchemaFactory = size =>\n  v.pipe(v.instance(Uint8Array), v.length(size));\n/**\n * Checks if two arrays of Buffers are equal.\n * @param a - The first array of Buffers.\n * @param b - The second array of Buffers.\n * @returns True if the arrays are equal, false otherwise.\n */\nexport function stacksEqual(a, b) {\n  if (a.length !== b.length) return false;\n  return a.every((x, i) => {\n    return tools.compare(x, b[i]) === 0;\n  });\n}\n/**\n * Checks if the given value is a valid elliptic curve point.\n * @param p - The value to check.\n * @returns True if the value is a valid elliptic curve point, false otherwise.\n */\nexport function isPoint(p) {\n  if (!(p instanceof Uint8Array)) return false;\n  if (p.length < 33) return false;\n  const t = p[0];\n  const x = p.slice(1, 33);\n  if (tools.compare(ZERO32, x) === 0) return false;\n  if (tools.compare(x, EC_P) >= 0) return false;\n  if ((t === 0x02 || t === 0x03) && p.length === 33) {\n    return true;\n  }\n  const y = p.slice(33);\n  if (tools.compare(ZERO32, y) === 0) return false;\n  if (tools.compare(y, EC_P) >= 0) return false;\n  if (t === 0x04 && p.length === 65) return true;\n  return false;\n}\nexport const TAPLEAF_VERSION_MASK = 0xfe;\nexport function isTapleaf(o) {\n  if (!o || !('output' in o)) return false;\n  if (!(o.output instanceof Uint8Array)) return false;\n  if (o.version !== undefined)\n    return (o.version & TAPLEAF_VERSION_MASK) === o.version;\n  return true;\n}\nexport function isTaptree(scriptTree) {\n  if (!Array.isArray(scriptTree)) return isTapleaf(scriptTree);\n  if (scriptTree.length !== 2) return false;\n  return scriptTree.every(t => isTaptree(t));\n}\nexport const Buffer256bitSchema = NBufferSchemaFactory(32);\nexport const Hash160bitSchema = NBufferSchemaFactory(20);\nexport const Hash256bitSchema = NBufferSchemaFactory(32);\nexport const BufferSchema = v.instance(Uint8Array);\nexport const HexSchema = v.pipe(v.string(), v.regex(/^([0-9a-f]{2})+$/i));\nexport const UInt8Schema = v.pipe(\n  v.number(),\n  v.integer(),\n  v.minValue(0),\n  v.maxValue(0xff),\n);\nexport const UInt32Schema = v.pipe(\n  v.number(),\n  v.integer(),\n  v.minValue(0),\n  v.maxValue(0xffffffff),\n);\nexport const SatoshiSchema = v.pipe(\n  v.bigint(),\n  v.minValue(0n),\n  v.maxValue(0x7fffffffffffffffn),\n);\nexport const NullablePartial = a =>\n  v.object(\n    Object.entries(a).reduce(\n      (acc, next) => ({ ...acc, [next[0]]: v.nullish(next[1]) }),\n      {},\n    ),\n  );\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAAA;AACA;;;AACA,MAAM,SAAS,IAAI,WAAW;AAC9B,MAAM,OAAO,2JAAM,OAAO,CACxB;AAEK,MAAM,uBAAuB,CAAA,OAClC,yIAAE,IAAI,CAAC,yIAAE,QAAQ,CAAC,aAAa,yIAAE,MAAM,CAAC;AAOnC,SAAS,YAAY,CAAC,EAAE,CAAC;IAC9B,IAAI,EAAE,MAAM,KAAK,EAAE,MAAM,EAAE,OAAO;IAClC,OAAO,EAAE,KAAK,CAAC,CAAC,GAAG;QACjB,OAAO,2JAAM,OAAO,CAAC,GAAG,CAAC,CAAC,EAAE,MAAM;IACpC;AACF;AAMO,SAAS,QAAQ,CAAC;IACvB,IAAI,CAAC,CAAC,aAAa,UAAU,GAAG,OAAO;IACvC,IAAI,EAAE,MAAM,GAAG,IAAI,OAAO;IAC1B,MAAM,IAAI,CAAC,CAAC,EAAE;IACd,MAAM,IAAI,EAAE,KAAK,CAAC,GAAG;IACrB,IAAI,2JAAM,OAAO,CAAC,QAAQ,OAAO,GAAG,OAAO;IAC3C,IAAI,2JAAM,OAAO,CAAC,GAAG,SAAS,GAAG,OAAO;IACxC,IAAI,CAAC,MAAM,QAAQ,MAAM,IAAI,KAAK,EAAE,MAAM,KAAK,IAAI;QACjD,OAAO;IACT;IACA,MAAM,IAAI,EAAE,KAAK,CAAC;IAClB,IAAI,2JAAM,OAAO,CAAC,QAAQ,OAAO,GAAG,OAAO;IAC3C,IAAI,2JAAM,OAAO,CAAC,GAAG,SAAS,GAAG,OAAO;IACxC,IAAI,MAAM,QAAQ,EAAE,MAAM,KAAK,IAAI,OAAO;IAC1C,OAAO;AACT;AACO,MAAM,uBAAuB;AAC7B,SAAS,UAAU,CAAC;IACzB,IAAI,CAAC,KAAK,CAAC,CAAC,YAAY,CAAC,GAAG,OAAO;IACnC,IAAI,CAAC,CAAC,EAAE,MAAM,YAAY,UAAU,GAAG,OAAO;IAC9C,IAAI,EAAE,OAAO,KAAK,WAChB,OAAO,CAAC,EAAE,OAAO,GAAG,oBAAoB,MAAM,EAAE,OAAO;IACzD,OAAO;AACT;AACO,SAAS,UAAU,UAAU;IAClC,IAAI,CAAC,MAAM,OAAO,CAAC,aAAa,OAAO,UAAU;IACjD,IAAI,WAAW,MAAM,KAAK,GAAG,OAAO;IACpC,OAAO,WAAW,KAAK,CAAC,CAAA,IAAK,UAAU;AACzC;AACO,MAAM,qBAAqB,qBAAqB;AAChD,MAAM,mBAAmB,qBAAqB;AAC9C,MAAM,mBAAmB,qBAAqB;AAC9C,MAAM,eAAe,yIAAE,QAAQ,CAAC;AAChC,MAAM,YAAY,yIAAE,IAAI,CAAC,yIAAE,MAAM,IAAI,yIAAE,KAAK,CAAC;AAC7C,MAAM,cAAc,yIAAE,IAAI,CAC/B,yIAAE,MAAM,IACR,yIAAE,OAAO,IACT,yIAAE,QAAQ,CAAC,IACX,yIAAE,QAAQ,CAAC;AAEN,MAAM,eAAe,yIAAE,IAAI,CAChC,yIAAE,MAAM,IACR,yIAAE,OAAO,IACT,yIAAE,QAAQ,CAAC,IACX,yIAAE,QAAQ,CAAC;AAEN,MAAM,gBAAgB,yIAAE,IAAI,CACjC,yIAAE,MAAM,IACR,yIAAE,QAAQ,CAAC,EAAE,GACb,yIAAE,QAAQ,CAAC,mBAAmB;AAEzB,MAAM,kBAAkB,CAAA,IAC7B,yIAAE,MAAM,CACN,OAAO,OAAO,CAAC,GAAG,MAAM,CACtB,CAAC,KAAK,OAAS,CAAC;YAAE,GAAG,GAAG;YAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,yIAAE,OAAO,CAAC,IAAI,CAAC,EAAE;QAAE,CAAC,GACzD,CAAC","ignoreList":[0]}},
    {"offset": {"line": 488, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 494, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bitcoinjs-lib/src/esm/script.js"],"sourcesContent":["/**\n * Script tools, including decompile, compile, toASM, fromASM, toStack, isCanonicalPubKey, isCanonicalScriptSignature\n * @packageDocumentation\n */\nimport * as bip66 from './bip66.js';\nimport { OPS, REVERSE_OPS } from './ops.js';\nimport * as pushdata from './push_data.js';\nimport * as scriptNumber from './script_number.js';\nimport * as scriptSignature from './script_signature.js';\nimport * as types from './types.js';\nimport * as tools from 'uint8array-tools';\nimport * as v from 'valibot';\nconst OP_INT_BASE = OPS.OP_RESERVED; // OP_1 - 1\nexport { OPS };\nconst StackSchema = v.array(v.union([v.instance(Uint8Array), v.number()]));\nfunction isOPInt(value) {\n  return (\n    v.is(v.number(), value) &&\n    (value === OPS.OP_0 ||\n      (value >= OPS.OP_1 && value <= OPS.OP_16) ||\n      value === OPS.OP_1NEGATE)\n  );\n}\nfunction isPushOnlyChunk(value) {\n  return v.is(types.BufferSchema, value) || isOPInt(value);\n}\nexport function isPushOnly(value) {\n  return v.is(v.pipe(v.any(), v.everyItem(isPushOnlyChunk)), value);\n}\nexport function countNonPushOnlyOPs(value) {\n  return value.length - value.filter(isPushOnlyChunk).length;\n}\nfunction asMinimalOP(buffer) {\n  if (buffer.length === 0) return OPS.OP_0;\n  if (buffer.length !== 1) return;\n  if (buffer[0] >= 1 && buffer[0] <= 16) return OP_INT_BASE + buffer[0];\n  if (buffer[0] === 0x81) return OPS.OP_1NEGATE;\n}\nfunction chunksIsBuffer(buf) {\n  return buf instanceof Uint8Array;\n}\nfunction chunksIsArray(buf) {\n  return v.is(StackSchema, buf);\n}\nfunction singleChunkIsBuffer(buf) {\n  return buf instanceof Uint8Array;\n}\n/**\n * Compiles an array of chunks into a Buffer.\n *\n * @param chunks - The array of chunks to compile.\n * @returns The compiled Buffer.\n * @throws Error if the compilation fails.\n */\nexport function compile(chunks) {\n  // TODO: remove me\n  if (chunksIsBuffer(chunks)) return chunks;\n  v.parse(StackSchema, chunks);\n  const bufferSize = chunks.reduce((accum, chunk) => {\n    // data chunk\n    if (singleChunkIsBuffer(chunk)) {\n      // adhere to BIP62.3, minimal push policy\n      if (chunk.length === 1 && asMinimalOP(chunk) !== undefined) {\n        return accum + 1;\n      }\n      return accum + pushdata.encodingLength(chunk.length) + chunk.length;\n    }\n    // opcode\n    return accum + 1;\n  }, 0.0);\n  const buffer = new Uint8Array(bufferSize);\n  let offset = 0;\n  chunks.forEach(chunk => {\n    // data chunk\n    if (singleChunkIsBuffer(chunk)) {\n      // adhere to BIP62.3, minimal push policy\n      const opcode = asMinimalOP(chunk);\n      if (opcode !== undefined) {\n        tools.writeUInt8(buffer, offset, opcode);\n        offset += 1;\n        return;\n      }\n      offset += pushdata.encode(buffer, chunk.length, offset);\n      buffer.set(chunk, offset);\n      offset += chunk.length;\n      // opcode\n    } else {\n      tools.writeUInt8(buffer, offset, chunk);\n      offset += 1;\n    }\n  });\n  if (offset !== buffer.length) throw new Error('Could not decode chunks');\n  return buffer;\n}\nexport function decompile(buffer) {\n  // TODO: remove me\n  if (chunksIsArray(buffer)) return buffer;\n  v.parse(types.BufferSchema, buffer);\n  const chunks = [];\n  let i = 0;\n  while (i < buffer.length) {\n    const opcode = buffer[i];\n    // data chunk\n    if (opcode > OPS.OP_0 && opcode <= OPS.OP_PUSHDATA4) {\n      const d = pushdata.decode(buffer, i);\n      // did reading a pushDataInt fail?\n      if (d === null) return null;\n      i += d.size;\n      // attempt to read too much data?\n      if (i + d.number > buffer.length) return null;\n      const data = buffer.slice(i, i + d.number);\n      i += d.number;\n      // decompile minimally\n      const op = asMinimalOP(data);\n      if (op !== undefined) {\n        chunks.push(op);\n      } else {\n        chunks.push(data);\n      }\n      // opcode\n    } else {\n      chunks.push(opcode);\n      i += 1;\n    }\n  }\n  return chunks;\n}\n/**\n * Converts the given chunks into an ASM (Assembly) string representation.\n * If the chunks parameter is a Buffer, it will be decompiled into a Stack before conversion.\n * @param chunks - The chunks to convert into ASM.\n * @returns The ASM string representation of the chunks.\n */\nexport function toASM(chunks) {\n  if (chunksIsBuffer(chunks)) {\n    chunks = decompile(chunks);\n  }\n  if (!chunks) {\n    throw new Error('Could not convert invalid chunks to ASM');\n  }\n  return chunks\n    .map(chunk => {\n      // data?\n      if (singleChunkIsBuffer(chunk)) {\n        const op = asMinimalOP(chunk);\n        if (op === undefined) return tools.toHex(chunk);\n        chunk = op;\n      }\n      // opcode!\n      return REVERSE_OPS[chunk];\n    })\n    .join(' ');\n}\n/**\n * Converts an ASM string to a Buffer.\n * @param asm The ASM string to convert.\n * @returns The converted Buffer.\n */\nexport function fromASM(asm) {\n  v.parse(v.string(), asm);\n  return compile(\n    asm.split(' ').map(chunkStr => {\n      // opcode?\n      if (OPS[chunkStr] !== undefined) return OPS[chunkStr];\n      v.parse(types.HexSchema, chunkStr);\n      // data!\n      return tools.fromHex(chunkStr);\n    }),\n  );\n}\n/**\n * Converts the given chunks into a stack of buffers.\n *\n * @param chunks - The chunks to convert.\n * @returns The stack of buffers.\n */\nexport function toStack(chunks) {\n  chunks = decompile(chunks);\n  v.parse(v.custom(isPushOnly), chunks);\n  return chunks.map(op => {\n    if (singleChunkIsBuffer(op)) return op;\n    if (op === OPS.OP_0) return new Uint8Array(0);\n    return scriptNumber.encode(op - OP_INT_BASE);\n  });\n}\nexport function isCanonicalPubKey(buffer) {\n  return types.isPoint(buffer);\n}\nexport function isDefinedHashType(hashType) {\n  const hashTypeMod = hashType & ~0x80;\n  return hashTypeMod > 0x00 && hashTypeMod < 0x04;\n}\nexport function isCanonicalScriptSignature(buffer) {\n  if (!(buffer instanceof Uint8Array)) return false;\n  if (!isDefinedHashType(buffer[buffer.length - 1])) return false;\n  return bip66.check(buffer.slice(0, -1));\n}\nexport const number = scriptNumber;\nexport const signature = scriptSignature;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 684, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 690, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bitcoinjs-lib/src/esm/script_signature.js"],"sourcesContent":["import * as bip66 from './bip66.js';\nimport { isDefinedHashType } from './script.js';\nimport * as v from 'valibot';\nimport * as tools from 'uint8array-tools';\nimport { NBufferSchemaFactory, UInt8Schema } from './types.js';\nconst ZERO = new Uint8Array(1);\n/**\n * Converts a buffer to a DER-encoded buffer.\n * @param x - The buffer to be converted.\n * @returns The DER-encoded buffer.\n */\nfunction toDER(x) {\n  let i = 0;\n  while (x[i] === 0) ++i;\n  if (i === x.length) return ZERO;\n  x = x.slice(i);\n  if (x[0] & 0x80) return tools.concat([ZERO, x]);\n  return x;\n}\n/**\n * Converts a DER-encoded signature to a buffer.\n * If the first byte of the input buffer is 0x00, it is skipped.\n * The resulting buffer is 32 bytes long, filled with zeros if necessary.\n * @param x - The DER-encoded signature.\n * @returns The converted buffer.\n */\nfunction fromDER(x) {\n  if (x[0] === 0x00) x = x.slice(1);\n  const buffer = new Uint8Array(32);\n  const bstart = Math.max(0, 32 - x.length);\n  buffer.set(x, bstart);\n  return buffer;\n}\n// BIP62: 1 byte hashType flag (only 0x01, 0x02, 0x03, 0x81, 0x82 and 0x83 are allowed)\n/**\n * Decodes a buffer into a ScriptSignature object.\n * @param buffer - The buffer to decode.\n * @returns The decoded ScriptSignature object.\n * @throws Error if the hashType is invalid.\n */\nexport function decode(buffer) {\n  const hashType = tools.readUInt8(buffer, buffer.length - 1);\n  if (!isDefinedHashType(hashType)) {\n    throw new Error('Invalid hashType ' + hashType);\n  }\n  const decoded = bip66.decode(buffer.subarray(0, -1));\n  const r = fromDER(decoded.r);\n  const s = fromDER(decoded.s);\n  const signature = tools.concat([r, s]);\n  return { signature, hashType };\n}\n/**\n * Encodes a signature and hash type into a buffer.\n * @param signature - The signature to encode.\n * @param hashType - The hash type to encode.\n * @returns The encoded buffer.\n * @throws Error if the hashType is invalid.\n */\nexport function encode(signature, hashType) {\n  v.parse(\n    v.object({\n      signature: NBufferSchemaFactory(64),\n      hashType: UInt8Schema,\n    }),\n    { signature, hashType },\n  );\n  if (!isDefinedHashType(hashType)) {\n    throw new Error('Invalid hashType ' + hashType);\n  }\n  const hashTypeBuffer = new Uint8Array(1);\n  tools.writeUInt8(hashTypeBuffer, 0, hashType);\n  const r = toDER(signature.slice(0, 32));\n  const s = toDER(signature.slice(32, 64));\n  return tools.concat([bip66.encode(r, s), hashTypeBuffer]);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AAEA;AACA;AAHA;AACA;;;;;;AAGA,MAAM,OAAO,IAAI,WAAW;AAC5B;;;;CAIC,GACD,SAAS,MAAM,CAAC;IACd,IAAI,IAAI;IACR,MAAO,CAAC,CAAC,EAAE,KAAK,EAAG,EAAE;IACrB,IAAI,MAAM,EAAE,MAAM,EAAE,OAAO;IAC3B,IAAI,EAAE,KAAK,CAAC;IACZ,IAAI,CAAC,CAAC,EAAE,GAAG,MAAM,OAAO,2JAAM,MAAM,CAAC;QAAC;QAAM;KAAE;IAC9C,OAAO;AACT;AACA;;;;;;CAMC,GACD,SAAS,QAAQ,CAAC;IAChB,IAAI,CAAC,CAAC,EAAE,KAAK,MAAM,IAAI,EAAE,KAAK,CAAC;IAC/B,MAAM,SAAS,IAAI,WAAW;IAC9B,MAAM,SAAS,KAAK,GAAG,CAAC,GAAG,KAAK,EAAE,MAAM;IACxC,OAAO,GAAG,CAAC,GAAG;IACd,OAAO;AACT;AAQO,SAAS,OAAO,MAAM;IAC3B,MAAM,WAAW,2JAAM,SAAS,CAAC,QAAQ,OAAO,MAAM,GAAG;IACzD,IAAI,CAAC,CAAA,GAAA,wKAAA,CAAA,oBAAiB,AAAD,EAAE,WAAW;QAChC,MAAM,IAAI,MAAM,sBAAsB;IACxC;IACA,MAAM,UAAU,wJAAM,MAAM,CAAC,OAAO,QAAQ,CAAC,GAAG,CAAC;IACjD,MAAM,IAAI,QAAQ,QAAQ,CAAC;IAC3B,MAAM,IAAI,QAAQ,QAAQ,CAAC;IAC3B,MAAM,YAAY,2JAAM,MAAM,CAAC;QAAC;QAAG;KAAE;IACrC,OAAO;QAAE;QAAW;IAAS;AAC/B;AAQO,SAAS,OAAO,SAAS,EAAE,QAAQ;IACxC,yIAAE,KAAK,CACL,yIAAE,MAAM,CAAC;QACP,WAAW,CAAA,GAAA,uJAAA,CAAA,uBAAoB,AAAD,EAAE;QAChC,UAAU,uJAAA,CAAA,cAAW;IACvB,IACA;QAAE;QAAW;IAAS;IAExB,IAAI,CAAC,CAAA,GAAA,wKAAA,CAAA,oBAAiB,AAAD,EAAE,WAAW;QAChC,MAAM,IAAI,MAAM,sBAAsB;IACxC;IACA,MAAM,iBAAiB,IAAI,WAAW;IACtC,2JAAM,UAAU,CAAC,gBAAgB,GAAG;IACpC,MAAM,IAAI,MAAM,UAAU,KAAK,CAAC,GAAG;IACnC,MAAM,IAAI,MAAM,UAAU,KAAK,CAAC,IAAI;IACpC,OAAO,2JAAM,MAAM,CAAC;QAAC,wJAAM,MAAM,CAAC,GAAG;QAAI;KAAe;AAC1D","ignoreList":[0]}},
    {"offset": {"line": 771, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 792, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bitcoinjs-lib/src/esm/payments/lazy.js"],"sourcesContent":["export function prop(object, name, f) {\n  Object.defineProperty(object, name, {\n    configurable: true,\n    enumerable: true,\n    get() {\n      const _value = f.call(this);\n      this[name] = _value;\n      return _value;\n    },\n    set(_value) {\n      Object.defineProperty(this, name, {\n        configurable: true,\n        enumerable: true,\n        value: _value,\n        writable: true,\n      });\n    },\n  });\n}\nexport function value(f) {\n  let _value;\n  return () => {\n    if (_value !== undefined) return _value;\n    _value = f();\n    return _value;\n  };\n}\n"],"names":[],"mappings":";;;;AAAO,SAAS,KAAK,MAAM,EAAE,IAAI,EAAE,CAAC;IAClC,OAAO,cAAc,CAAC,QAAQ,MAAM;QAClC,cAAc;QACd,YAAY;QACZ;YACE,MAAM,SAAS,EAAE,IAAI,CAAC,IAAI;YAC1B,IAAI,CAAC,KAAK,GAAG;YACb,OAAO;QACT;QACA,KAAI,MAAM;YACR,OAAO,cAAc,CAAC,IAAI,EAAE,MAAM;gBAChC,cAAc;gBACd,YAAY;gBACZ,OAAO;gBACP,UAAU;YACZ;QACF;IACF;AACF;AACO,SAAS,MAAM,CAAC;IACrB,IAAI;IACJ,OAAO;QACL,IAAI,WAAW,WAAW,OAAO;QACjC,SAAS;QACT,OAAO;IACT;AACF","ignoreList":[0]}},
    {"offset": {"line": 823, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 875, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bitcoinjs-lib/src/esm/payments/embed.js"],"sourcesContent":["import { bitcoin as BITCOIN_NETWORK } from '../networks.js';\nimport * as bscript from '../script.js';\nimport { stacksEqual, BufferSchema } from '../types.js';\nimport * as lazy from './lazy.js';\nimport * as v from 'valibot';\nconst OPS = bscript.OPS;\n// output: OP_RETURN ...\n/**\n * Embeds data in a Bitcoin payment.\n * @param a - The payment object.\n * @param opts - Optional payment options.\n * @returns The modified payment object.\n * @throws {TypeError} If there is not enough data or if the output is invalid.\n */\nexport function p2data(a, opts) {\n  if (!a.data && !a.output) throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  v.parse(\n    v.partial(\n      v.object({\n        network: v.object({}),\n        output: BufferSchema,\n        data: v.array(BufferSchema),\n      }),\n    ),\n    a,\n  );\n  const network = a.network || BITCOIN_NETWORK;\n  const o = { name: 'embed', network };\n  lazy.prop(o, 'output', () => {\n    if (!a.data) return;\n    return bscript.compile([OPS.OP_RETURN].concat(a.data));\n  });\n  lazy.prop(o, 'data', () => {\n    if (!a.output) return;\n    return bscript.decompile(a.output).slice(1);\n  });\n  // extended validation\n  if (opts.validate) {\n    if (a.output) {\n      const chunks = bscript.decompile(a.output);\n      if (chunks[0] !== OPS.OP_RETURN) throw new TypeError('Output is invalid');\n      if (!chunks.slice(1).every(chunk => v.is(BufferSchema, chunk)))\n        throw new TypeError('Output is invalid');\n      if (a.data && !stacksEqual(a.data, o.data))\n        throw new TypeError('Data mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;AAFA;AAGA;;;;;;AACA,MAAM,MAAM,yJAAQ,GAAG;AAShB,SAAS,OAAO,CAAC,EAAE,IAAI;IAC5B,IAAI,CAAC,EAAE,IAAI,IAAI,CAAC,EAAE,MAAM,EAAE,MAAM,IAAI,UAAU;IAC9C,OAAO,OAAO,MAAM,CAAC;QAAE,UAAU;IAAK,GAAG,QAAQ,CAAC;IAClD,yIAAE,KAAK,CACL,yIAAE,OAAO,CACP,yIAAE,MAAM,CAAC;QACP,SAAS,yIAAE,MAAM,CAAC,CAAC;QACnB,QAAQ,uJAAA,CAAA,eAAY;QACpB,MAAM,yIAAE,KAAK,CAAC,uJAAA,CAAA,eAAY;IAC5B,KAEF;IAEF,MAAM,UAAU,EAAE,OAAO,IAAI,0JAAA,CAAA,UAAe;IAC5C,MAAM,IAAI;QAAE,MAAM;QAAS;IAAQ;IACnC,mKAAK,IAAI,CAAC,GAAG,UAAU;QACrB,IAAI,CAAC,EAAE,IAAI,EAAE;QACb,OAAO,yJAAQ,OAAO,CAAC;YAAC,IAAI,SAAS;SAAC,CAAC,MAAM,CAAC,EAAE,IAAI;IACtD;IACA,mKAAK,IAAI,CAAC,GAAG,QAAQ;QACnB,IAAI,CAAC,EAAE,MAAM,EAAE;QACf,OAAO,yJAAQ,SAAS,CAAC,EAAE,MAAM,EAAE,KAAK,CAAC;IAC3C;IACA,sBAAsB;IACtB,IAAI,KAAK,QAAQ,EAAE;QACjB,IAAI,EAAE,MAAM,EAAE;YACZ,MAAM,SAAS,yJAAQ,SAAS,CAAC,EAAE,MAAM;YACzC,IAAI,MAAM,CAAC,EAAE,KAAK,IAAI,SAAS,EAAE,MAAM,IAAI,UAAU;YACrD,IAAI,CAAC,OAAO,KAAK,CAAC,GAAG,KAAK,CAAC,CAAA,QAAS,yIAAE,EAAE,CAAC,uJAAA,CAAA,eAAY,EAAE,SACrD,MAAM,IAAI,UAAU;YACtB,IAAI,EAAE,IAAI,IAAI,CAAC,CAAA,GAAA,uJAAA,CAAA,cAAW,AAAD,EAAE,EAAE,IAAI,EAAE,EAAE,IAAI,GACvC,MAAM,IAAI,UAAU;QACxB;IACF;IACA,OAAO,OAAO,MAAM,CAAC,GAAG;AAC1B","ignoreList":[0]}},
    {"offset": {"line": 926, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 932, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bitcoinjs-lib/src/esm/payments/p2ms.js"],"sourcesContent":["import { bitcoin as BITCOIN_NETWORK } from '../networks.js';\nimport * as bscript from '../script.js';\nimport { BufferSchema, isPoint, stacksEqual } from '../types.js';\nimport * as lazy from './lazy.js';\nimport * as v from 'valibot';\nconst OPS = bscript.OPS;\nconst OP_INT_BASE = OPS.OP_RESERVED; // OP_1 - 1\n// input: OP_0 [signatures ...]\n// output: m [pubKeys ...] n OP_CHECKMULTISIG\n/**\n * Represents a function that creates a Pay-to-Multisig (P2MS) payment object.\n * @param a - The payment object.\n * @param opts - Optional payment options.\n * @returns The created payment object.\n * @throws {TypeError} If the provided data is not valid.\n */\nexport function p2ms(a, opts) {\n  if (\n    !a.input &&\n    !a.output &&\n    !(a.pubkeys && a.m !== undefined) &&\n    !a.signatures\n  )\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  function isAcceptableSignature(x) {\n    return (\n      bscript.isCanonicalScriptSignature(x) ||\n      (opts.allowIncomplete && x === OPS.OP_0) !== undefined\n    );\n  }\n  v.parse(\n    v.partial(\n      v.object({\n        network: v.object({}),\n        m: v.number(),\n        n: v.number(),\n        output: BufferSchema,\n        pubkeys: v.array(v.custom(isPoint), 'Received invalid pubkey'),\n        signatures: v.array(\n          v.custom(isAcceptableSignature),\n          'Expected signature to be of type isAcceptableSignature',\n        ),\n        input: BufferSchema,\n      }),\n    ),\n    a,\n  );\n  const network = a.network || BITCOIN_NETWORK;\n  const o = { network };\n  let chunks = [];\n  let decoded = false;\n  function decode(output) {\n    if (decoded) return;\n    decoded = true;\n    chunks = bscript.decompile(output);\n    o.m = chunks[0] - OP_INT_BASE;\n    o.n = chunks[chunks.length - 2] - OP_INT_BASE;\n    o.pubkeys = chunks.slice(1, -2);\n  }\n  lazy.prop(o, 'output', () => {\n    if (!a.m) return;\n    if (!o.n) return;\n    if (!a.pubkeys) return;\n    return bscript.compile(\n      [].concat(\n        OP_INT_BASE + a.m,\n        a.pubkeys,\n        OP_INT_BASE + o.n,\n        OPS.OP_CHECKMULTISIG,\n      ),\n    );\n  });\n  lazy.prop(o, 'm', () => {\n    if (!o.output) return;\n    decode(o.output);\n    return o.m;\n  });\n  lazy.prop(o, 'n', () => {\n    if (!o.pubkeys) return;\n    return o.pubkeys.length;\n  });\n  lazy.prop(o, 'pubkeys', () => {\n    if (!a.output) return;\n    decode(a.output);\n    return o.pubkeys;\n  });\n  lazy.prop(o, 'signatures', () => {\n    if (!a.input) return;\n    return bscript.decompile(a.input).slice(1);\n  });\n  lazy.prop(o, 'input', () => {\n    if (!a.signatures) return;\n    return bscript.compile([OPS.OP_0].concat(a.signatures));\n  });\n  lazy.prop(o, 'witness', () => {\n    if (!o.input) return;\n    return [];\n  });\n  lazy.prop(o, 'name', () => {\n    if (!o.m || !o.n) return;\n    return `p2ms(${o.m} of ${o.n})`;\n  });\n  // extended validation\n  if (opts.validate) {\n    if (a.output) {\n      decode(a.output);\n      v.parse(v.number(), chunks[0], { message: 'Output is invalid' });\n      v.parse(v.number(), chunks[chunks.length - 2], {\n        message: 'Output is invalid',\n      });\n      if (chunks[chunks.length - 1] !== OPS.OP_CHECKMULTISIG)\n        throw new TypeError('Output is invalid');\n      if (o.m <= 0 || o.n > 16 || o.m > o.n || o.n !== chunks.length - 3)\n        throw new TypeError('Output is invalid');\n      if (!o.pubkeys.every(x => isPoint(x)))\n        throw new TypeError('Output is invalid');\n      if (a.m !== undefined && a.m !== o.m) throw new TypeError('m mismatch');\n      if (a.n !== undefined && a.n !== o.n) throw new TypeError('n mismatch');\n      if (a.pubkeys && !stacksEqual(a.pubkeys, o.pubkeys))\n        throw new TypeError('Pubkeys mismatch');\n    }\n    if (a.pubkeys) {\n      if (a.n !== undefined && a.n !== a.pubkeys.length)\n        throw new TypeError('Pubkey count mismatch');\n      o.n = a.pubkeys.length;\n      if (o.n < o.m) throw new TypeError('Pubkey count cannot be less than m');\n    }\n    if (a.signatures) {\n      if (a.signatures.length < o.m)\n        throw new TypeError('Not enough signatures provided');\n      if (a.signatures.length > o.m)\n        throw new TypeError('Too many signatures provided');\n    }\n    if (a.input) {\n      if (a.input[0] !== OPS.OP_0) throw new TypeError('Input is invalid');\n      if (\n        o.signatures.length === 0 ||\n        !o.signatures.every(isAcceptableSignature)\n      )\n        throw new TypeError('Input has invalid signature(s)');\n      if (a.signatures && !stacksEqual(a.signatures, o.signatures))\n        throw new TypeError('Signature mismatch');\n      if (a.m !== undefined && a.m !== a.signatures.length)\n        throw new TypeError('Signature count mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1052, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1058, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bitcoinjs-lib/src/esm/payments/p2pk.js"],"sourcesContent":["import { bitcoin as BITCOIN_NETWORK } from '../networks.js';\nimport * as bscript from '../script.js';\nimport { BufferSchema, isPoint } from '../types.js';\nimport * as lazy from './lazy.js';\nimport * as tools from 'uint8array-tools';\nimport * as v from 'valibot';\nconst OPS = bscript.OPS;\n// input: {signature}\n// output: {pubKey} OP_CHECKSIG\n/**\n * Creates a pay-to-public-key (P2PK) payment object.\n *\n * @param a - The payment object containing the necessary data.\n * @param opts - Optional payment options.\n * @returns The P2PK payment object.\n * @throws {TypeError} If the required data is not provided or if the data is invalid.\n */\nexport function p2pk(a, opts) {\n  if (!a.input && !a.output && !a.pubkey && !a.input && !a.signature)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  v.parse(\n    v.partial(\n      v.object({\n        network: v.object({}),\n        output: BufferSchema,\n        pubkey: v.custom(isPoint, 'invalid pubkey'),\n        signature: v.custom(\n          bscript.isCanonicalScriptSignature,\n          'Expected signature to be of type isCanonicalScriptSignature',\n        ),\n        input: BufferSchema,\n      }),\n    ),\n    a,\n  );\n  const _chunks = lazy.value(() => {\n    return bscript.decompile(a.input);\n  });\n  const network = a.network || BITCOIN_NETWORK;\n  const o = { name: 'p2pk', network };\n  lazy.prop(o, 'output', () => {\n    if (!a.pubkey) return;\n    return bscript.compile([a.pubkey, OPS.OP_CHECKSIG]);\n  });\n  lazy.prop(o, 'pubkey', () => {\n    if (!a.output) return;\n    return a.output.slice(1, -1);\n  });\n  lazy.prop(o, 'signature', () => {\n    if (!a.input) return;\n    return _chunks()[0];\n  });\n  lazy.prop(o, 'input', () => {\n    if (!a.signature) return;\n    return bscript.compile([a.signature]);\n  });\n  lazy.prop(o, 'witness', () => {\n    if (!o.input) return;\n    return [];\n  });\n  // extended validation\n  if (opts.validate) {\n    if (a.output) {\n      if (a.output[a.output.length - 1] !== OPS.OP_CHECKSIG)\n        throw new TypeError('Output is invalid');\n      if (!isPoint(o.pubkey)) throw new TypeError('Output pubkey is invalid');\n      if (a.pubkey && tools.compare(a.pubkey, o.pubkey) !== 0)\n        throw new TypeError('Pubkey mismatch');\n    }\n    if (a.signature) {\n      if (a.input && tools.compare(a.input, o.input) !== 0)\n        throw new TypeError('Signature mismatch');\n    }\n    if (a.input) {\n      if (_chunks().length !== 1) throw new TypeError('Input is invalid');\n      if (!bscript.isCanonicalScriptSignature(o.signature))\n        throw new TypeError('Input has invalid signature');\n    }\n  }\n  return Object.assign(o, a);\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;AAHA;AAIA;;;;;;;AACA,MAAM,MAAM,yJAAQ,GAAG;AAWhB,SAAS,KAAK,CAAC,EAAE,IAAI;IAC1B,IAAI,CAAC,EAAE,KAAK,IAAI,CAAC,EAAE,MAAM,IAAI,CAAC,EAAE,MAAM,IAAI,CAAC,EAAE,KAAK,IAAI,CAAC,EAAE,SAAS,EAChE,MAAM,IAAI,UAAU;IACtB,OAAO,OAAO,MAAM,CAAC;QAAE,UAAU;IAAK,GAAG,QAAQ,CAAC;IAClD,yIAAE,KAAK,CACL,yIAAE,OAAO,CACP,yIAAE,MAAM,CAAC;QACP,SAAS,yIAAE,MAAM,CAAC,CAAC;QACnB,QAAQ,uJAAA,CAAA,eAAY;QACpB,QAAQ,yIAAE,MAAM,CAAC,uJAAA,CAAA,UAAO,EAAE;QAC1B,WAAW,yIAAE,MAAM,CACjB,yJAAQ,0BAA0B,EAClC;QAEF,OAAO,uJAAA,CAAA,eAAY;IACrB,KAEF;IAEF,MAAM,UAAU,mKAAK,KAAK,CAAC;QACzB,OAAO,yJAAQ,SAAS,CAAC,EAAE,KAAK;IAClC;IACA,MAAM,UAAU,EAAE,OAAO,IAAI,0JAAA,CAAA,UAAe;IAC5C,MAAM,IAAI;QAAE,MAAM;QAAQ;IAAQ;IAClC,mKAAK,IAAI,CAAC,GAAG,UAAU;QACrB,IAAI,CAAC,EAAE,MAAM,EAAE;QACf,OAAO,yJAAQ,OAAO,CAAC;YAAC,EAAE,MAAM;YAAE,IAAI,WAAW;SAAC;IACpD;IACA,mKAAK,IAAI,CAAC,GAAG,UAAU;QACrB,IAAI,CAAC,EAAE,MAAM,EAAE;QACf,OAAO,EAAE,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC;IAC5B;IACA,mKAAK,IAAI,CAAC,GAAG,aAAa;QACxB,IAAI,CAAC,EAAE,KAAK,EAAE;QACd,OAAO,SAAS,CAAC,EAAE;IACrB;IACA,mKAAK,IAAI,CAAC,GAAG,SAAS;QACpB,IAAI,CAAC,EAAE,SAAS,EAAE;QAClB,OAAO,yJAAQ,OAAO,CAAC;YAAC,EAAE,SAAS;SAAC;IACtC;IACA,mKAAK,IAAI,CAAC,GAAG,WAAW;QACtB,IAAI,CAAC,EAAE,KAAK,EAAE;QACd,OAAO,EAAE;IACX;IACA,sBAAsB;IACtB,IAAI,KAAK,QAAQ,EAAE;QACjB,IAAI,EAAE,MAAM,EAAE;YACZ,IAAI,EAAE,MAAM,CAAC,EAAE,MAAM,CAAC,MAAM,GAAG,EAAE,KAAK,IAAI,WAAW,EACnD,MAAM,IAAI,UAAU;YACtB,IAAI,CAAC,CAAA,GAAA,uJAAA,CAAA,UAAO,AAAD,EAAE,EAAE,MAAM,GAAG,MAAM,IAAI,UAAU;YAC5C,IAAI,EAAE,MAAM,IAAI,2JAAM,OAAO,CAAC,EAAE,MAAM,EAAE,EAAE,MAAM,MAAM,GACpD,MAAM,IAAI,UAAU;QACxB;QACA,IAAI,EAAE,SAAS,EAAE;YACf,IAAI,EAAE,KAAK,IAAI,2JAAM,OAAO,CAAC,EAAE,KAAK,EAAE,EAAE,KAAK,MAAM,GACjD,MAAM,IAAI,UAAU;QACxB;QACA,IAAI,EAAE,KAAK,EAAE;YACX,IAAI,UAAU,MAAM,KAAK,GAAG,MAAM,IAAI,UAAU;YAChD,IAAI,CAAC,yJAAQ,0BAA0B,CAAC,EAAE,SAAS,GACjD,MAAM,IAAI,UAAU;QACxB;IACF;IACA,OAAO,OAAO,MAAM,CAAC,GAAG;AAC1B","ignoreList":[0]}},
    {"offset": {"line": 1137, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1143, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bitcoinjs-lib/src/esm/crypto.js"],"sourcesContent":["/**\n * A module for hashing functions.\n * include ripemd160sha1sha256hash160hash256taggedHash\n *\n * @packageDocumentation\n */\nimport { ripemd160 } from '@noble/hashes/ripemd160';\nimport { sha256 } from '@noble/hashes/sha256';\nimport * as tools from 'uint8array-tools';\nexport function hash160(buffer) {\n  return ripemd160(sha256(buffer));\n}\nexport function hash256(buffer) {\n  return sha256(sha256(buffer));\n}\nexport const TAGS = [\n  'BIP0340/challenge',\n  'BIP0340/aux',\n  'BIP0340/nonce',\n  'TapLeaf',\n  'TapBranch',\n  'TapSighash',\n  'TapTweak',\n  'KeyAgg list',\n  'KeyAgg coefficient',\n];\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\n/**\n * Defines the tagged hash prefixes used in the crypto module.\n */\nexport const TAGGED_HASH_PREFIXES = {\n  'BIP0340/challenge': Uint8Array.from([\n    123, 181, 45, 122, 159, 239, 88, 50, 62, 177, 191, 122, 64, 125, 179, 130,\n    210, 243, 242, 216, 27, 177, 34, 79, 73, 254, 81, 143, 109, 72, 211, 124,\n    123, 181, 45, 122, 159, 239, 88, 50, 62, 177, 191, 122, 64, 125, 179, 130,\n    210, 243, 242, 216, 27, 177, 34, 79, 73, 254, 81, 143, 109, 72, 211, 124,\n  ]),\n  'BIP0340/aux': Uint8Array.from([\n    241, 239, 78, 94, 192, 99, 202, 218, 109, 148, 202, 250, 157, 152, 126, 160,\n    105, 38, 88, 57, 236, 193, 31, 151, 45, 119, 165, 46, 216, 193, 204, 144,\n    241, 239, 78, 94, 192, 99, 202, 218, 109, 148, 202, 250, 157, 152, 126, 160,\n    105, 38, 88, 57, 236, 193, 31, 151, 45, 119, 165, 46, 216, 193, 204, 144,\n  ]),\n  'BIP0340/nonce': Uint8Array.from([\n    7, 73, 119, 52, 167, 155, 203, 53, 91, 155, 140, 125, 3, 79, 18, 28, 244,\n    52, 215, 62, 247, 45, 218, 25, 135, 0, 97, 251, 82, 191, 235, 47, 7, 73,\n    119, 52, 167, 155, 203, 53, 91, 155, 140, 125, 3, 79, 18, 28, 244, 52, 215,\n    62, 247, 45, 218, 25, 135, 0, 97, 251, 82, 191, 235, 47,\n  ]),\n  TapLeaf: Uint8Array.from([\n    174, 234, 143, 220, 66, 8, 152, 49, 5, 115, 75, 88, 8, 29, 30, 38, 56, 211,\n    95, 28, 181, 64, 8, 212, 211, 87, 202, 3, 190, 120, 233, 238, 174, 234, 143,\n    220, 66, 8, 152, 49, 5, 115, 75, 88, 8, 29, 30, 38, 56, 211, 95, 28, 181,\n    64, 8, 212, 211, 87, 202, 3, 190, 120, 233, 238,\n  ]),\n  TapBranch: Uint8Array.from([\n    25, 65, 161, 242, 229, 110, 185, 95, 162, 169, 241, 148, 190, 92, 1, 247,\n    33, 111, 51, 237, 130, 176, 145, 70, 52, 144, 208, 91, 245, 22, 160, 21, 25,\n    65, 161, 242, 229, 110, 185, 95, 162, 169, 241, 148, 190, 92, 1, 247, 33,\n    111, 51, 237, 130, 176, 145, 70, 52, 144, 208, 91, 245, 22, 160, 21,\n  ]),\n  TapSighash: Uint8Array.from([\n    244, 10, 72, 223, 75, 42, 112, 200, 180, 146, 75, 242, 101, 70, 97, 237, 61,\n    149, 253, 102, 163, 19, 235, 135, 35, 117, 151, 198, 40, 228, 160, 49, 244,\n    10, 72, 223, 75, 42, 112, 200, 180, 146, 75, 242, 101, 70, 97, 237, 61, 149,\n    253, 102, 163, 19, 235, 135, 35, 117, 151, 198, 40, 228, 160, 49,\n  ]),\n  TapTweak: Uint8Array.from([\n    232, 15, 225, 99, 156, 156, 160, 80, 227, 175, 27, 57, 193, 67, 198, 62, 66,\n    156, 188, 235, 21, 217, 64, 251, 181, 197, 161, 244, 175, 87, 197, 233, 232,\n    15, 225, 99, 156, 156, 160, 80, 227, 175, 27, 57, 193, 67, 198, 62, 66, 156,\n    188, 235, 21, 217, 64, 251, 181, 197, 161, 244, 175, 87, 197, 233,\n  ]),\n  'KeyAgg list': Uint8Array.from([\n    72, 28, 151, 28, 60, 11, 70, 215, 240, 178, 117, 174, 89, 141, 78, 44, 126,\n    215, 49, 156, 89, 74, 92, 110, 199, 158, 160, 212, 153, 2, 148, 240, 72, 28,\n    151, 28, 60, 11, 70, 215, 240, 178, 117, 174, 89, 141, 78, 44, 126, 215, 49,\n    156, 89, 74, 92, 110, 199, 158, 160, 212, 153, 2, 148, 240,\n  ]),\n  'KeyAgg coefficient': Uint8Array.from([\n    191, 201, 4, 3, 77, 28, 136, 232, 200, 14, 34, 229, 61, 36, 86, 109, 100,\n    130, 78, 214, 66, 114, 129, 192, 145, 0, 249, 77, 205, 82, 201, 129, 191,\n    201, 4, 3, 77, 28, 136, 232, 200, 14, 34, 229, 61, 36, 86, 109, 100, 130,\n    78, 214, 66, 114, 129, 192, 145, 0, 249, 77, 205, 82, 201, 129,\n  ]),\n};\nexport function taggedHash(prefix, data) {\n  return sha256(tools.concat([TAGGED_HASH_PREFIXES[prefix], data]));\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1780, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1786, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bitcoinjs-lib/src/esm/payments/p2pkh.js"],"sourcesContent":["import * as bcrypto from '../crypto.js';\nimport { bitcoin as BITCOIN_NETWORK } from '../networks.js';\nimport * as bscript from '../script.js';\nimport {\n  isPoint,\n  Hash160bitSchema,\n  NBufferSchemaFactory,\n  BufferSchema,\n} from '../types.js';\nimport * as lazy from './lazy.js';\nimport bs58check from 'bs58check';\nimport * as tools from 'uint8array-tools';\nimport * as v from 'valibot';\nconst OPS = bscript.OPS;\n// input: {signature} {pubkey}\n// output: OP_DUP OP_HASH160 {hash160(pubkey)} OP_EQUALVERIFY OP_CHECKSIG\n/**\n * Creates a Pay-to-Public-Key-Hash (P2PKH) payment object.\n *\n * @param a - The payment object containing the necessary data.\n * @param opts - Optional payment options.\n * @returns The P2PKH payment object.\n * @throws {TypeError} If the required data is not provided or if the data is invalid.\n */\nexport function p2pkh(a, opts) {\n  if (!a.address && !a.hash && !a.output && !a.pubkey && !a.input)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  v.parse(\n    v.partial(\n      v.object({\n        network: v.object({}),\n        address: v.string(),\n        hash: Hash160bitSchema,\n        output: NBufferSchemaFactory(25),\n        pubkey: v.custom(isPoint),\n        signature: v.custom(bscript.isCanonicalScriptSignature),\n        input: BufferSchema,\n      }),\n    ),\n    a,\n  );\n  const _address = lazy.value(() => {\n    const payload = bs58check.decode(a.address);\n    const version = tools.readUInt8(payload, 0);\n    const hash = payload.slice(1);\n    return { version, hash };\n  });\n  const _chunks = lazy.value(() => {\n    return bscript.decompile(a.input);\n  });\n  const network = a.network || BITCOIN_NETWORK;\n  const o = { name: 'p2pkh', network };\n  lazy.prop(o, 'address', () => {\n    if (!o.hash) return;\n    const payload = new Uint8Array(21);\n    tools.writeUInt8(payload, 0, network.pubKeyHash);\n    payload.set(o.hash, 1);\n    return bs58check.encode(payload);\n  });\n  lazy.prop(o, 'hash', () => {\n    if (a.output) return a.output.slice(3, 23);\n    if (a.address) return _address().hash;\n    if (a.pubkey || o.pubkey) return bcrypto.hash160(a.pubkey || o.pubkey);\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.hash) return;\n    return bscript.compile([\n      OPS.OP_DUP,\n      OPS.OP_HASH160,\n      o.hash,\n      OPS.OP_EQUALVERIFY,\n      OPS.OP_CHECKSIG,\n    ]);\n  });\n  lazy.prop(o, 'pubkey', () => {\n    if (!a.input) return;\n    return _chunks()[1];\n  });\n  lazy.prop(o, 'signature', () => {\n    if (!a.input) return;\n    return _chunks()[0];\n  });\n  lazy.prop(o, 'input', () => {\n    if (!a.pubkey) return;\n    if (!a.signature) return;\n    return bscript.compile([a.signature, a.pubkey]);\n  });\n  lazy.prop(o, 'witness', () => {\n    if (!o.input) return;\n    return [];\n  });\n  // extended validation\n  if (opts.validate) {\n    let hash = Uint8Array.from([]);\n    if (a.address) {\n      if (_address().version !== network.pubKeyHash)\n        throw new TypeError('Invalid version or Network mismatch');\n      if (_address().hash.length !== 20) throw new TypeError('Invalid address');\n      hash = _address().hash;\n    }\n    if (a.hash) {\n      if (hash.length > 0 && tools.compare(hash, a.hash) !== 0)\n        throw new TypeError('Hash mismatch');\n      else hash = a.hash;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 25 ||\n        a.output[0] !== OPS.OP_DUP ||\n        a.output[1] !== OPS.OP_HASH160 ||\n        a.output[2] !== 0x14 ||\n        a.output[23] !== OPS.OP_EQUALVERIFY ||\n        a.output[24] !== OPS.OP_CHECKSIG\n      )\n        throw new TypeError('Output is invalid');\n      const hash2 = a.output.slice(3, 23);\n      if (hash.length > 0 && tools.compare(hash, hash2) !== 0)\n        throw new TypeError('Hash mismatch');\n      else hash = hash2;\n    }\n    if (a.pubkey) {\n      const pkh = bcrypto.hash160(a.pubkey);\n      if (hash.length > 0 && tools.compare(hash, pkh) !== 0)\n        throw new TypeError('Hash mismatch');\n      else hash = pkh;\n    }\n    if (a.input) {\n      const chunks = _chunks();\n      if (chunks.length !== 2) throw new TypeError('Input is invalid');\n      if (!bscript.isCanonicalScriptSignature(chunks[0]))\n        throw new TypeError('Input has invalid signature');\n      if (!isPoint(chunks[1])) throw new TypeError('Input has invalid pubkey');\n      if (a.signature && tools.compare(a.signature, chunks[0]) !== 0)\n        throw new TypeError('Signature mismatch');\n      if (a.pubkey && tools.compare(a.pubkey, chunks[1]) !== 0)\n        throw new TypeError('Pubkey mismatch');\n      const pkh = bcrypto.hash160(chunks[1]);\n      if (hash.length > 0 && tools.compare(hash, pkh) !== 0)\n        throw new TypeError('Hash mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1916, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1922, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bitcoinjs-lib/src/esm/payments/p2sh.js"],"sourcesContent":["import * as bcrypto from '../crypto.js';\nimport { bitcoin as BITCOIN_NETWORK } from '../networks.js';\nimport * as bscript from '../script.js';\nimport { BufferSchema, NBufferSchemaFactory, stacksEqual } from '../types.js';\nimport * as lazy from './lazy.js';\nimport bs58check from 'bs58check';\nimport * as tools from 'uint8array-tools';\nimport * as v from 'valibot';\nconst OPS = bscript.OPS;\n// input: [redeemScriptSig ...] {redeemScript}\n// witness: <?>\n// output: OP_HASH160 {hash160(redeemScript)} OP_EQUAL\n/**\n * Creates a Pay-to-Script-Hash (P2SH) payment object.\n *\n * @param a - The payment object containing the necessary data.\n * @param opts - Optional payment options.\n * @returns The P2SH payment object.\n * @throws {TypeError} If the required data is not provided or if the data is invalid.\n */\nexport function p2sh(a, opts) {\n  if (!a.address && !a.hash && !a.output && !a.redeem && !a.input)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  v.parse(\n    v.partial(\n      v.object({\n        network: v.object({}),\n        address: v.string(),\n        hash: NBufferSchemaFactory(20),\n        output: NBufferSchemaFactory(23),\n        redeem: v.partial(\n          v.object({\n            network: v.object({}),\n            output: BufferSchema,\n            input: BufferSchema,\n            witness: v.array(BufferSchema),\n          }),\n        ),\n        input: BufferSchema,\n        witness: v.array(BufferSchema),\n      }),\n    ),\n    a,\n  );\n  let network = a.network;\n  if (!network) {\n    network = (a.redeem && a.redeem.network) || BITCOIN_NETWORK;\n  }\n  const o = { network };\n  const _address = lazy.value(() => {\n    const payload = bs58check.decode(a.address);\n    const version = tools.readUInt8(payload, 0);\n    const hash = payload.slice(1);\n    return { version, hash };\n  });\n  const _chunks = lazy.value(() => {\n    return bscript.decompile(a.input);\n  });\n  const _redeem = lazy.value(() => {\n    const chunks = _chunks();\n    const lastChunk = chunks[chunks.length - 1];\n    return {\n      network,\n      output: lastChunk === OPS.OP_FALSE ? Uint8Array.from([]) : lastChunk,\n      input: bscript.compile(chunks.slice(0, -1)),\n      witness: a.witness || [],\n    };\n  });\n  // output dependents\n  lazy.prop(o, 'address', () => {\n    if (!o.hash) return;\n    const payload = new Uint8Array(21);\n    tools.writeUInt8(payload, 0, o.network.scriptHash);\n    payload.set(o.hash, 1);\n    return bs58check.encode(payload);\n  });\n  lazy.prop(o, 'hash', () => {\n    // in order of least effort\n    if (a.output) return a.output.slice(2, 22);\n    if (a.address) return _address().hash;\n    if (o.redeem && o.redeem.output) return bcrypto.hash160(o.redeem.output);\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.hash) return;\n    return bscript.compile([OPS.OP_HASH160, o.hash, OPS.OP_EQUAL]);\n  });\n  // input dependents\n  lazy.prop(o, 'redeem', () => {\n    if (!a.input) return;\n    return _redeem();\n  });\n  lazy.prop(o, 'input', () => {\n    if (!a.redeem || !a.redeem.input || !a.redeem.output) return;\n    return bscript.compile(\n      [].concat(bscript.decompile(a.redeem.input), a.redeem.output),\n    );\n  });\n  lazy.prop(o, 'witness', () => {\n    if (o.redeem && o.redeem.witness) return o.redeem.witness;\n    if (o.input) return [];\n  });\n  lazy.prop(o, 'name', () => {\n    const nameParts = ['p2sh'];\n    if (o.redeem !== undefined && o.redeem.name !== undefined)\n      nameParts.push(o.redeem.name);\n    return nameParts.join('-');\n  });\n  if (opts.validate) {\n    let hash = Uint8Array.from([]);\n    if (a.address) {\n      if (_address().version !== network.scriptHash)\n        throw new TypeError('Invalid version or Network mismatch');\n      if (_address().hash.length !== 20) throw new TypeError('Invalid address');\n      hash = _address().hash;\n    }\n    if (a.hash) {\n      if (hash.length > 0 && tools.compare(hash, a.hash) !== 0)\n        throw new TypeError('Hash mismatch');\n      else hash = a.hash;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 23 ||\n        a.output[0] !== OPS.OP_HASH160 ||\n        a.output[1] !== 0x14 ||\n        a.output[22] !== OPS.OP_EQUAL\n      )\n        throw new TypeError('Output is invalid');\n      const hash2 = a.output.slice(2, 22);\n      if (hash.length > 0 && tools.compare(hash, hash2) !== 0)\n        throw new TypeError('Hash mismatch');\n      else hash = hash2;\n    }\n    // inlined to prevent 'no-inner-declarations' failing\n    const checkRedeem = redeem => {\n      // is the redeem output empty/invalid?\n      if (redeem.output) {\n        const decompile = bscript.decompile(redeem.output);\n        if (!decompile || decompile.length < 1)\n          throw new TypeError('Redeem.output too short');\n        if (redeem.output.byteLength > 520)\n          throw new TypeError(\n            'Redeem.output unspendable if larger than 520 bytes',\n          );\n        if (bscript.countNonPushOnlyOPs(decompile) > 201)\n          throw new TypeError(\n            'Redeem.output unspendable with more than 201 non-push ops',\n          );\n        // match hash against other sources\n        const hash2 = bcrypto.hash160(redeem.output);\n        if (hash.length > 0 && tools.compare(hash, hash2) !== 0)\n          throw new TypeError('Hash mismatch');\n        else hash = hash2;\n      }\n      if (redeem.input) {\n        const hasInput = redeem.input.length > 0;\n        const hasWitness = redeem.witness && redeem.witness.length > 0;\n        if (!hasInput && !hasWitness) throw new TypeError('Empty input');\n        if (hasInput && hasWitness)\n          throw new TypeError('Input and witness provided');\n        if (hasInput) {\n          const richunks = bscript.decompile(redeem.input);\n          if (!bscript.isPushOnly(richunks))\n            throw new TypeError('Non push-only scriptSig');\n        }\n      }\n    };\n    if (a.input) {\n      const chunks = _chunks();\n      if (!chunks || chunks.length < 1) throw new TypeError('Input too short');\n      if (!(_redeem().output instanceof Uint8Array))\n        throw new TypeError('Input is invalid');\n      checkRedeem(_redeem());\n    }\n    if (a.redeem) {\n      if (a.redeem.network && a.redeem.network !== network)\n        throw new TypeError('Network mismatch');\n      if (a.input) {\n        const redeem = _redeem();\n        if (\n          a.redeem.output &&\n          tools.compare(a.redeem.output, redeem.output) !== 0\n        )\n          throw new TypeError('Redeem.output mismatch');\n        if (a.redeem.input && tools.compare(a.redeem.input, redeem.input) !== 0)\n          throw new TypeError('Redeem.input mismatch');\n      }\n      checkRedeem(a.redeem);\n    }\n    if (a.witness) {\n      if (\n        a.redeem &&\n        a.redeem.witness &&\n        !stacksEqual(a.redeem.witness, a.witness)\n      )\n        throw new TypeError('Witness and redeem.witness mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\n"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAKA;;;;;;;;;AACA,MAAM,MAAM,yJAAQ,GAAG;AAYhB,SAAS,KAAK,CAAC,EAAE,IAAI;IAC1B,IAAI,CAAC,EAAE,OAAO,IAAI,CAAC,EAAE,IAAI,IAAI,CAAC,EAAE,MAAM,IAAI,CAAC,EAAE,MAAM,IAAI,CAAC,EAAE,KAAK,EAC7D,MAAM,IAAI,UAAU;IACtB,OAAO,OAAO,MAAM,CAAC;QAAE,UAAU;IAAK,GAAG,QAAQ,CAAC;IAClD,yIAAE,KAAK,CACL,yIAAE,OAAO,CACP,yIAAE,MAAM,CAAC;QACP,SAAS,yIAAE,MAAM,CAAC,CAAC;QACnB,SAAS,yIAAE,MAAM;QACjB,MAAM,CAAA,GAAA,uJAAA,CAAA,uBAAoB,AAAD,EAAE;QAC3B,QAAQ,CAAA,GAAA,uJAAA,CAAA,uBAAoB,AAAD,EAAE;QAC7B,QAAQ,yIAAE,OAAO,CACf,yIAAE,MAAM,CAAC;YACP,SAAS,yIAAE,MAAM,CAAC,CAAC;YACnB,QAAQ,uJAAA,CAAA,eAAY;YACpB,OAAO,uJAAA,CAAA,eAAY;YACnB,SAAS,yIAAE,KAAK,CAAC,uJAAA,CAAA,eAAY;QAC/B;QAEF,OAAO,uJAAA,CAAA,eAAY;QACnB,SAAS,yIAAE,KAAK,CAAC,uJAAA,CAAA,eAAY;IAC/B,KAEF;IAEF,IAAI,UAAU,EAAE,OAAO;IACvB,IAAI,CAAC,SAAS;QACZ,UAAU,AAAC,EAAE,MAAM,IAAI,EAAE,MAAM,CAAC,OAAO,IAAK,0JAAA,CAAA,UAAe;IAC7D;IACA,MAAM,IAAI;QAAE;IAAQ;IACpB,MAAM,WAAW,mKAAK,KAAK,CAAC;QAC1B,MAAM,UAAU,gJAAA,CAAA,UAAS,CAAC,MAAM,CAAC,EAAE,OAAO;QAC1C,MAAM,UAAU,2JAAM,SAAS,CAAC,SAAS;QACzC,MAAM,OAAO,QAAQ,KAAK,CAAC;QAC3B,OAAO;YAAE;YAAS;QAAK;IACzB;IACA,MAAM,UAAU,mKAAK,KAAK,CAAC;QACzB,OAAO,yJAAQ,SAAS,CAAC,EAAE,KAAK;IAClC;IACA,MAAM,UAAU,mKAAK,KAAK,CAAC;QACzB,MAAM,SAAS;QACf,MAAM,YAAY,MAAM,CAAC,OAAO,MAAM,GAAG,EAAE;QAC3C,OAAO;YACL;YACA,QAAQ,cAAc,IAAI,QAAQ,GAAG,WAAW,IAAI,CAAC,EAAE,IAAI;YAC3D,OAAO,yJAAQ,OAAO,CAAC,OAAO,KAAK,CAAC,GAAG,CAAC;YACxC,SAAS,EAAE,OAAO,IAAI,EAAE;QAC1B;IACF;IACA,oBAAoB;IACpB,mKAAK,IAAI,CAAC,GAAG,WAAW;QACtB,IAAI,CAAC,EAAE,IAAI,EAAE;QACb,MAAM,UAAU,IAAI,WAAW;QAC/B,2JAAM,UAAU,CAAC,SAAS,GAAG,EAAE,OAAO,CAAC,UAAU;QACjD,QAAQ,GAAG,CAAC,EAAE,IAAI,EAAE;QACpB,OAAO,gJAAA,CAAA,UAAS,CAAC,MAAM,CAAC;IAC1B;IACA,mKAAK,IAAI,CAAC,GAAG,QAAQ;QACnB,2BAA2B;QAC3B,IAAI,EAAE,MAAM,EAAE,OAAO,EAAE,MAAM,CAAC,KAAK,CAAC,GAAG;QACvC,IAAI,EAAE,OAAO,EAAE,OAAO,WAAW,IAAI;QACrC,IAAI,EAAE,MAAM,IAAI,EAAE,MAAM,CAAC,MAAM,EAAE,OAAO,yJAAQ,OAAO,CAAC,EAAE,MAAM,CAAC,MAAM;IACzE;IACA,mKAAK,IAAI,CAAC,GAAG,UAAU;QACrB,IAAI,CAAC,EAAE,IAAI,EAAE;QACb,OAAO,yJAAQ,OAAO,CAAC;YAAC,IAAI,UAAU;YAAE,EAAE,IAAI;YAAE,IAAI,QAAQ;SAAC;IAC/D;IACA,mBAAmB;IACnB,mKAAK,IAAI,CAAC,GAAG,UAAU;QACrB,IAAI,CAAC,EAAE,KAAK,EAAE;QACd,OAAO;IACT;IACA,mKAAK,IAAI,CAAC,GAAG,SAAS;QACpB,IAAI,CAAC,EAAE,MAAM,IAAI,CAAC,EAAE,MAAM,CAAC,KAAK,IAAI,CAAC,EAAE,MAAM,CAAC,MAAM,EAAE;QACtD,OAAO,yJAAQ,OAAO,CACpB,EAAE,CAAC,MAAM,CAAC,yJAAQ,SAAS,CAAC,EAAE,MAAM,CAAC,KAAK,GAAG,EAAE,MAAM,CAAC,MAAM;IAEhE;IACA,mKAAK,IAAI,CAAC,GAAG,WAAW;QACtB,IAAI,EAAE,MAAM,IAAI,EAAE,MAAM,CAAC,OAAO,EAAE,OAAO,EAAE,MAAM,CAAC,OAAO;QACzD,IAAI,EAAE,KAAK,EAAE,OAAO,EAAE;IACxB;IACA,mKAAK,IAAI,CAAC,GAAG,QAAQ;QACnB,MAAM,YAAY;YAAC;SAAO;QAC1B,IAAI,EAAE,MAAM,KAAK,aAAa,EAAE,MAAM,CAAC,IAAI,KAAK,WAC9C,UAAU,IAAI,CAAC,EAAE,MAAM,CAAC,IAAI;QAC9B,OAAO,UAAU,IAAI,CAAC;IACxB;IACA,IAAI,KAAK,QAAQ,EAAE;QACjB,IAAI,OAAO,WAAW,IAAI,CAAC,EAAE;QAC7B,IAAI,EAAE,OAAO,EAAE;YACb,IAAI,WAAW,OAAO,KAAK,QAAQ,UAAU,EAC3C,MAAM,IAAI,UAAU;YACtB,IAAI,WAAW,IAAI,CAAC,MAAM,KAAK,IAAI,MAAM,IAAI,UAAU;YACvD,OAAO,WAAW,IAAI;QACxB;QACA,IAAI,EAAE,IAAI,EAAE;YACV,IAAI,KAAK,MAAM,GAAG,KAAK,2JAAM,OAAO,CAAC,MAAM,EAAE,IAAI,MAAM,GACrD,MAAM,IAAI,UAAU;iBACjB,OAAO,EAAE,IAAI;QACpB;QACA,IAAI,EAAE,MAAM,EAAE;YACZ,IACE,EAAE,MAAM,CAAC,MAAM,KAAK,MACpB,EAAE,MAAM,CAAC,EAAE,KAAK,IAAI,UAAU,IAC9B,EAAE,MAAM,CAAC,EAAE,KAAK,QAChB,EAAE,MAAM,CAAC,GAAG,KAAK,IAAI,QAAQ,EAE7B,MAAM,IAAI,UAAU;YACtB,MAAM,QAAQ,EAAE,MAAM,CAAC,KAAK,CAAC,GAAG;YAChC,IAAI,KAAK,MAAM,GAAG,KAAK,2JAAM,OAAO,CAAC,MAAM,WAAW,GACpD,MAAM,IAAI,UAAU;iBACjB,OAAO;QACd;QACA,qDAAqD;QACrD,MAAM,cAAc,CAAA;YAClB,sCAAsC;YACtC,IAAI,OAAO,MAAM,EAAE;gBACjB,MAAM,YAAY,yJAAQ,SAAS,CAAC,OAAO,MAAM;gBACjD,IAAI,CAAC,aAAa,UAAU,MAAM,GAAG,GACnC,MAAM,IAAI,UAAU;gBACtB,IAAI,OAAO,MAAM,CAAC,UAAU,GAAG,KAC7B,MAAM,IAAI,UACR;gBAEJ,IAAI,yJAAQ,mBAAmB,CAAC,aAAa,KAC3C,MAAM,IAAI,UACR;gBAEJ,mCAAmC;gBACnC,MAAM,QAAQ,yJAAQ,OAAO,CAAC,OAAO,MAAM;gBAC3C,IAAI,KAAK,MAAM,GAAG,KAAK,2JAAM,OAAO,CAAC,MAAM,WAAW,GACpD,MAAM,IAAI,UAAU;qBACjB,OAAO;YACd;YACA,IAAI,OAAO,KAAK,EAAE;gBAChB,MAAM,WAAW,OAAO,KAAK,CAAC,MAAM,GAAG;gBACvC,MAAM,aAAa,OAAO,OAAO,IAAI,OAAO,OAAO,CAAC,MAAM,GAAG;gBAC7D,IAAI,CAAC,YAAY,CAAC,YAAY,MAAM,IAAI,UAAU;gBAClD,IAAI,YAAY,YACd,MAAM,IAAI,UAAU;gBACtB,IAAI,UAAU;oBACZ,MAAM,WAAW,yJAAQ,SAAS,CAAC,OAAO,KAAK;oBAC/C,IAAI,CAAC,yJAAQ,UAAU,CAAC,WACtB,MAAM,IAAI,UAAU;gBACxB;YACF;QACF;QACA,IAAI,EAAE,KAAK,EAAE;YACX,MAAM,SAAS;YACf,IAAI,CAAC,UAAU,OAAO,MAAM,GAAG,GAAG,MAAM,IAAI,UAAU;YACtD,IAAI,CAAC,CAAC,UAAU,MAAM,YAAY,UAAU,GAC1C,MAAM,IAAI,UAAU;YACtB,YAAY;QACd;QACA,IAAI,EAAE,MAAM,EAAE;YACZ,IAAI,EAAE,MAAM,CAAC,OAAO,IAAI,EAAE,MAAM,CAAC,OAAO,KAAK,SAC3C,MAAM,IAAI,UAAU;YACtB,IAAI,EAAE,KAAK,EAAE;gBACX,MAAM,SAAS;gBACf,IACE,EAAE,MAAM,CAAC,MAAM,IACf,2JAAM,OAAO,CAAC,EAAE,MAAM,CAAC,MAAM,EAAE,OAAO,MAAM,MAAM,GAElD,MAAM,IAAI,UAAU;gBACtB,IAAI,EAAE,MAAM,CAAC,KAAK,IAAI,2JAAM,OAAO,CAAC,EAAE,MAAM,CAAC,KAAK,EAAE,OAAO,KAAK,MAAM,GACpE,MAAM,IAAI,UAAU;YACxB;YACA,YAAY,EAAE,MAAM;QACtB;QACA,IAAI,EAAE,OAAO,EAAE;YACb,IACE,EAAE,MAAM,IACR,EAAE,MAAM,CAAC,OAAO,IAChB,CAAC,CAAA,GAAA,uJAAA,CAAA,cAAW,AAAD,EAAE,EAAE,MAAM,CAAC,OAAO,EAAE,EAAE,OAAO,GAExC,MAAM,IAAI,UAAU;QACxB;IACF;IACA,OAAO,OAAO,MAAM,CAAC,GAAG;AAC1B","ignoreList":[0]}},
    {"offset": {"line": 2095, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2101, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bitcoinjs-lib/src/esm/payments/p2wpkh.js"],"sourcesContent":["import * as bcrypto from '../crypto.js';\nimport { bitcoin as BITCOIN_NETWORK } from '../networks.js';\nimport * as bscript from '../script.js';\nimport { BufferSchema, isPoint, NBufferSchemaFactory } from '../types.js';\nimport * as lazy from './lazy.js';\nimport { bech32 } from 'bech32';\nimport * as tools from 'uint8array-tools';\nimport * as v from 'valibot';\nconst OPS = bscript.OPS;\nconst EMPTY_BUFFER = new Uint8Array(0);\n// witness: {signature} {pubKey}\n// input: <>\n// output: OP_0 {pubKeyHash}\n/**\n * Creates a pay-to-witness-public-key-hash (p2wpkh) payment object.\n *\n * @param a - The payment object containing the necessary data.\n * @param opts - Optional payment options.\n * @returns The p2wpkh payment object.\n * @throws {TypeError} If the required data is missing or invalid.\n */\nexport function p2wpkh(a, opts) {\n  if (!a.address && !a.hash && !a.output && !a.pubkey && !a.witness)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  v.parse(\n    v.partial(\n      v.object({\n        address: v.string(),\n        hash: NBufferSchemaFactory(20),\n        input: NBufferSchemaFactory(0),\n        network: v.object({}),\n        output: NBufferSchemaFactory(22),\n        pubkey: v.custom(isPoint, 'Not a valid pubkey'),\n        signature: v.custom(bscript.isCanonicalScriptSignature),\n        witness: v.array(BufferSchema),\n      }),\n    ),\n    a,\n  );\n  const _address = lazy.value(() => {\n    const result = bech32.decode(a.address);\n    const version = result.words.shift();\n    const data = bech32.fromWords(result.words);\n    return {\n      version,\n      prefix: result.prefix,\n      data: Uint8Array.from(data),\n    };\n  });\n  const network = a.network || BITCOIN_NETWORK;\n  const o = { name: 'p2wpkh', network };\n  lazy.prop(o, 'address', () => {\n    if (!o.hash) return;\n    const words = bech32.toWords(o.hash);\n    words.unshift(0x00);\n    return bech32.encode(network.bech32, words);\n  });\n  lazy.prop(o, 'hash', () => {\n    if (a.output) return a.output.slice(2, 22);\n    if (a.address) return _address().data;\n    if (a.pubkey || o.pubkey) return bcrypto.hash160(a.pubkey || o.pubkey);\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.hash) return;\n    return bscript.compile([OPS.OP_0, o.hash]);\n  });\n  lazy.prop(o, 'pubkey', () => {\n    if (a.pubkey) return a.pubkey;\n    if (!a.witness) return;\n    return a.witness[1];\n  });\n  lazy.prop(o, 'signature', () => {\n    if (!a.witness) return;\n    return a.witness[0];\n  });\n  lazy.prop(o, 'input', () => {\n    if (!o.witness) return;\n    return EMPTY_BUFFER;\n  });\n  lazy.prop(o, 'witness', () => {\n    if (!a.pubkey) return;\n    if (!a.signature) return;\n    return [a.signature, a.pubkey];\n  });\n  // extended validation\n  if (opts.validate) {\n    let hash = Uint8Array.from([]);\n    if (a.address) {\n      if (network && network.bech32 !== _address().prefix)\n        throw new TypeError('Invalid prefix or Network mismatch');\n      if (_address().version !== 0x00)\n        throw new TypeError('Invalid address version');\n      if (_address().data.length !== 20)\n        throw new TypeError('Invalid address data');\n      hash = _address().data;\n    }\n    if (a.hash) {\n      if (hash.length > 0 && tools.compare(hash, a.hash) !== 0)\n        throw new TypeError('Hash mismatch');\n      else hash = a.hash;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 22 ||\n        a.output[0] !== OPS.OP_0 ||\n        a.output[1] !== 0x14\n      )\n        throw new TypeError('Output is invalid');\n      if (hash.length > 0 && tools.compare(hash, a.output.slice(2)) !== 0)\n        throw new TypeError('Hash mismatch');\n      else hash = a.output.slice(2);\n    }\n    if (a.pubkey) {\n      const pkh = bcrypto.hash160(a.pubkey);\n      if (hash.length > 0 && tools.compare(hash, pkh) !== 0)\n        throw new TypeError('Hash mismatch');\n      else hash = pkh;\n      if (!isPoint(a.pubkey) || a.pubkey.length !== 33)\n        throw new TypeError('Invalid pubkey for p2wpkh');\n    }\n    if (a.witness) {\n      if (a.witness.length !== 2) throw new TypeError('Witness is invalid');\n      if (!bscript.isCanonicalScriptSignature(a.witness[0]))\n        throw new TypeError('Witness has invalid signature');\n      if (!isPoint(a.witness[1]) || a.witness[1].length !== 33)\n        throw new TypeError('Witness has invalid pubkey');\n      if (a.signature && tools.compare(a.signature, a.witness[0]) !== 0)\n        throw new TypeError('Signature mismatch');\n      // if (a.pubkey && !a.pubkey.equals(a.witness[1]))\n      if (a.pubkey && tools.compare(a.pubkey, a.witness[1]) !== 0)\n        throw new TypeError('Pubkey mismatch');\n      const pkh = bcrypto.hash160(a.witness[1]);\n      if (hash.length > 0 && tools.compare(hash, pkh) !== 0)\n        throw new TypeError('Hash mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2229, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2235, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bitcoinjs-lib/src/esm/payments/p2wsh.js"],"sourcesContent":["import { sha256 } from '@noble/hashes/sha256';\nimport { bitcoin as BITCOIN_NETWORK } from '../networks.js';\nimport * as bscript from '../script.js';\nimport {\n  Buffer256bitSchema,\n  BufferSchema,\n  isPoint,\n  NBufferSchemaFactory,\n  stacksEqual,\n  NullablePartial,\n} from '../types.js';\nimport * as lazy from './lazy.js';\nimport { bech32 } from 'bech32';\nimport * as tools from 'uint8array-tools';\nimport * as v from 'valibot';\nconst OPS = bscript.OPS;\nconst EMPTY_BUFFER = new Uint8Array(0);\nfunction chunkHasUncompressedPubkey(chunk) {\n  if (\n    chunk instanceof Uint8Array &&\n    chunk.length === 65 &&\n    chunk[0] === 0x04 &&\n    isPoint(chunk)\n  ) {\n    return true;\n  } else {\n    return false;\n  }\n}\n// input: <>\n// witness: [redeemScriptSig ...] {redeemScript}\n// output: OP_0 {sha256(redeemScript)}\n/**\n * Creates a Pay-to-Witness-Script-Hash (P2WSH) payment object.\n *\n * @param a - The payment object containing the necessary data.\n * @param opts - Optional payment options.\n * @returns The P2WSH payment object.\n * @throws {TypeError} If the required data is missing or invalid.\n */\nexport function p2wsh(a, opts) {\n  if (!a.address && !a.hash && !a.output && !a.redeem && !a.witness)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  v.parse(\n    NullablePartial({\n      network: v.object({}),\n      address: v.string(),\n      hash: Buffer256bitSchema,\n      output: NBufferSchemaFactory(34),\n      redeem: NullablePartial({\n        input: BufferSchema,\n        network: v.object({}),\n        output: BufferSchema,\n        witness: v.array(BufferSchema),\n      }),\n      input: NBufferSchemaFactory(0),\n      witness: v.array(BufferSchema),\n    }),\n    a,\n  );\n  const _address = lazy.value(() => {\n    const result = bech32.decode(a.address);\n    const version = result.words.shift();\n    const data = bech32.fromWords(result.words);\n    return {\n      version,\n      prefix: result.prefix,\n      data: Uint8Array.from(data),\n    };\n  });\n  const _rchunks = lazy.value(() => {\n    return bscript.decompile(a.redeem.input);\n  });\n  let network = a.network;\n  if (!network) {\n    network = (a.redeem && a.redeem.network) || BITCOIN_NETWORK;\n  }\n  const o = { network };\n  lazy.prop(o, 'address', () => {\n    if (!o.hash) return;\n    const words = bech32.toWords(o.hash);\n    words.unshift(0x00);\n    return bech32.encode(network.bech32, words);\n  });\n  lazy.prop(o, 'hash', () => {\n    if (a.output) return a.output.slice(2);\n    if (a.address) return _address().data;\n    if (o.redeem && o.redeem.output) return sha256(o.redeem.output);\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.hash) return;\n    return bscript.compile([OPS.OP_0, o.hash]);\n  });\n  lazy.prop(o, 'redeem', () => {\n    if (!a.witness) return;\n    return {\n      output: a.witness[a.witness.length - 1],\n      input: EMPTY_BUFFER,\n      witness: a.witness.slice(0, -1),\n    };\n  });\n  lazy.prop(o, 'input', () => {\n    if (!o.witness) return;\n    return EMPTY_BUFFER;\n  });\n  lazy.prop(o, 'witness', () => {\n    // transform redeem input to witness stack?\n    if (\n      a.redeem &&\n      a.redeem.input &&\n      a.redeem.input.length > 0 &&\n      a.redeem.output &&\n      a.redeem.output.length > 0\n    ) {\n      const stack = bscript.toStack(_rchunks());\n      // assign, and blank the existing input\n      o.redeem = Object.assign({ witness: stack }, a.redeem);\n      o.redeem.input = EMPTY_BUFFER;\n      return [].concat(stack, a.redeem.output);\n    }\n    if (!a.redeem) return;\n    if (!a.redeem.output) return;\n    if (!a.redeem.witness) return;\n    return [].concat(a.redeem.witness, a.redeem.output);\n  });\n  lazy.prop(o, 'name', () => {\n    const nameParts = ['p2wsh'];\n    if (o.redeem !== undefined && o.redeem.name !== undefined)\n      nameParts.push(o.redeem.name);\n    return nameParts.join('-');\n  });\n  // extended validation\n  if (opts.validate) {\n    let hash = Uint8Array.from([]);\n    if (a.address) {\n      if (_address().prefix !== network.bech32)\n        throw new TypeError('Invalid prefix or Network mismatch');\n      if (_address().version !== 0x00)\n        throw new TypeError('Invalid address version');\n      if (_address().data.length !== 32)\n        throw new TypeError('Invalid address data');\n      hash = _address().data;\n    }\n    if (a.hash) {\n      if (hash.length > 0 && tools.compare(hash, a.hash) !== 0)\n        throw new TypeError('Hash mismatch');\n      else hash = a.hash;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 34 ||\n        a.output[0] !== OPS.OP_0 ||\n        a.output[1] !== 0x20\n      )\n        throw new TypeError('Output is invalid');\n      const hash2 = a.output.slice(2);\n      if (hash.length > 0 && tools.compare(hash, hash2) !== 0)\n        throw new TypeError('Hash mismatch');\n      else hash = hash2;\n    }\n    if (a.redeem) {\n      if (a.redeem.network && a.redeem.network !== network)\n        throw new TypeError('Network mismatch');\n      // is there two redeem sources?\n      if (\n        a.redeem.input &&\n        a.redeem.input.length > 0 &&\n        a.redeem.witness &&\n        a.redeem.witness.length > 0\n      )\n        throw new TypeError('Ambiguous witness source');\n      // is the redeem output non-empty/valid?\n      if (a.redeem.output) {\n        const decompile = bscript.decompile(a.redeem.output);\n        if (!decompile || decompile.length < 1)\n          throw new TypeError('Redeem.output is invalid');\n        if (a.redeem.output.byteLength > 3600)\n          throw new TypeError(\n            'Redeem.output unspendable if larger than 3600 bytes',\n          );\n        if (bscript.countNonPushOnlyOPs(decompile) > 201)\n          throw new TypeError(\n            'Redeem.output unspendable with more than 201 non-push ops',\n          );\n        // match hash against other sources\n        const hash2 = sha256(a.redeem.output);\n        if (hash.length > 0 && tools.compare(hash, hash2) !== 0)\n          throw new TypeError('Hash mismatch');\n        else hash = hash2;\n      }\n      if (a.redeem.input && !bscript.isPushOnly(_rchunks()))\n        throw new TypeError('Non push-only scriptSig');\n      if (\n        a.witness &&\n        a.redeem.witness &&\n        !stacksEqual(a.witness, a.redeem.witness)\n      )\n        throw new TypeError('Witness and redeem.witness mismatch');\n      if (\n        (a.redeem.input && _rchunks().some(chunkHasUncompressedPubkey)) ||\n        (a.redeem.output &&\n          (bscript.decompile(a.redeem.output) || []).some(\n            chunkHasUncompressedPubkey,\n          ))\n      ) {\n        throw new TypeError(\n          'redeem.input or redeem.output contains uncompressed pubkey',\n        );\n      }\n    }\n    if (a.witness && a.witness.length > 0) {\n      const wScript = a.witness[a.witness.length - 1];\n      if (\n        a.redeem &&\n        a.redeem.output &&\n        tools.compare(a.redeem.output, wScript) !== 0\n      )\n        throw new TypeError('Witness and redeem.output mismatch');\n      if (\n        a.witness.some(chunkHasUncompressedPubkey) ||\n        (bscript.decompile(wScript) || []).some(chunkHasUncompressedPubkey)\n      )\n        throw new TypeError('Witness contains uncompressed pubkey');\n    }\n  }\n  return Object.assign(o, a);\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2404, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2410, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bitcoinjs-lib/src/esm/ecc_lib.js"],"sourcesContent":["import * as tools from 'uint8array-tools';\nconst _ECCLIB_CACHE = {};\n/**\n * Initializes the ECC library with the provided instance.\n * If `eccLib` is `undefined`, the library will be cleared.\n * If `eccLib` is a new instance, it will be verified before setting it as the active library.\n *\n * @param eccLib The instance of the ECC library to initialize.\n */\nexport function initEccLib(eccLib) {\n  if (!eccLib) {\n    // allow clearing the library\n    _ECCLIB_CACHE.eccLib = eccLib;\n  } else if (eccLib !== _ECCLIB_CACHE.eccLib) {\n    // new instance, verify it\n    verifyEcc(eccLib);\n    _ECCLIB_CACHE.eccLib = eccLib;\n  }\n}\n/**\n * Retrieves the ECC Library instance.\n * Throws an error if the ECC Library is not provided.\n * You must call initEccLib() with a valid TinySecp256k1Interface instance before calling this function.\n * @returns The ECC Library instance.\n * @throws Error if the ECC Library is not provided.\n */\nexport function getEccLib() {\n  if (!_ECCLIB_CACHE.eccLib)\n    throw new Error(\n      'No ECC Library provided. You must call initEccLib() with a valid TinySecp256k1Interface instance',\n    );\n  return _ECCLIB_CACHE.eccLib;\n}\nconst h = hex => tools.fromHex(hex);\n/**\n * Verifies the ECC functionality.\n *\n * @param ecc - The TinySecp256k1Interface object.\n */\nfunction verifyEcc(ecc) {\n  assert(typeof ecc.isXOnlyPoint === 'function');\n  assert(\n    ecc.isXOnlyPoint(\n      h('79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),\n    ),\n  );\n  assert(\n    ecc.isXOnlyPoint(\n      h('fffffffffffffffffffffffffffffffffffffffffffffffffffffffeeffffc2e'),\n    ),\n  );\n  assert(\n    ecc.isXOnlyPoint(\n      h('f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9'),\n    ),\n  );\n  assert(\n    ecc.isXOnlyPoint(\n      h('0000000000000000000000000000000000000000000000000000000000000001'),\n    ),\n  );\n  assert(\n    !ecc.isXOnlyPoint(\n      h('0000000000000000000000000000000000000000000000000000000000000000'),\n    ),\n  );\n  assert(\n    !ecc.isXOnlyPoint(\n      h('fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),\n    ),\n  );\n  assert(typeof ecc.xOnlyPointAddTweak === 'function');\n  tweakAddVectors.forEach(t => {\n    const r = ecc.xOnlyPointAddTweak(h(t.pubkey), h(t.tweak));\n    if (t.result === null) {\n      assert(r === null);\n    } else {\n      assert(r !== null);\n      assert(r.parity === t.parity);\n      assert(tools.compare(r.xOnlyPubkey, h(t.result)) === 0);\n    }\n  });\n}\nfunction assert(bool) {\n  if (!bool) throw new Error('ecc library invalid');\n}\nconst tweakAddVectors = [\n  {\n    pubkey: '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',\n    tweak: 'fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140',\n    parity: -1,\n    result: null,\n  },\n  {\n    pubkey: '1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b',\n    tweak: 'a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac',\n    parity: 1,\n    result: 'e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf',\n  },\n  {\n    pubkey: '2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991',\n    tweak: '823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47',\n    parity: 0,\n    result: '9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c',\n  },\n];\n"],"names":[],"mappings":";;;;AAAA;;AACA,MAAM,gBAAgB,CAAC;AAQhB,SAAS,WAAW,MAAM;IAC/B,IAAI,CAAC,QAAQ;QACX,6BAA6B;QAC7B,cAAc,MAAM,GAAG;IACzB,OAAO,IAAI,WAAW,cAAc,MAAM,EAAE;QAC1C,0BAA0B;QAC1B,UAAU;QACV,cAAc,MAAM,GAAG;IACzB;AACF;AAQO,SAAS;IACd,IAAI,CAAC,cAAc,MAAM,EACvB,MAAM,IAAI,MACR;IAEJ,OAAO,cAAc,MAAM;AAC7B;AACA,MAAM,IAAI,CAAA,MAAO,2JAAM,OAAO,CAAC;AAC/B;;;;CAIC,GACD,SAAS,UAAU,GAAG;IACpB,OAAO,OAAO,IAAI,YAAY,KAAK;IACnC,OACE,IAAI,YAAY,CACd,EAAE;IAGN,OACE,IAAI,YAAY,CACd,EAAE;IAGN,OACE,IAAI,YAAY,CACd,EAAE;IAGN,OACE,IAAI,YAAY,CACd,EAAE;IAGN,OACE,CAAC,IAAI,YAAY,CACf,EAAE;IAGN,OACE,CAAC,IAAI,YAAY,CACf,EAAE;IAGN,OAAO,OAAO,IAAI,kBAAkB,KAAK;IACzC,gBAAgB,OAAO,CAAC,CAAA;QACtB,MAAM,IAAI,IAAI,kBAAkB,CAAC,EAAE,EAAE,MAAM,GAAG,EAAE,EAAE,KAAK;QACvD,IAAI,EAAE,MAAM,KAAK,MAAM;YACrB,OAAO,MAAM;QACf,OAAO;YACL,OAAO,MAAM;YACb,OAAO,EAAE,MAAM,KAAK,EAAE,MAAM;YAC5B,OAAO,2JAAM,OAAO,CAAC,EAAE,WAAW,EAAE,EAAE,EAAE,MAAM,OAAO;QACvD;IACF;AACF;AACA,SAAS,OAAO,IAAI;IAClB,IAAI,CAAC,MAAM,MAAM,IAAI,MAAM;AAC7B;AACA,MAAM,kBAAkB;IACtB;QACE,QAAQ;QACR,OAAO;QACP,QAAQ,CAAC;QACT,QAAQ;IACV;IACA;QACE,QAAQ;QACR,OAAO;QACP,QAAQ;QACR,QAAQ;IACV;IACA;QACE,QAAQ;QACR,OAAO;QACP,QAAQ;QACR,QAAQ;IACV;CACD","ignoreList":[0]}},
    {"offset": {"line": 2479, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2485, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bitcoinjs-lib/src/esm/bufferutils.js"],"sourcesContent":["import * as types from './types.js';\nimport * as varuint from 'varuint-bitcoin';\nimport * as v from 'valibot';\nexport { varuint };\nimport * as tools from 'uint8array-tools';\nconst MAX_JS_NUMBER = 0x001fffffffffffff;\n// https://github.com/feross/buffer/blob/master/index.js#L1127\nfunction verifuint(value, max) {\n  if (typeof value !== 'number' && typeof value !== 'bigint')\n    throw new Error('cannot write a non-number as a number');\n  if (value < 0 && value < BigInt(0))\n    throw new Error('specified a negative value for writing an unsigned value');\n  if (value > max && value > BigInt(max))\n    throw new Error('RangeError: value out of range');\n  if (Math.floor(Number(value)) !== Number(value))\n    throw new Error('value has a fractional component');\n}\n/**\n * Reverses the order of bytes in a buffer.\n * @param buffer - The buffer to reverse.\n * @returns A new buffer with the bytes reversed.\n */\nexport function reverseBuffer(buffer) {\n  if (buffer.length < 1) return buffer;\n  let j = buffer.length - 1;\n  let tmp = 0;\n  for (let i = 0; i < buffer.length / 2; i++) {\n    tmp = buffer[i];\n    buffer[i] = buffer[j];\n    buffer[j] = tmp;\n    j--;\n  }\n  return buffer;\n}\nexport function cloneBuffer(buffer) {\n  const clone = new Uint8Array(buffer.length);\n  clone.set(buffer);\n  return clone;\n}\n/**\n * Helper class for serialization of bitcoin data types into a pre-allocated buffer.\n */\nexport class BufferWriter {\n  buffer;\n  offset;\n  static withCapacity(size) {\n    return new BufferWriter(new Uint8Array(size));\n  }\n  constructor(buffer, offset = 0) {\n    this.buffer = buffer;\n    this.offset = offset;\n    v.parse(v.tuple([types.BufferSchema, types.UInt32Schema]), [\n      buffer,\n      offset,\n    ]);\n  }\n  writeUInt8(i) {\n    this.offset = tools.writeUInt8(this.buffer, this.offset, i);\n  }\n  writeInt32(i) {\n    this.offset = tools.writeInt32(this.buffer, this.offset, i, 'LE');\n  }\n  writeInt64(i) {\n    this.offset = tools.writeInt64(this.buffer, this.offset, BigInt(i), 'LE');\n  }\n  writeUInt32(i) {\n    this.offset = tools.writeUInt32(this.buffer, this.offset, i, 'LE');\n  }\n  writeUInt64(i) {\n    this.offset = tools.writeUInt64(this.buffer, this.offset, BigInt(i), 'LE');\n  }\n  writeVarInt(i) {\n    const { bytes } = varuint.encode(i, this.buffer, this.offset);\n    this.offset += bytes;\n  }\n  writeSlice(slice) {\n    if (this.buffer.length < this.offset + slice.length) {\n      throw new Error('Cannot write slice out of bounds');\n    }\n    this.buffer.set(slice, this.offset);\n    this.offset += slice.length;\n  }\n  writeVarSlice(slice) {\n    this.writeVarInt(slice.length);\n    this.writeSlice(slice);\n  }\n  writeVector(vector) {\n    this.writeVarInt(vector.length);\n    vector.forEach(buf => this.writeVarSlice(buf));\n  }\n  end() {\n    if (this.buffer.length === this.offset) {\n      return this.buffer;\n    }\n    throw new Error(`buffer size ${this.buffer.length}, offset ${this.offset}`);\n  }\n}\n/**\n * Helper class for reading of bitcoin data types from a buffer.\n */\nexport class BufferReader {\n  buffer;\n  offset;\n  constructor(buffer, offset = 0) {\n    this.buffer = buffer;\n    this.offset = offset;\n    v.parse(v.tuple([types.BufferSchema, types.UInt32Schema]), [\n      buffer,\n      offset,\n    ]);\n  }\n  readUInt8() {\n    const result = tools.readUInt8(this.buffer, this.offset);\n    this.offset++;\n    return result;\n  }\n  readInt32() {\n    const result = tools.readInt32(this.buffer, this.offset, 'LE');\n    this.offset += 4;\n    return result;\n  }\n  readUInt32() {\n    const result = tools.readUInt32(this.buffer, this.offset, 'LE');\n    this.offset += 4;\n    return result;\n  }\n  readInt64() {\n    const result = tools.readInt64(this.buffer, this.offset, 'LE');\n    this.offset += 8;\n    return result;\n  }\n  readVarInt() {\n    const { bigintValue, bytes } = varuint.decode(this.buffer, this.offset);\n    this.offset += bytes;\n    return bigintValue;\n  }\n  readSlice(n) {\n    verifuint(n, MAX_JS_NUMBER);\n    const num = Number(n);\n    if (this.buffer.length < this.offset + num) {\n      throw new Error('Cannot read slice out of bounds');\n    }\n    const result = this.buffer.slice(this.offset, this.offset + num);\n    this.offset += num;\n    return result;\n  }\n  readVarSlice() {\n    return this.readSlice(this.readVarInt());\n  }\n  readVector() {\n    const count = this.readVarInt();\n    const vector = [];\n    for (let i = 0; i < count; i++) vector.push(this.readVarSlice());\n    return vector;\n  }\n}\n"],"names":[],"mappings":";;;;;;AAEA;AAFA;AAIA;AAHA;;;;;;AAIA,MAAM,gBAAgB;AACtB,8DAA8D;AAC9D,SAAS,UAAU,KAAK,EAAE,GAAG;IAC3B,IAAI,OAAO,UAAU,YAAY,OAAO,UAAU,UAChD,MAAM,IAAI,MAAM;IAClB,IAAI,QAAQ,KAAK,QAAQ,OAAO,IAC9B,MAAM,IAAI,MAAM;IAClB,IAAI,QAAQ,OAAO,QAAQ,OAAO,MAChC,MAAM,IAAI,MAAM;IAClB,IAAI,KAAK,KAAK,CAAC,OAAO,YAAY,OAAO,QACvC,MAAM,IAAI,MAAM;AACpB;AAMO,SAAS,cAAc,MAAM;IAClC,IAAI,OAAO,MAAM,GAAG,GAAG,OAAO;IAC9B,IAAI,IAAI,OAAO,MAAM,GAAG;IACxB,IAAI,MAAM;IACV,IAAK,IAAI,IAAI,GAAG,IAAI,OAAO,MAAM,GAAG,GAAG,IAAK;QAC1C,MAAM,MAAM,CAAC,EAAE;QACf,MAAM,CAAC,EAAE,GAAG,MAAM,CAAC,EAAE;QACrB,MAAM,CAAC,EAAE,GAAG;QACZ;IACF;IACA,OAAO;AACT;AACO,SAAS,YAAY,MAAM;IAChC,MAAM,QAAQ,IAAI,WAAW,OAAO,MAAM;IAC1C,MAAM,GAAG,CAAC;IACV,OAAO;AACT;AAIO,MAAM;IACX,OAAO;IACP,OAAO;IACP,OAAO,aAAa,IAAI,EAAE;QACxB,OAAO,IAAI,aAAa,IAAI,WAAW;IACzC;IACA,YAAY,MAAM,EAAE,SAAS,CAAC,CAAE;QAC9B,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,MAAM,GAAG;QACd,yIAAE,KAAK,CAAC,yIAAE,KAAK,CAAC;YAAC,wJAAM,YAAY;YAAE,wJAAM,YAAY;SAAC,GAAG;YACzD;YACA;SACD;IACH;IACA,WAAW,CAAC,EAAE;QACZ,IAAI,CAAC,MAAM,GAAG,2JAAM,UAAU,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,MAAM,EAAE;IAC3D;IACA,WAAW,CAAC,EAAE;QACZ,IAAI,CAAC,MAAM,GAAG,2JAAM,UAAU,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,MAAM,EAAE,GAAG;IAC9D;IACA,WAAW,CAAC,EAAE;QACZ,IAAI,CAAC,MAAM,GAAG,2JAAM,UAAU,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,MAAM,EAAE,OAAO,IAAI;IACtE;IACA,YAAY,CAAC,EAAE;QACb,IAAI,CAAC,MAAM,GAAG,2JAAM,WAAW,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,MAAM,EAAE,GAAG;IAC/D;IACA,YAAY,CAAC,EAAE;QACb,IAAI,CAAC,MAAM,GAAG,2JAAM,WAAW,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,MAAM,EAAE,OAAO,IAAI;IACvE;IACA,YAAY,CAAC,EAAE;QACb,MAAM,EAAE,KAAK,EAAE,GAAG,0JAAQ,MAAM,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,MAAM;QAC5D,IAAI,CAAC,MAAM,IAAI;IACjB;IACA,WAAW,KAAK,EAAE;QAChB,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,GAAG,MAAM,MAAM,EAAE;YACnD,MAAM,IAAI,MAAM;QAClB;QACA,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,OAAO,IAAI,CAAC,MAAM;QAClC,IAAI,CAAC,MAAM,IAAI,MAAM,MAAM;IAC7B;IACA,cAAc,KAAK,EAAE;QACnB,IAAI,CAAC,WAAW,CAAC,MAAM,MAAM;QAC7B,IAAI,CAAC,UAAU,CAAC;IAClB;IACA,YAAY,MAAM,EAAE;QAClB,IAAI,CAAC,WAAW,CAAC,OAAO,MAAM;QAC9B,OAAO,OAAO,CAAC,CAAA,MAAO,IAAI,CAAC,aAAa,CAAC;IAC3C;IACA,MAAM;QACJ,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,KAAK,IAAI,CAAC,MAAM,EAAE;YACtC,OAAO,IAAI,CAAC,MAAM;QACpB;QACA,MAAM,IAAI,MAAM,CAAC,YAAY,EAAE,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,SAAS,EAAE,IAAI,CAAC,MAAM,EAAE;IAC5E;AACF;AAIO,MAAM;IACX,OAAO;IACP,OAAO;IACP,YAAY,MAAM,EAAE,SAAS,CAAC,CAAE;QAC9B,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,MAAM,GAAG;QACd,yIAAE,KAAK,CAAC,yIAAE,KAAK,CAAC;YAAC,wJAAM,YAAY;YAAE,wJAAM,YAAY;SAAC,GAAG;YACzD;YACA;SACD;IACH;IACA,YAAY;QACV,MAAM,SAAS,2JAAM,SAAS,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,MAAM;QACvD,IAAI,CAAC,MAAM;QACX,OAAO;IACT;IACA,YAAY;QACV,MAAM,SAAS,2JAAM,SAAS,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,MAAM,EAAE;QACzD,IAAI,CAAC,MAAM,IAAI;QACf,OAAO;IACT;IACA,aAAa;QACX,MAAM,SAAS,2JAAM,UAAU,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,MAAM,EAAE;QAC1D,IAAI,CAAC,MAAM,IAAI;QACf,OAAO;IACT;IACA,YAAY;QACV,MAAM,SAAS,2JAAM,SAAS,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,MAAM,EAAE;QACzD,IAAI,CAAC,MAAM,IAAI;QACf,OAAO;IACT;IACA,aAAa;QACX,MAAM,EAAE,WAAW,EAAE,KAAK,EAAE,GAAG,0JAAQ,MAAM,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,MAAM;QACtE,IAAI,CAAC,MAAM,IAAI;QACf,OAAO;IACT;IACA,UAAU,CAAC,EAAE;QACX,UAAU,GAAG;QACb,MAAM,MAAM,OAAO;QACnB,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,GAAG,KAAK;YAC1C,MAAM,IAAI,MAAM;QAClB;QACA,MAAM,SAAS,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,MAAM,GAAG;QAC5D,IAAI,CAAC,MAAM,IAAI;QACf,OAAO;IACT;IACA,eAAe;QACb,OAAO,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,UAAU;IACvC;IACA,aAAa;QACX,MAAM,QAAQ,IAAI,CAAC,UAAU;QAC7B,MAAM,SAAS,EAAE;QACjB,IAAK,IAAI,IAAI,GAAG,IAAI,OAAO,IAAK,OAAO,IAAI,CAAC,IAAI,CAAC,YAAY;QAC7D,OAAO;IACT;AACF","ignoreList":[0]}},
    {"offset": {"line": 2642, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2659, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bitcoinjs-lib/src/esm/payments/bip341.js"],"sourcesContent":["import { getEccLib } from '../ecc_lib.js';\nimport * as bcrypto from '../crypto.js';\nimport { varuint } from '../bufferutils.js';\nimport { isTapleaf } from '../types.js';\nimport * as tools from 'uint8array-tools';\nexport const LEAF_VERSION_TAPSCRIPT = 0xc0;\nexport const MAX_TAPTREE_DEPTH = 128;\nconst isHashBranch = ht => 'left' in ht && 'right' in ht;\n/**\n * Calculates the root hash from a given control block and leaf hash.\n * @param controlBlock - The control block buffer.\n * @param leafHash - The leaf hash buffer.\n * @returns The root hash buffer.\n * @throws {TypeError} If the control block length is less than 33.\n */\nexport function rootHashFromPath(controlBlock, leafHash) {\n  if (controlBlock.length < 33)\n    throw new TypeError(\n      `The control-block length is too small. Got ${controlBlock.length}, expected min 33.`,\n    );\n  const m = (controlBlock.length - 33) / 32;\n  let kj = leafHash;\n  for (let j = 0; j < m; j++) {\n    const ej = controlBlock.slice(33 + 32 * j, 65 + 32 * j);\n    if (tools.compare(kj, ej) < 0) {\n      kj = tapBranchHash(kj, ej);\n    } else {\n      kj = tapBranchHash(ej, kj);\n    }\n  }\n  return kj;\n}\n/**\n * Build a hash tree of merkle nodes from the scripts binary tree.\n * @param scriptTree - the tree of scripts to pairwise hash.\n */\nexport function toHashTree(scriptTree) {\n  if (isTapleaf(scriptTree)) return { hash: tapleafHash(scriptTree) };\n  const hashes = [toHashTree(scriptTree[0]), toHashTree(scriptTree[1])];\n  // hashes.sort((a, b) => a.hash.compare(b.hash));\n  hashes.sort((a, b) => tools.compare(a.hash, b.hash));\n  const [left, right] = hashes;\n  return {\n    hash: tapBranchHash(left.hash, right.hash),\n    left,\n    right,\n  };\n}\n/**\n * Given a HashTree, finds the path from a particular hash to the root.\n * @param node - the root of the tree\n * @param hash - the hash to search for\n * @returns - array of sibling hashes, from leaf (inclusive) to root\n * (exclusive) needed to prove inclusion of the specified hash. undefined if no\n * path is found\n */\nexport function findScriptPath(node, hash) {\n  if (isHashBranch(node)) {\n    const leftPath = findScriptPath(node.left, hash);\n    if (leftPath !== undefined) return [...leftPath, node.right.hash];\n    const rightPath = findScriptPath(node.right, hash);\n    if (rightPath !== undefined) return [...rightPath, node.left.hash];\n  } else if (tools.compare(node.hash, hash) === 0) {\n    return [];\n  }\n  return undefined;\n}\n/**\n * Calculates the tapleaf hash for a given Tapleaf object.\n * @param leaf - The Tapleaf object to calculate the hash for.\n * @returns The tapleaf hash as a Buffer.\n */\nexport function tapleafHash(leaf) {\n  const version = leaf.version || LEAF_VERSION_TAPSCRIPT;\n  return bcrypto.taggedHash(\n    'TapLeaf',\n    tools.concat([Uint8Array.from([version]), serializeScript(leaf.output)]),\n  );\n}\n/**\n * Computes the taproot tweak hash for a given public key and optional hash.\n * If a hash is provided, the public key and hash are concatenated before computing the hash.\n * If no hash is provided, only the public key is used to compute the hash.\n *\n * @param pubKey - The public key buffer.\n * @param h - The optional hash buffer.\n * @returns The taproot tweak hash.\n */\nexport function tapTweakHash(pubKey, h) {\n  return bcrypto.taggedHash(\n    'TapTweak',\n    tools.concat(h ? [pubKey, h] : [pubKey]),\n  );\n}\n/**\n * Tweak a public key with a given tweak hash.\n * @param pubKey - The public key to be tweaked.\n * @param h - The tweak hash.\n * @returns The tweaked public key or null if the input is invalid.\n */\nexport function tweakKey(pubKey, h) {\n  if (!(pubKey instanceof Uint8Array)) return null;\n  if (pubKey.length !== 32) return null;\n  if (h && h.length !== 32) return null;\n  const tweakHash = tapTweakHash(pubKey, h);\n  const res = getEccLib().xOnlyPointAddTweak(pubKey, tweakHash);\n  if (!res || res.xOnlyPubkey === null) return null;\n  return {\n    parity: res.parity,\n    x: Uint8Array.from(res.xOnlyPubkey),\n  };\n}\n/**\n * Computes the TapBranch hash by concatenating two buffers and applying the 'TapBranch' tagged hash algorithm.\n *\n * @param a - The first buffer.\n * @param b - The second buffer.\n * @returns The TapBranch hash of the concatenated buffers.\n */\nfunction tapBranchHash(a, b) {\n  return bcrypto.taggedHash('TapBranch', tools.concat([a, b]));\n}\n/**\n * Serializes a script by encoding its length as a varint and concatenating it with the script.\n *\n * @param s - The script to be serialized.\n * @returns The serialized script as a Buffer.\n */\nfunction serializeScript(s) {\n  /* global BigInt */\n  const varintLen = varuint.encodingLength(s.length);\n  const buffer = new Uint8Array(varintLen);\n  varuint.encode(s.length, buffer);\n  return tools.concat([buffer, s]);\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2786, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2792, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bitcoinjs-lib/src/esm/payments/p2tr.js"],"sourcesContent":["import { bitcoin as BITCOIN_NETWORK } from '../networks.js';\nimport * as bscript from '../script.js';\nimport {\n  isTaptree,\n  TAPLEAF_VERSION_MASK,\n  stacksEqual,\n  NBufferSchemaFactory,\n  BufferSchema,\n} from '../types.js';\nimport { getEccLib } from '../ecc_lib.js';\nimport {\n  toHashTree,\n  rootHashFromPath,\n  findScriptPath,\n  tapleafHash,\n  tweakKey,\n  LEAF_VERSION_TAPSCRIPT,\n} from './bip341.js';\nimport * as lazy from './lazy.js';\nimport { bech32m } from 'bech32';\nimport { fromBech32 } from '../address.js';\nimport * as tools from 'uint8array-tools';\nimport * as v from 'valibot';\nconst OPS = bscript.OPS;\nconst TAPROOT_WITNESS_VERSION = 0x01;\nconst ANNEX_PREFIX = 0x50;\n/**\n * Creates a Pay-to-Taproot (P2TR) payment object.\n *\n * @param a - The payment object containing the necessary data for P2TR.\n * @param opts - Optional payment options.\n * @returns The P2TR payment object.\n * @throws {TypeError} If the provided data is invalid or insufficient.\n */\nexport function p2tr(a, opts) {\n  if (\n    !a.address &&\n    !a.output &&\n    !a.pubkey &&\n    !a.internalPubkey &&\n    !(a.witness && a.witness.length > 1)\n  )\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  v.parse(\n    v.partial(\n      v.object({\n        address: v.string(),\n        input: NBufferSchemaFactory(0),\n        network: v.object({}),\n        output: NBufferSchemaFactory(34),\n        internalPubkey: NBufferSchemaFactory(32),\n        hash: NBufferSchemaFactory(32), // merkle root hash, the tweak\n        pubkey: NBufferSchemaFactory(32), // tweaked with `hash` from `internalPubkey`\n        signature: v.union([\n          NBufferSchemaFactory(64),\n          NBufferSchemaFactory(65),\n        ]),\n        witness: v.array(BufferSchema),\n        scriptTree: v.custom(isTaptree, 'Taptree is not of type isTaptree'),\n        redeem: v.partial(\n          v.object({\n            output: BufferSchema, // tapleaf script\n            redeemVersion: v.number(), // tapleaf version\n            witness: v.array(BufferSchema),\n          }),\n        ),\n        redeemVersion: v.number(),\n      }),\n    ),\n    a,\n  );\n  const _address = lazy.value(() => {\n    return fromBech32(a.address);\n  });\n  // remove annex if present, ignored by taproot\n  const _witness = lazy.value(() => {\n    if (!a.witness || !a.witness.length) return;\n    if (\n      a.witness.length >= 2 &&\n      a.witness[a.witness.length - 1][0] === ANNEX_PREFIX\n    ) {\n      return a.witness.slice(0, -1);\n    }\n    return a.witness.slice();\n  });\n  const _hashTree = lazy.value(() => {\n    if (a.scriptTree) return toHashTree(a.scriptTree);\n    if (a.hash) return { hash: a.hash };\n    return;\n  });\n  const network = a.network || BITCOIN_NETWORK;\n  const o = { name: 'p2tr', network };\n  lazy.prop(o, 'address', () => {\n    if (!o.pubkey) return;\n    const words = bech32m.toWords(o.pubkey);\n    words.unshift(TAPROOT_WITNESS_VERSION);\n    return bech32m.encode(network.bech32, words);\n  });\n  lazy.prop(o, 'hash', () => {\n    const hashTree = _hashTree();\n    if (hashTree) return hashTree.hash;\n    const w = _witness();\n    if (w && w.length > 1) {\n      const controlBlock = w[w.length - 1];\n      const leafVersion = controlBlock[0] & TAPLEAF_VERSION_MASK;\n      const script = w[w.length - 2];\n      const leafHash = tapleafHash({ output: script, version: leafVersion });\n      return rootHashFromPath(controlBlock, leafHash);\n    }\n    return null;\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.pubkey) return;\n    return bscript.compile([OPS.OP_1, o.pubkey]);\n  });\n  lazy.prop(o, 'redeemVersion', () => {\n    if (a.redeemVersion) return a.redeemVersion;\n    if (\n      a.redeem &&\n      a.redeem.redeemVersion !== undefined &&\n      a.redeem.redeemVersion !== null\n    ) {\n      return a.redeem.redeemVersion;\n    }\n    return LEAF_VERSION_TAPSCRIPT;\n  });\n  lazy.prop(o, 'redeem', () => {\n    const witness = _witness(); // witness without annex\n    if (!witness || witness.length < 2) return;\n    return {\n      output: witness[witness.length - 2],\n      witness: witness.slice(0, -2),\n      redeemVersion: witness[witness.length - 1][0] & TAPLEAF_VERSION_MASK,\n    };\n  });\n  lazy.prop(o, 'pubkey', () => {\n    if (a.pubkey) return a.pubkey;\n    if (a.output) return a.output.slice(2);\n    if (a.address) return _address().data;\n    if (o.internalPubkey) {\n      const tweakedKey = tweakKey(o.internalPubkey, o.hash);\n      if (tweakedKey) return tweakedKey.x;\n    }\n  });\n  lazy.prop(o, 'internalPubkey', () => {\n    if (a.internalPubkey) return a.internalPubkey;\n    const witness = _witness();\n    if (witness && witness.length > 1)\n      return witness[witness.length - 1].slice(1, 33);\n  });\n  lazy.prop(o, 'signature', () => {\n    if (a.signature) return a.signature;\n    const witness = _witness(); // witness without annex\n    if (!witness || witness.length !== 1) return;\n    return witness[0];\n  });\n  lazy.prop(o, 'witness', () => {\n    if (a.witness) return a.witness;\n    const hashTree = _hashTree();\n    if (hashTree && a.redeem && a.redeem.output && a.internalPubkey) {\n      const leafHash = tapleafHash({\n        output: a.redeem.output,\n        version: o.redeemVersion,\n      });\n      const path = findScriptPath(hashTree, leafHash);\n      if (!path) return;\n      const outputKey = tweakKey(a.internalPubkey, hashTree.hash);\n      if (!outputKey) return;\n      const controlBock = tools.concat(\n        [\n          Uint8Array.from([o.redeemVersion | outputKey.parity]),\n          a.internalPubkey,\n        ].concat(path),\n      );\n      return [a.redeem.output, controlBock];\n    }\n    if (a.signature) return [a.signature];\n  });\n  // extended validation\n  if (opts.validate) {\n    let pubkey = Uint8Array.from([]);\n    if (a.address) {\n      if (network && network.bech32 !== _address().prefix)\n        throw new TypeError('Invalid prefix or Network mismatch');\n      if (_address().version !== TAPROOT_WITNESS_VERSION)\n        throw new TypeError('Invalid address version');\n      if (_address().data.length !== 32)\n        throw new TypeError('Invalid address data');\n      pubkey = _address().data;\n    }\n    if (a.pubkey) {\n      if (pubkey.length > 0 && tools.compare(pubkey, a.pubkey) !== 0)\n        throw new TypeError('Pubkey mismatch');\n      else pubkey = a.pubkey;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 34 ||\n        a.output[0] !== OPS.OP_1 ||\n        a.output[1] !== 0x20\n      )\n        throw new TypeError('Output is invalid');\n      if (pubkey.length > 0 && tools.compare(pubkey, a.output.slice(2)) !== 0)\n        throw new TypeError('Pubkey mismatch');\n      else pubkey = a.output.slice(2);\n    }\n    if (a.internalPubkey) {\n      const tweakedKey = tweakKey(a.internalPubkey, o.hash);\n      if (pubkey.length > 0 && tools.compare(pubkey, tweakedKey.x) !== 0)\n        throw new TypeError('Pubkey mismatch');\n      else pubkey = tweakedKey.x;\n    }\n    if (pubkey && pubkey.length) {\n      if (!getEccLib().isXOnlyPoint(pubkey))\n        throw new TypeError('Invalid pubkey for p2tr');\n    }\n    const hashTree = _hashTree();\n    if (a.hash && hashTree) {\n      if (tools.compare(a.hash, hashTree.hash) !== 0)\n        throw new TypeError('Hash mismatch');\n    }\n    if (a.redeem && a.redeem.output && hashTree) {\n      const leafHash = tapleafHash({\n        output: a.redeem.output,\n        version: o.redeemVersion,\n      });\n      if (!findScriptPath(hashTree, leafHash))\n        throw new TypeError('Redeem script not in tree');\n    }\n    const witness = _witness();\n    // compare the provided redeem data with the one computed from witness\n    if (a.redeem && o.redeem) {\n      if (a.redeem.redeemVersion) {\n        if (a.redeem.redeemVersion !== o.redeem.redeemVersion)\n          throw new TypeError('Redeem.redeemVersion and witness mismatch');\n      }\n      if (a.redeem.output) {\n        if (bscript.decompile(a.redeem.output).length === 0)\n          throw new TypeError('Redeem.output is invalid');\n        // output redeem is constructed from the witness\n        if (\n          o.redeem.output &&\n          tools.compare(a.redeem.output, o.redeem.output) !== 0\n        )\n          throw new TypeError('Redeem.output and witness mismatch');\n      }\n      if (a.redeem.witness) {\n        if (\n          o.redeem.witness &&\n          !stacksEqual(a.redeem.witness, o.redeem.witness)\n        )\n          throw new TypeError('Redeem.witness and witness mismatch');\n      }\n    }\n    if (witness && witness.length) {\n      if (witness.length === 1) {\n        // key spending\n        if (a.signature && tools.compare(a.signature, witness[0]) !== 0)\n          throw new TypeError('Signature mismatch');\n      } else {\n        // script path spending\n        const controlBlock = witness[witness.length - 1];\n        if (controlBlock.length < 33)\n          throw new TypeError(\n            `The control-block length is too small. Got ${controlBlock.length}, expected min 33.`,\n          );\n        if ((controlBlock.length - 33) % 32 !== 0)\n          throw new TypeError(\n            `The control-block length of ${controlBlock.length} is incorrect!`,\n          );\n        const m = (controlBlock.length - 33) / 32;\n        if (m > 128)\n          throw new TypeError(\n            `The script path is too long. Got ${m}, expected max 128.`,\n          );\n        const internalPubkey = controlBlock.slice(1, 33);\n        if (\n          a.internalPubkey &&\n          tools.compare(a.internalPubkey, internalPubkey) !== 0\n        )\n          throw new TypeError('Internal pubkey mismatch');\n        if (!getEccLib().isXOnlyPoint(internalPubkey))\n          throw new TypeError('Invalid internalPubkey for p2tr witness');\n        const leafVersion = controlBlock[0] & TAPLEAF_VERSION_MASK;\n        const script = witness[witness.length - 2];\n        const leafHash = tapleafHash({ output: script, version: leafVersion });\n        const hash = rootHashFromPath(controlBlock, leafHash);\n        const outputKey = tweakKey(internalPubkey, hash);\n        if (!outputKey)\n          // todo: needs test data\n          throw new TypeError('Invalid outputKey for p2tr witness');\n        if (pubkey.length && tools.compare(pubkey, outputKey.x) !== 0)\n          throw new TypeError('Pubkey mismatch for p2tr witness');\n        if (outputKey.parity !== (controlBlock[0] & 1))\n          throw new Error('Incorrect parity');\n      }\n    }\n  }\n  return Object.assign(o, a);\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3043, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3049, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bitcoinjs-lib/src/esm/payments/index.js"],"sourcesContent":["import { p2data as embed } from './embed.js';\nimport { p2ms } from './p2ms.js';\nimport { p2pk } from './p2pk.js';\nimport { p2pkh } from './p2pkh.js';\nimport { p2sh } from './p2sh.js';\nimport { p2wpkh } from './p2wpkh.js';\nimport { p2wsh } from './p2wsh.js';\nimport { p2tr } from './p2tr.js';\nexport { embed, p2ms, p2pk, p2pkh, p2sh, p2wpkh, p2wsh, p2tr };\n// TODO\n// witness commitment\n"],"names":[],"mappings":";;;;;;;;;;CASA,OAAO;CACP,qBAAqB","ignoreList":[0]}},
    {"offset": {"line": 3061, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3126, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bitcoinjs-lib/src/esm/address.js"],"sourcesContent":["import * as networks from './networks.js';\nimport * as payments from './payments/index.js';\nimport * as bscript from './script.js';\nimport { Hash160bitSchema, UInt8Schema } from './types.js';\nimport { bech32, bech32m } from 'bech32';\nimport bs58check from 'bs58check';\nimport * as tools from 'uint8array-tools';\nimport * as v from 'valibot';\nconst FUTURE_SEGWIT_MAX_SIZE = 40;\nconst FUTURE_SEGWIT_MIN_SIZE = 2;\nconst FUTURE_SEGWIT_MAX_VERSION = 16;\nconst FUTURE_SEGWIT_MIN_VERSION = 2;\nconst FUTURE_SEGWIT_VERSION_DIFF = 0x50;\nconst FUTURE_SEGWIT_VERSION_WARNING =\n  'WARNING: Sending to a future segwit version address can lead to loss of funds. ' +\n  'End users MUST be warned carefully in the GUI and asked if they wish to proceed ' +\n  'with caution. Wallets should verify the segwit version from the output of fromBech32, ' +\n  'then decide when it is safe to use which version of segwit.';\n/**\n * Converts an output buffer to a future segwit address.\n * @param output - The output buffer.\n * @param network - The network object.\n * @returns The future segwit address.\n * @throws {TypeError} If the program length or version is invalid for segwit address.\n */\nfunction _toFutureSegwitAddress(output, network) {\n  const data = output.slice(2);\n  if (\n    data.length < FUTURE_SEGWIT_MIN_SIZE ||\n    data.length > FUTURE_SEGWIT_MAX_SIZE\n  )\n    throw new TypeError('Invalid program length for segwit address');\n  const version = output[0] - FUTURE_SEGWIT_VERSION_DIFF;\n  if (\n    version < FUTURE_SEGWIT_MIN_VERSION ||\n    version > FUTURE_SEGWIT_MAX_VERSION\n  )\n    throw new TypeError('Invalid version for segwit address');\n  if (output[1] !== data.length)\n    throw new TypeError('Invalid script for segwit address');\n  console.warn(FUTURE_SEGWIT_VERSION_WARNING);\n  return toBech32(data, version, network.bech32);\n}\n/**\n * Decodes a base58check encoded Bitcoin address and returns the version and hash.\n *\n * @param address - The base58check encoded Bitcoin address to decode.\n * @returns An object containing the version and hash of the decoded address.\n * @throws {TypeError} If the address is too short or too long.\n */\nexport function fromBase58Check(address) {\n  const payload = bs58check.decode(address);\n  // TODO: 4.0.0, move to \"toOutputScript\"\n  if (payload.length < 21) throw new TypeError(address + ' is too short');\n  if (payload.length > 21) throw new TypeError(address + ' is too long');\n  const version = tools.readUInt8(payload, 0);\n  const hash = payload.slice(1);\n  return { version, hash };\n}\n/**\n * Converts a Bech32 or Bech32m encoded address to its corresponding data representation.\n * @param address - The Bech32 or Bech32m encoded address.\n * @returns An object containing the version, prefix, and data of the address.\n * @throws {TypeError} If the address uses the wrong encoding.\n */\nexport function fromBech32(address) {\n  let result;\n  let version;\n  try {\n    result = bech32.decode(address);\n  } catch (e) {}\n  if (result) {\n    version = result.words[0];\n    if (version !== 0) throw new TypeError(address + ' uses wrong encoding');\n  } else {\n    result = bech32m.decode(address);\n    version = result.words[0];\n    if (version === 0) throw new TypeError(address + ' uses wrong encoding');\n  }\n  const data = bech32.fromWords(result.words.slice(1));\n  return {\n    version,\n    prefix: result.prefix,\n    data: Uint8Array.from(data),\n  };\n}\n/**\n * Converts a hash to a Base58Check-encoded string.\n * @param hash - The hash to be encoded.\n * @param version - The version byte to be prepended to the encoded string.\n * @returns The Base58Check-encoded string.\n */\nexport function toBase58Check(hash, version) {\n  v.parse(v.tuple([Hash160bitSchema, UInt8Schema]), [hash, version]);\n  const payload = new Uint8Array(21);\n  tools.writeUInt8(payload, 0, version);\n  payload.set(hash, 1);\n  return bs58check.encode(payload);\n}\n/**\n * Converts a buffer to a Bech32 or Bech32m encoded string.\n * @param data - The buffer to be encoded.\n * @param version - The version number to be used in the encoding.\n * @param prefix - The prefix string to be used in the encoding.\n * @returns The Bech32 or Bech32m encoded string.\n */\nexport function toBech32(data, version, prefix) {\n  const words = bech32.toWords(data);\n  words.unshift(version);\n  return version === 0\n    ? bech32.encode(prefix, words)\n    : bech32m.encode(prefix, words);\n}\n/**\n * Converts an output script to a Bitcoin address.\n * @param output - The output script as a Buffer.\n * @param network - The Bitcoin network (optional).\n * @returns The Bitcoin address corresponding to the output script.\n * @throws If the output script has no matching address.\n */\nexport function fromOutputScript(output, network) {\n  // TODO: Network\n  network = network || networks.bitcoin;\n  try {\n    return payments.p2pkh({ output, network }).address;\n  } catch (e) {}\n  try {\n    return payments.p2sh({ output, network }).address;\n  } catch (e) {}\n  try {\n    return payments.p2wpkh({ output, network }).address;\n  } catch (e) {}\n  try {\n    return payments.p2wsh({ output, network }).address;\n  } catch (e) {}\n  try {\n    return payments.p2tr({ output, network }).address;\n  } catch (e) {}\n  try {\n    return _toFutureSegwitAddress(output, network);\n  } catch (e) {}\n  throw new Error(bscript.toASM(output) + ' has no matching Address');\n}\n/**\n * Converts a Bitcoin address to its corresponding output script.\n * @param address - The Bitcoin address to convert.\n * @param network - The Bitcoin network to use. Defaults to the Bitcoin network.\n * @returns The corresponding output script as a Buffer.\n * @throws If the address has an invalid prefix or no matching script.\n */\nexport function toOutputScript(address, network) {\n  network = network || networks.bitcoin;\n  let decodeBase58;\n  let decodeBech32;\n  try {\n    decodeBase58 = fromBase58Check(address);\n  } catch (e) {}\n  if (decodeBase58) {\n    if (decodeBase58.version === network.pubKeyHash)\n      return payments.p2pkh({ hash: decodeBase58.hash }).output;\n    if (decodeBase58.version === network.scriptHash)\n      return payments.p2sh({ hash: decodeBase58.hash }).output;\n  } else {\n    try {\n      decodeBech32 = fromBech32(address);\n    } catch (e) {}\n    if (decodeBech32) {\n      if (decodeBech32.prefix !== network.bech32)\n        throw new Error(address + ' has an invalid prefix');\n      if (decodeBech32.version === 0) {\n        if (decodeBech32.data.length === 20)\n          return payments.p2wpkh({ hash: decodeBech32.data }).output;\n        if (decodeBech32.data.length === 32)\n          return payments.p2wsh({ hash: decodeBech32.data }).output;\n      } else if (decodeBech32.version === 1) {\n        if (decodeBech32.data.length === 32)\n          return payments.p2tr({ pubkey: decodeBech32.data }).output;\n      } else if (\n        decodeBech32.version >= FUTURE_SEGWIT_MIN_VERSION &&\n        decodeBech32.version <= FUTURE_SEGWIT_MAX_VERSION &&\n        decodeBech32.data.length >= FUTURE_SEGWIT_MIN_SIZE &&\n        decodeBech32.data.length <= FUTURE_SEGWIT_MAX_SIZE\n      ) {\n        console.warn(FUTURE_SEGWIT_VERSION_WARNING);\n        return bscript.compile([\n          decodeBech32.version + FUTURE_SEGWIT_VERSION_DIFF,\n          decodeBech32.data,\n        ]);\n      }\n    }\n  }\n  throw new Error(address + ' has no matching Script');\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3304, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3310, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bitcoinjs-lib/src/esm/merkle.js"],"sourcesContent":["import * as tools from 'uint8array-tools';\n/**\n * Calculates the Merkle root of an array of buffers using a specified digest function.\n *\n * @param values - The array of buffers.\n * @param digestFn - The digest function used to calculate the hash of the concatenated buffers.\n * @returns The Merkle root as a buffer.\n * @throws {TypeError} If the values parameter is not an array or the digestFn parameter is not a function.\n */\nexport function fastMerkleRoot(values, digestFn) {\n  if (!Array.isArray(values)) throw TypeError('Expected values Array');\n  if (typeof digestFn !== 'function')\n    throw TypeError('Expected digest Function');\n  let length = values.length;\n  const results = values.concat();\n  while (length > 1) {\n    let j = 0;\n    for (let i = 0; i < length; i += 2, ++j) {\n      const left = results[i];\n      const right = i + 1 === length ? left : results[i + 1];\n      const data = tools.concat([left, right]);\n      results[j] = digestFn(data);\n    }\n    length = j;\n  }\n  return results[0];\n}\n"],"names":[],"mappings":";;;AAAA;;AASO,SAAS,eAAe,MAAM,EAAE,QAAQ;IAC7C,IAAI,CAAC,MAAM,OAAO,CAAC,SAAS,MAAM,UAAU;IAC5C,IAAI,OAAO,aAAa,YACtB,MAAM,UAAU;IAClB,IAAI,SAAS,OAAO,MAAM;IAC1B,MAAM,UAAU,OAAO,MAAM;IAC7B,MAAO,SAAS,EAAG;QACjB,IAAI,IAAI;QACR,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,KAAK,GAAG,EAAE,EAAG;YACvC,MAAM,OAAO,OAAO,CAAC,EAAE;YACvB,MAAM,QAAQ,IAAI,MAAM,SAAS,OAAO,OAAO,CAAC,IAAI,EAAE;YACtD,MAAM,OAAO,2JAAM,MAAM,CAAC;gBAAC;gBAAM;aAAM;YACvC,OAAO,CAAC,EAAE,GAAG,SAAS;QACxB;QACA,SAAS;IACX;IACA,OAAO,OAAO,CAAC,EAAE;AACnB","ignoreList":[0]}},
    {"offset": {"line": 3335, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3341, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bitcoinjs-lib/src/esm/transaction.js"],"sourcesContent":["import {\n  BufferReader,\n  BufferWriter,\n  reverseBuffer,\n  varuint,\n} from './bufferutils.js';\nimport * as bcrypto from './crypto.js';\nimport { sha256 } from '@noble/hashes/sha256';\nimport * as bscript from './script.js';\nimport { OPS as opcodes } from './script.js';\nimport * as types from './types.js';\nimport * as tools from 'uint8array-tools';\nimport * as v from 'valibot';\nfunction varSliceSize(someScript) {\n  const length = someScript.length;\n  return varuint.encodingLength(length) + length;\n}\nfunction vectorSize(someVector) {\n  const length = someVector.length;\n  return (\n    varuint.encodingLength(length) +\n    someVector.reduce((sum, witness) => {\n      return sum + varSliceSize(witness);\n    }, 0)\n  );\n}\nconst EMPTY_BUFFER = new Uint8Array(0);\nconst EMPTY_WITNESS = [];\nconst ZERO = tools.fromHex(\n  '0000000000000000000000000000000000000000000000000000000000000000',\n);\nconst ONE = tools.fromHex(\n  '0000000000000000000000000000000000000000000000000000000000000001',\n);\nconst VALUE_UINT64_MAX = tools.fromHex('ffffffffffffffff');\nconst BLANK_OUTPUT = {\n  script: EMPTY_BUFFER,\n  valueBuffer: VALUE_UINT64_MAX,\n};\nfunction isOutput(out) {\n  return out.value !== undefined;\n}\n/**\n * Represents a Bitcoin transaction.\n */\nexport class Transaction {\n  static DEFAULT_SEQUENCE = 0xffffffff;\n  static SIGHASH_DEFAULT = 0x00;\n  static SIGHASH_ALL = 0x01;\n  static SIGHASH_NONE = 0x02;\n  static SIGHASH_SINGLE = 0x03;\n  static SIGHASH_ANYONECANPAY = 0x80;\n  static SIGHASH_OUTPUT_MASK = 0x03;\n  static SIGHASH_INPUT_MASK = 0x80;\n  static ADVANCED_TRANSACTION_MARKER = 0x00;\n  static ADVANCED_TRANSACTION_FLAG = 0x01;\n  static fromBuffer(buffer, _NO_STRICT) {\n    const bufferReader = new BufferReader(buffer);\n    const tx = new Transaction();\n    tx.version = bufferReader.readInt32();\n    const marker = bufferReader.readUInt8();\n    const flag = bufferReader.readUInt8();\n    let hasWitnesses = false;\n    if (\n      marker === Transaction.ADVANCED_TRANSACTION_MARKER &&\n      flag === Transaction.ADVANCED_TRANSACTION_FLAG\n    ) {\n      hasWitnesses = true;\n    } else {\n      bufferReader.offset -= 2;\n    }\n    const vinLen = bufferReader.readVarInt();\n    for (let i = 0; i < vinLen; ++i) {\n      tx.ins.push({\n        hash: bufferReader.readSlice(32),\n        index: bufferReader.readUInt32(),\n        script: bufferReader.readVarSlice(),\n        sequence: bufferReader.readUInt32(),\n        witness: EMPTY_WITNESS,\n      });\n    }\n    const voutLen = bufferReader.readVarInt();\n    for (let i = 0; i < voutLen; ++i) {\n      tx.outs.push({\n        value: bufferReader.readInt64(),\n        script: bufferReader.readVarSlice(),\n      });\n    }\n    if (hasWitnesses) {\n      for (let i = 0; i < vinLen; ++i) {\n        tx.ins[i].witness = bufferReader.readVector();\n      }\n      // was this pointless?\n      if (!tx.hasWitnesses())\n        throw new Error('Transaction has superfluous witness data');\n    }\n    tx.locktime = bufferReader.readUInt32();\n    if (_NO_STRICT) return tx;\n    if (bufferReader.offset !== buffer.length)\n      throw new Error('Transaction has unexpected data');\n    return tx;\n  }\n  static fromHex(hex) {\n    return Transaction.fromBuffer(tools.fromHex(hex), false);\n  }\n  static isCoinbaseHash(buffer) {\n    v.parse(types.Hash256bitSchema, buffer);\n    for (let i = 0; i < 32; ++i) {\n      if (buffer[i] !== 0) return false;\n    }\n    return true;\n  }\n  version = 1;\n  locktime = 0;\n  ins = [];\n  outs = [];\n  isCoinbase() {\n    return (\n      this.ins.length === 1 && Transaction.isCoinbaseHash(this.ins[0].hash)\n    );\n  }\n  addInput(hash, index, sequence, scriptSig) {\n    v.parse(\n      v.tuple([\n        types.Hash256bitSchema,\n        types.UInt32Schema,\n        v.nullable(v.optional(types.UInt32Schema)),\n        v.nullable(v.optional(types.BufferSchema)),\n      ]),\n      [hash, index, sequence, scriptSig],\n    );\n    if (sequence === undefined || sequence === null) {\n      sequence = Transaction.DEFAULT_SEQUENCE;\n    }\n    // Add the input and return the input's index\n    return (\n      this.ins.push({\n        hash,\n        index,\n        script: scriptSig || EMPTY_BUFFER,\n        sequence: sequence,\n        witness: EMPTY_WITNESS,\n      }) - 1\n    );\n  }\n  addOutput(scriptPubKey, value) {\n    v.parse(v.tuple([types.BufferSchema, types.SatoshiSchema]), [\n      scriptPubKey,\n      value,\n    ]);\n    // Add the output and return the output's index\n    return (\n      this.outs.push({\n        script: scriptPubKey,\n        value,\n      }) - 1\n    );\n  }\n  hasWitnesses() {\n    return this.ins.some(x => {\n      return x.witness.length !== 0;\n    });\n  }\n  weight() {\n    const base = this.byteLength(false);\n    const total = this.byteLength(true);\n    return base * 3 + total;\n  }\n  virtualSize() {\n    return Math.ceil(this.weight() / 4);\n  }\n  byteLength(_ALLOW_WITNESS = true) {\n    const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();\n    return (\n      (hasWitnesses ? 10 : 8) +\n      varuint.encodingLength(this.ins.length) +\n      varuint.encodingLength(this.outs.length) +\n      this.ins.reduce((sum, input) => {\n        return sum + 40 + varSliceSize(input.script);\n      }, 0) +\n      this.outs.reduce((sum, output) => {\n        return sum + 8 + varSliceSize(output.script);\n      }, 0) +\n      (hasWitnesses\n        ? this.ins.reduce((sum, input) => {\n            return sum + vectorSize(input.witness);\n          }, 0)\n        : 0)\n    );\n  }\n  clone() {\n    const newTx = new Transaction();\n    newTx.version = this.version;\n    newTx.locktime = this.locktime;\n    newTx.ins = this.ins.map(txIn => {\n      return {\n        hash: txIn.hash,\n        index: txIn.index,\n        script: txIn.script,\n        sequence: txIn.sequence,\n        witness: txIn.witness,\n      };\n    });\n    newTx.outs = this.outs.map(txOut => {\n      return {\n        script: txOut.script,\n        value: txOut.value,\n      };\n    });\n    return newTx;\n  }\n  /**\n   * Hash transaction for signing a specific input.\n   *\n   * Bitcoin uses a different hash for each signed transaction input.\n   * This method copies the transaction, makes the necessary changes based on the\n   * hashType, and then hashes the result.\n   * This hash can then be used to sign the provided transaction input.\n   */\n  hashForSignature(inIndex, prevOutScript, hashType) {\n    v.parse(v.tuple([types.UInt32Schema, types.BufferSchema, v.number()]), [\n      inIndex,\n      prevOutScript,\n      hashType,\n    ]);\n    // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L29\n    if (inIndex >= this.ins.length) return ONE;\n    // ignore OP_CODESEPARATOR\n    const ourScript = bscript.compile(\n      bscript.decompile(prevOutScript).filter(x => {\n        return x !== opcodes.OP_CODESEPARATOR;\n      }),\n    );\n    const txTmp = this.clone();\n    // SIGHASH_NONE: ignore all outputs? (wildcard payee)\n    if ((hashType & 0x1f) === Transaction.SIGHASH_NONE) {\n      txTmp.outs = [];\n      // ignore sequence numbers (except at inIndex)\n      txTmp.ins.forEach((input, i) => {\n        if (i === inIndex) return;\n        input.sequence = 0;\n      });\n      // SIGHASH_SINGLE: ignore all outputs, except at the same index?\n    } else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE) {\n      // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L60\n      if (inIndex >= this.outs.length) return ONE;\n      // truncate outputs after\n      txTmp.outs.length = inIndex + 1;\n      // \"blank\" outputs before\n      for (let i = 0; i < inIndex; i++) {\n        txTmp.outs[i] = BLANK_OUTPUT;\n      }\n      // ignore sequence numbers (except at inIndex)\n      txTmp.ins.forEach((input, y) => {\n        if (y === inIndex) return;\n        input.sequence = 0;\n      });\n    }\n    // SIGHASH_ANYONECANPAY: ignore inputs entirely?\n    if (hashType & Transaction.SIGHASH_ANYONECANPAY) {\n      txTmp.ins = [txTmp.ins[inIndex]];\n      txTmp.ins[0].script = ourScript;\n      // SIGHASH_ALL: only ignore input scripts\n    } else {\n      // \"blank\" others input scripts\n      txTmp.ins.forEach(input => {\n        input.script = EMPTY_BUFFER;\n      });\n      txTmp.ins[inIndex].script = ourScript;\n    }\n    // serialize and hash\n    const buffer = new Uint8Array(txTmp.byteLength(false) + 4);\n    tools.writeInt32(buffer, buffer.length - 4, hashType, 'LE');\n    txTmp.__toBuffer(buffer, 0, false);\n    return bcrypto.hash256(buffer);\n  }\n  hashForWitnessV1(inIndex, prevOutScripts, values, hashType, leafHash, annex) {\n    // https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#common-signature-message\n    v.parse(\n      v.tuple([\n        types.UInt32Schema,\n        v.array(types.BufferSchema),\n        v.array(types.SatoshiSchema),\n        types.UInt32Schema,\n      ]),\n      [inIndex, prevOutScripts, values, hashType],\n    );\n    if (\n      values.length !== this.ins.length ||\n      prevOutScripts.length !== this.ins.length\n    ) {\n      throw new Error('Must supply prevout script and value for all inputs');\n    }\n    const outputType =\n      hashType === Transaction.SIGHASH_DEFAULT\n        ? Transaction.SIGHASH_ALL\n        : hashType & Transaction.SIGHASH_OUTPUT_MASK;\n    const inputType = hashType & Transaction.SIGHASH_INPUT_MASK;\n    const isAnyoneCanPay = inputType === Transaction.SIGHASH_ANYONECANPAY;\n    const isNone = outputType === Transaction.SIGHASH_NONE;\n    const isSingle = outputType === Transaction.SIGHASH_SINGLE;\n    let hashPrevouts = EMPTY_BUFFER;\n    let hashAmounts = EMPTY_BUFFER;\n    let hashScriptPubKeys = EMPTY_BUFFER;\n    let hashSequences = EMPTY_BUFFER;\n    let hashOutputs = EMPTY_BUFFER;\n    if (!isAnyoneCanPay) {\n      let bufferWriter = BufferWriter.withCapacity(36 * this.ins.length);\n      this.ins.forEach(txIn => {\n        bufferWriter.writeSlice(txIn.hash);\n        bufferWriter.writeUInt32(txIn.index);\n      });\n      hashPrevouts = sha256(bufferWriter.end());\n      bufferWriter = BufferWriter.withCapacity(8 * this.ins.length);\n      values.forEach(value => bufferWriter.writeInt64(value));\n      hashAmounts = sha256(bufferWriter.end());\n      bufferWriter = BufferWriter.withCapacity(\n        prevOutScripts.map(varSliceSize).reduce((a, b) => a + b),\n      );\n      prevOutScripts.forEach(prevOutScript =>\n        bufferWriter.writeVarSlice(prevOutScript),\n      );\n      hashScriptPubKeys = sha256(bufferWriter.end());\n      bufferWriter = BufferWriter.withCapacity(4 * this.ins.length);\n      this.ins.forEach(txIn => bufferWriter.writeUInt32(txIn.sequence));\n      hashSequences = sha256(bufferWriter.end());\n    }\n    if (!(isNone || isSingle)) {\n      if (!this.outs.length)\n        throw new Error('Add outputs to the transaction before signing.');\n      const txOutsSize = this.outs\n        .map(output => 8 + varSliceSize(output.script))\n        .reduce((a, b) => a + b);\n      const bufferWriter = BufferWriter.withCapacity(txOutsSize);\n      this.outs.forEach(out => {\n        bufferWriter.writeInt64(out.value);\n        bufferWriter.writeVarSlice(out.script);\n      });\n      hashOutputs = sha256(bufferWriter.end());\n    } else if (isSingle && inIndex < this.outs.length) {\n      const output = this.outs[inIndex];\n      const bufferWriter = BufferWriter.withCapacity(\n        8 + varSliceSize(output.script),\n      );\n      bufferWriter.writeInt64(output.value);\n      bufferWriter.writeVarSlice(output.script);\n      hashOutputs = sha256(bufferWriter.end());\n    }\n    const spendType = (leafHash ? 2 : 0) + (annex ? 1 : 0);\n    // Length calculation from:\n    // https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-14\n    // With extension from:\n    // https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki#signature-validation\n    const sigMsgSize =\n      174 -\n      (isAnyoneCanPay ? 49 : 0) -\n      (isNone ? 32 : 0) +\n      (annex ? 32 : 0) +\n      (leafHash ? 37 : 0);\n    const sigMsgWriter = BufferWriter.withCapacity(sigMsgSize);\n    sigMsgWriter.writeUInt8(hashType);\n    // Transaction\n    sigMsgWriter.writeInt32(this.version);\n    sigMsgWriter.writeUInt32(this.locktime);\n    sigMsgWriter.writeSlice(hashPrevouts);\n    sigMsgWriter.writeSlice(hashAmounts);\n    sigMsgWriter.writeSlice(hashScriptPubKeys);\n    sigMsgWriter.writeSlice(hashSequences);\n    if (!(isNone || isSingle)) {\n      sigMsgWriter.writeSlice(hashOutputs);\n    }\n    // Input\n    sigMsgWriter.writeUInt8(spendType);\n    if (isAnyoneCanPay) {\n      const input = this.ins[inIndex];\n      sigMsgWriter.writeSlice(input.hash);\n      sigMsgWriter.writeUInt32(input.index);\n      sigMsgWriter.writeInt64(values[inIndex]);\n      sigMsgWriter.writeVarSlice(prevOutScripts[inIndex]);\n      sigMsgWriter.writeUInt32(input.sequence);\n    } else {\n      sigMsgWriter.writeUInt32(inIndex);\n    }\n    if (annex) {\n      const bufferWriter = BufferWriter.withCapacity(varSliceSize(annex));\n      bufferWriter.writeVarSlice(annex);\n      sigMsgWriter.writeSlice(sha256(bufferWriter.end()));\n    }\n    // Output\n    if (isSingle) {\n      sigMsgWriter.writeSlice(hashOutputs);\n    }\n    // BIP342 extension\n    if (leafHash) {\n      sigMsgWriter.writeSlice(leafHash);\n      sigMsgWriter.writeUInt8(0);\n      sigMsgWriter.writeUInt32(0xffffffff);\n    }\n    // Extra zero byte because:\n    // https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-19\n    return bcrypto.taggedHash(\n      'TapSighash',\n      tools.concat([Uint8Array.from([0x00]), sigMsgWriter.end()]),\n    );\n  }\n  hashForWitnessV0(inIndex, prevOutScript, value, hashType) {\n    v.parse(\n      v.tuple([\n        types.UInt32Schema,\n        types.BufferSchema,\n        types.SatoshiSchema,\n        types.UInt32Schema,\n      ]),\n      [inIndex, prevOutScript, value, hashType],\n    );\n    let tbuffer = Uint8Array.from([]);\n    let bufferWriter;\n    let hashOutputs = ZERO;\n    let hashPrevouts = ZERO;\n    let hashSequence = ZERO;\n    if (!(hashType & Transaction.SIGHASH_ANYONECANPAY)) {\n      tbuffer = new Uint8Array(36 * this.ins.length);\n      bufferWriter = new BufferWriter(tbuffer, 0);\n      this.ins.forEach(txIn => {\n        bufferWriter.writeSlice(txIn.hash);\n        bufferWriter.writeUInt32(txIn.index);\n      });\n      hashPrevouts = bcrypto.hash256(tbuffer);\n    }\n    if (\n      !(hashType & Transaction.SIGHASH_ANYONECANPAY) &&\n      (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&\n      (hashType & 0x1f) !== Transaction.SIGHASH_NONE\n    ) {\n      tbuffer = new Uint8Array(4 * this.ins.length);\n      bufferWriter = new BufferWriter(tbuffer, 0);\n      this.ins.forEach(txIn => {\n        bufferWriter.writeUInt32(txIn.sequence);\n      });\n      hashSequence = bcrypto.hash256(tbuffer);\n    }\n    if (\n      (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&\n      (hashType & 0x1f) !== Transaction.SIGHASH_NONE\n    ) {\n      const txOutsSize = this.outs.reduce((sum, output) => {\n        return sum + 8 + varSliceSize(output.script);\n      }, 0);\n      tbuffer = new Uint8Array(txOutsSize);\n      bufferWriter = new BufferWriter(tbuffer, 0);\n      this.outs.forEach(out => {\n        bufferWriter.writeInt64(out.value);\n        bufferWriter.writeVarSlice(out.script);\n      });\n      hashOutputs = bcrypto.hash256(tbuffer);\n    } else if (\n      (hashType & 0x1f) === Transaction.SIGHASH_SINGLE &&\n      inIndex < this.outs.length\n    ) {\n      const output = this.outs[inIndex];\n      tbuffer = new Uint8Array(8 + varSliceSize(output.script));\n      bufferWriter = new BufferWriter(tbuffer, 0);\n      bufferWriter.writeInt64(output.value);\n      bufferWriter.writeVarSlice(output.script);\n      hashOutputs = bcrypto.hash256(tbuffer);\n    }\n    tbuffer = new Uint8Array(156 + varSliceSize(prevOutScript));\n    bufferWriter = new BufferWriter(tbuffer, 0);\n    const input = this.ins[inIndex];\n    bufferWriter.writeInt32(this.version);\n    bufferWriter.writeSlice(hashPrevouts);\n    bufferWriter.writeSlice(hashSequence);\n    bufferWriter.writeSlice(input.hash);\n    bufferWriter.writeUInt32(input.index);\n    bufferWriter.writeVarSlice(prevOutScript);\n    bufferWriter.writeInt64(value);\n    bufferWriter.writeUInt32(input.sequence);\n    bufferWriter.writeSlice(hashOutputs);\n    bufferWriter.writeUInt32(this.locktime);\n    bufferWriter.writeUInt32(hashType);\n    return bcrypto.hash256(tbuffer);\n  }\n  getHash(forWitness) {\n    // wtxid for coinbase is always 32 bytes of 0x00\n    if (forWitness && this.isCoinbase()) return new Uint8Array(32);\n    return bcrypto.hash256(this.__toBuffer(undefined, undefined, forWitness));\n  }\n  getId() {\n    // transaction hash's are displayed in reverse order\n    return tools.toHex(reverseBuffer(this.getHash(false)));\n  }\n  toBuffer(buffer, initialOffset) {\n    return this.__toBuffer(buffer, initialOffset, true);\n  }\n  toHex() {\n    return tools.toHex(this.toBuffer(undefined, undefined));\n  }\n  setInputScript(index, scriptSig) {\n    v.parse(v.tuple([v.number(), types.BufferSchema]), [index, scriptSig]);\n    this.ins[index].script = scriptSig;\n  }\n  setWitness(index, witness) {\n    v.parse(v.tuple([v.number(), v.array(types.BufferSchema)]), [\n      index,\n      witness,\n    ]);\n    this.ins[index].witness = witness;\n  }\n  __toBuffer(buffer, initialOffset, _ALLOW_WITNESS = false) {\n    if (!buffer) buffer = new Uint8Array(this.byteLength(_ALLOW_WITNESS));\n    const bufferWriter = new BufferWriter(buffer, initialOffset || 0);\n    bufferWriter.writeInt32(this.version);\n    const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();\n    if (hasWitnesses) {\n      bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_MARKER);\n      bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_FLAG);\n    }\n    bufferWriter.writeVarInt(this.ins.length);\n    this.ins.forEach(txIn => {\n      bufferWriter.writeSlice(txIn.hash);\n      bufferWriter.writeUInt32(txIn.index);\n      bufferWriter.writeVarSlice(txIn.script);\n      bufferWriter.writeUInt32(txIn.sequence);\n    });\n    bufferWriter.writeVarInt(this.outs.length);\n    this.outs.forEach(txOut => {\n      if (isOutput(txOut)) {\n        bufferWriter.writeInt64(txOut.value);\n      } else {\n        bufferWriter.writeSlice(txOut.valueBuffer);\n      }\n      bufferWriter.writeVarSlice(txOut.script);\n    });\n    if (hasWitnesses) {\n      this.ins.forEach(input => {\n        bufferWriter.writeVector(input.witness);\n      });\n    }\n    bufferWriter.writeUInt32(this.locktime);\n    // avoid slicing unless necessary\n    if (initialOffset !== undefined)\n      return buffer.slice(initialOffset, bufferWriter.offset);\n    return buffer;\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3857, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3863, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bitcoinjs-lib/src/esm/block.js"],"sourcesContent":["import {\n  BufferReader,\n  BufferWriter,\n  reverseBuffer,\n  varuint,\n} from './bufferutils.js';\nimport * as bcrypto from './crypto.js';\nimport { fastMerkleRoot } from './merkle.js';\nimport { Transaction } from './transaction.js';\nimport * as v from 'valibot';\nimport * as tools from 'uint8array-tools';\nconst errorMerkleNoTxes = new TypeError(\n  'Cannot compute merkle root for zero transactions',\n);\nconst errorWitnessNotSegwit = new TypeError(\n  'Cannot compute witness commit for non-segwit block',\n);\nexport class Block {\n  static fromBuffer(buffer) {\n    if (buffer.length < 80) throw new Error('Buffer too small (< 80 bytes)');\n    const bufferReader = new BufferReader(buffer);\n    const block = new Block();\n    block.version = bufferReader.readInt32();\n    block.prevHash = bufferReader.readSlice(32);\n    block.merkleRoot = bufferReader.readSlice(32);\n    block.timestamp = bufferReader.readUInt32();\n    block.bits = bufferReader.readUInt32();\n    block.nonce = bufferReader.readUInt32();\n    if (buffer.length === 80) return block;\n    const readTransaction = () => {\n      const tx = Transaction.fromBuffer(\n        bufferReader.buffer.slice(bufferReader.offset),\n        true,\n      );\n      bufferReader.offset += tx.byteLength();\n      return tx;\n    };\n    const nTransactions = bufferReader.readVarInt();\n    block.transactions = [];\n    for (let i = 0; i < nTransactions; ++i) {\n      const tx = readTransaction();\n      block.transactions.push(tx);\n    }\n    const witnessCommit = block.getWitnessCommit();\n    // This Block contains a witness commit\n    if (witnessCommit) block.witnessCommit = witnessCommit;\n    return block;\n  }\n  static fromHex(hex) {\n    return Block.fromBuffer(tools.fromHex(hex));\n  }\n  static calculateTarget(bits) {\n    const exponent = ((bits & 0xff000000) >> 24) - 3;\n    const mantissa = bits & 0x007fffff;\n    const target = new Uint8Array(32);\n    target[29 - exponent] = (mantissa >> 16) & 0xff;\n    target[30 - exponent] = (mantissa >> 8) & 0xff;\n    target[31 - exponent] = mantissa & 0xff;\n    return target;\n  }\n  static calculateMerkleRoot(transactions, forWitness) {\n    v.parse(v.array(v.object({ getHash: v.function() })), transactions);\n    if (transactions.length === 0) throw errorMerkleNoTxes;\n    if (forWitness && !txesHaveWitnessCommit(transactions))\n      throw errorWitnessNotSegwit;\n    const hashes = transactions.map(transaction =>\n      transaction.getHash(forWitness),\n    );\n    const rootHash = fastMerkleRoot(hashes, bcrypto.hash256);\n    return forWitness\n      ? bcrypto.hash256(\n          tools.concat([rootHash, transactions[0].ins[0].witness[0]]),\n        )\n      : rootHash;\n  }\n  version = 1;\n  prevHash = undefined;\n  merkleRoot = undefined;\n  timestamp = 0;\n  witnessCommit = undefined;\n  bits = 0;\n  nonce = 0;\n  transactions = undefined;\n  getWitnessCommit() {\n    if (!txesHaveWitnessCommit(this.transactions)) return null;\n    // The merkle root for the witness data is in an OP_RETURN output.\n    // There is no rule for the index of the output, so use filter to find it.\n    // The root is prepended with 0xaa21a9ed so check for 0x6a24aa21a9ed\n    // If multiple commits are found, the output with highest index is assumed.\n    const witnessCommits = this.transactions[0].outs\n      .filter(\n        out =>\n          tools.compare(\n            out.script.slice(0, 6),\n            Uint8Array.from([0x6a, 0x24, 0xaa, 0x21, 0xa9, 0xed]),\n          ) === 0,\n      )\n      .map(out => out.script.slice(6, 38));\n    if (witnessCommits.length === 0) return null;\n    // Use the commit with the highest output (should only be one though)\n    const result = witnessCommits[witnessCommits.length - 1];\n    if (!(result instanceof Uint8Array && result.length === 32)) return null;\n    return result;\n  }\n  hasWitnessCommit() {\n    if (\n      this.witnessCommit instanceof Uint8Array &&\n      this.witnessCommit.length === 32\n    )\n      return true;\n    if (this.getWitnessCommit() !== null) return true;\n    return false;\n  }\n  hasWitness() {\n    return anyTxHasWitness(this.transactions);\n  }\n  weight() {\n    const base = this.byteLength(false, false);\n    const total = this.byteLength(false, true);\n    return base * 3 + total;\n  }\n  byteLength(headersOnly, allowWitness = true) {\n    if (headersOnly || !this.transactions) return 80;\n    return (\n      80 +\n      varuint.encodingLength(this.transactions.length) +\n      this.transactions.reduce((a, x) => a + x.byteLength(allowWitness), 0)\n    );\n  }\n  getHash() {\n    return bcrypto.hash256(this.toBuffer(true));\n  }\n  getId() {\n    return tools.toHex(reverseBuffer(this.getHash()));\n  }\n  getUTCDate() {\n    const date = new Date(0); // epoch\n    date.setUTCSeconds(this.timestamp);\n    return date;\n  }\n  // TODO: buffer, offset compatibility\n  toBuffer(headersOnly) {\n    const buffer = new Uint8Array(this.byteLength(headersOnly));\n    const bufferWriter = new BufferWriter(buffer);\n    bufferWriter.writeInt32(this.version);\n    bufferWriter.writeSlice(this.prevHash);\n    bufferWriter.writeSlice(this.merkleRoot);\n    bufferWriter.writeUInt32(this.timestamp);\n    bufferWriter.writeUInt32(this.bits);\n    bufferWriter.writeUInt32(this.nonce);\n    if (headersOnly || !this.transactions) return buffer;\n    const { bytes } = varuint.encode(\n      this.transactions.length,\n      buffer,\n      bufferWriter.offset,\n    );\n    bufferWriter.offset += bytes;\n    this.transactions.forEach(tx => {\n      const txSize = tx.byteLength(); // TODO: extract from toBuffer?\n      tx.toBuffer(buffer, bufferWriter.offset);\n      bufferWriter.offset += txSize;\n    });\n    return buffer;\n  }\n  toHex(headersOnly) {\n    return tools.toHex(this.toBuffer(headersOnly));\n  }\n  checkTxRoots() {\n    // If the Block has segwit transactions but no witness commit,\n    // there's no way it can be valid, so fail the check.\n    const hasWitnessCommit = this.hasWitnessCommit();\n    if (!hasWitnessCommit && this.hasWitness()) return false;\n    return (\n      this.__checkMerkleRoot() &&\n      (hasWitnessCommit ? this.__checkWitnessCommit() : true)\n    );\n  }\n  checkProofOfWork() {\n    const hash = reverseBuffer(this.getHash());\n    const target = Block.calculateTarget(this.bits);\n    return tools.compare(hash, target) <= 0;\n  }\n  __checkMerkleRoot() {\n    if (!this.transactions) throw errorMerkleNoTxes;\n    const actualMerkleRoot = Block.calculateMerkleRoot(this.transactions);\n    return tools.compare(this.merkleRoot, actualMerkleRoot) === 0;\n  }\n  __checkWitnessCommit() {\n    if (!this.transactions) throw errorMerkleNoTxes;\n    if (!this.hasWitnessCommit()) throw errorWitnessNotSegwit;\n    const actualWitnessCommit = Block.calculateMerkleRoot(\n      this.transactions,\n      true,\n    );\n    return tools.compare(this.witnessCommit, actualWitnessCommit) === 0;\n  }\n}\nfunction txesHaveWitnessCommit(transactions) {\n  return (\n    transactions instanceof Array &&\n    transactions[0] &&\n    transactions[0].ins &&\n    transactions[0].ins instanceof Array &&\n    transactions[0].ins[0] &&\n    transactions[0].ins[0].witness &&\n    transactions[0].ins[0].witness instanceof Array &&\n    transactions[0].ins[0].witness.length > 0\n  );\n}\nfunction anyTxHasWitness(transactions) {\n  return (\n    transactions instanceof Array &&\n    transactions.some(\n      tx =>\n        typeof tx === 'object' &&\n        tx.ins instanceof Array &&\n        tx.ins.some(\n          input =>\n            typeof input === 'object' &&\n            input.witness instanceof Array &&\n            input.witness.length > 0,\n        ),\n    )\n  );\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4044, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4050, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bitcoinjs-lib/src/esm/psbt/psbtutils.js"],"sourcesContent":["import * as varuint from 'varuint-bitcoin';\nimport * as bscript from '../script.js';\nimport { Transaction } from '../transaction.js';\nimport { hash160 } from '../crypto.js';\nimport * as payments from '../payments/index.js';\nimport * as tools from 'uint8array-tools';\n/**\n * Checks if a given payment factory can generate a payment script from a given script.\n * @param payment The payment factory to check.\n * @returns A function that takes a script and returns a boolean indicating whether the payment factory can generate a payment script from the script.\n */\nfunction isPaymentFactory(payment) {\n  return script => {\n    try {\n      payment({ output: script });\n      return true;\n    } catch (err) {\n      return false;\n    }\n  };\n}\nexport const isP2MS = isPaymentFactory(payments.p2ms);\nexport const isP2PK = isPaymentFactory(payments.p2pk);\nexport const isP2PKH = isPaymentFactory(payments.p2pkh);\nexport const isP2WPKH = isPaymentFactory(payments.p2wpkh);\nexport const isP2WSHScript = isPaymentFactory(payments.p2wsh);\nexport const isP2SHScript = isPaymentFactory(payments.p2sh);\nexport const isP2TR = isPaymentFactory(payments.p2tr);\n/**\n * Converts a witness stack to a script witness.\n * @param witness The witness stack to convert.\n * @returns The script witness as a Buffer.\n */\nexport function witnessStackToScriptWitness(witness) {\n  let buffer = new Uint8Array(0);\n  function writeSlice(slice) {\n    buffer = tools.concat([buffer, slice]);\n  }\n  function writeVarInt(i) {\n    const currentLen = buffer.length;\n    const varintLen = varuint.encodingLength(i);\n    buffer = tools.concat([buffer, new Uint8Array(varintLen)]);\n    varuint.encode(i, buffer, currentLen);\n  }\n  function writeVarSlice(slice) {\n    writeVarInt(slice.length);\n    writeSlice(slice);\n  }\n  function writeVector(vector) {\n    writeVarInt(vector.length);\n    vector.forEach(writeVarSlice);\n  }\n  writeVector(witness);\n  return buffer;\n}\n/**\n * Finds the position of a public key in a script.\n * @param pubkey The public key to search for.\n * @param script The script to search in.\n * @returns The index of the public key in the script, or -1 if not found.\n * @throws {Error} If there is an unknown script error.\n */\nexport function pubkeyPositionInScript(pubkey, script) {\n  const pubkeyHash = hash160(pubkey);\n  const pubkeyXOnly = pubkey.slice(1, 33); // slice before calling?\n  const decompiled = bscript.decompile(script);\n  if (decompiled === null) throw new Error('Unknown script error');\n  return decompiled.findIndex(element => {\n    if (typeof element === 'number') return false;\n    return (\n      tools.compare(pubkey, element) === 0 ||\n      tools.compare(pubkeyHash, element) === 0 ||\n      tools.compare(pubkeyXOnly, element) === 0\n    );\n  });\n}\n/**\n * Checks if a public key is present in a script.\n * @param pubkey The public key to check.\n * @param script The script to search in.\n * @returns A boolean indicating whether the public key is present in the script.\n */\nexport function pubkeyInScript(pubkey, script) {\n  return pubkeyPositionInScript(pubkey, script) !== -1;\n}\n/**\n * Checks if an input contains a signature for a specific action.\n * @param input - The input to check.\n * @param action - The action to check for.\n * @returns A boolean indicating whether the input contains a signature for the specified action.\n */\nexport function checkInputForSig(input, action) {\n  const pSigs = extractPartialSigs(input);\n  return pSigs.some(pSig =>\n    signatureBlocksAction(pSig, bscript.signature.decode, action),\n  );\n}\n/**\n * Determines if a given action is allowed for a signature block.\n * @param signature - The signature block.\n * @param signatureDecodeFn - The function used to decode the signature.\n * @param action - The action to be checked.\n * @returns True if the action is allowed, false otherwise.\n */\nexport function signatureBlocksAction(signature, signatureDecodeFn, action) {\n  const { hashType } = signatureDecodeFn(signature);\n  const whitelist = [];\n  const isAnyoneCanPay = hashType & Transaction.SIGHASH_ANYONECANPAY;\n  if (isAnyoneCanPay) whitelist.push('addInput');\n  const hashMod = hashType & 0x1f;\n  switch (hashMod) {\n    case Transaction.SIGHASH_ALL:\n      break;\n    case Transaction.SIGHASH_SINGLE:\n    case Transaction.SIGHASH_NONE:\n      whitelist.push('addOutput');\n      whitelist.push('setInputSequence');\n      break;\n  }\n  if (whitelist.indexOf(action) === -1) {\n    return true;\n  }\n  return false;\n}\n/**\n * Extracts the signatures from a PsbtInput object.\n * If the input has partial signatures, it returns an array of the signatures.\n * If the input does not have partial signatures, it checks if it has a finalScriptSig or finalScriptWitness.\n * If it does, it extracts the signatures from the final scripts and returns them.\n * If none of the above conditions are met, it returns an empty array.\n *\n * @param input - The PsbtInput object from which to extract the signatures.\n * @returns An array of signatures extracted from the PsbtInput object.\n */\nfunction extractPartialSigs(input) {\n  let pSigs = [];\n  if ((input.partialSig || []).length === 0) {\n    if (!input.finalScriptSig && !input.finalScriptWitness) return [];\n    pSigs = getPsigsFromInputFinalScripts(input);\n  } else {\n    pSigs = input.partialSig;\n  }\n  return pSigs.map(p => p.signature);\n}\n/**\n * Retrieves the partial signatures (Psigs) from the input's final scripts.\n * Psigs are extracted from both the final scriptSig and final scriptWitness of the input.\n * Only canonical script signatures are considered.\n *\n * @param input - The PsbtInput object representing the input.\n * @returns An array of PartialSig objects containing the extracted Psigs.\n */\nfunction getPsigsFromInputFinalScripts(input) {\n  const scriptItems = !input.finalScriptSig\n    ? []\n    : bscript.decompile(input.finalScriptSig) || [];\n  const witnessItems = !input.finalScriptWitness\n    ? []\n    : bscript.decompile(input.finalScriptWitness) || [];\n  return scriptItems\n    .concat(witnessItems)\n    .filter(item => {\n      return (\n        item instanceof Uint8Array && bscript.isCanonicalScriptSignature(item)\n      );\n    })\n    .map(sig => ({ signature: sig }));\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4201, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4207, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bitcoinjs-lib/src/esm/psbt/bip371.js"],"sourcesContent":["import { isTapleaf, isTaptree } from '../types.js';\nimport { Transaction } from '../transaction.js';\nimport {\n  witnessStackToScriptWitness,\n  pubkeyPositionInScript,\n  isP2TR,\n} from './psbtutils.js';\nimport {\n  tweakKey,\n  tapleafHash,\n  rootHashFromPath,\n  LEAF_VERSION_TAPSCRIPT,\n  MAX_TAPTREE_DEPTH,\n} from '../payments/bip341.js';\nimport { p2tr } from '../payments/index.js';\nimport * as tools from 'uint8array-tools';\nimport { signatureBlocksAction } from './psbtutils.js';\n/**\n * Converts a public key to an X-only public key.\n * @param pubKey The public key to convert.\n * @returns The X-only public key.\n */\nexport const toXOnly = pubKey =>\n  pubKey.length === 32 ? pubKey : pubKey.slice(1, 33);\n/**\n * Default tapscript finalizer. It searches for the `tapLeafHashToFinalize` if provided.\n * Otherwise it will search for the tapleaf that has at least one signature and has the shortest path.\n * @param inputIndex the position of the PSBT input.\n * @param input the PSBT input.\n * @param tapLeafHashToFinalize optional, if provided the finalizer will search for a tapleaf that has this hash\n *                              and will try to build the finalScriptWitness.\n * @returns the finalScriptWitness or throws an exception if no tapleaf found.\n */\nexport function tapScriptFinalizer(inputIndex, input, tapLeafHashToFinalize) {\n  const tapLeaf = findTapLeafToFinalize(\n    input,\n    inputIndex,\n    tapLeafHashToFinalize,\n  );\n  try {\n    const sigs = sortSignatures(input, tapLeaf);\n    const witness = sigs.concat(tapLeaf.script).concat(tapLeaf.controlBlock);\n    return { finalScriptWitness: witnessStackToScriptWitness(witness) };\n  } catch (err) {\n    throw new Error(`Can not finalize taproot input #${inputIndex}: ${err}`);\n  }\n}\n/**\n * Serializes a taproot signature.\n * @param sig The signature to serialize.\n * @param sighashType The sighash type. Optional.\n * @returns The serialized taproot signature.\n */\nexport function serializeTaprootSignature(sig, sighashType) {\n  const sighashTypeByte = sighashType\n    ? Uint8Array.from([sighashType])\n    : Uint8Array.from([]);\n  return tools.concat([sig, sighashTypeByte]);\n}\n/**\n * Checks if a PSBT input is a taproot input.\n * @param input The PSBT input to check.\n * @returns True if the input is a taproot input, false otherwise.\n */\nexport function isTaprootInput(input) {\n  return (\n    input &&\n    !!(\n      input.tapInternalKey ||\n      input.tapMerkleRoot ||\n      (input.tapLeafScript && input.tapLeafScript.length) ||\n      (input.tapBip32Derivation && input.tapBip32Derivation.length) ||\n      (input.witnessUtxo && isP2TR(input.witnessUtxo.script))\n    )\n  );\n}\n/**\n * Checks if a PSBT output is a taproot output.\n * @param output The PSBT output to check.\n * @param script The script to check. Optional.\n * @returns True if the output is a taproot output, false otherwise.\n */\nexport function isTaprootOutput(output, script) {\n  return (\n    output &&\n    !!(\n      output.tapInternalKey ||\n      output.tapTree ||\n      (output.tapBip32Derivation && output.tapBip32Derivation.length) ||\n      (script && isP2TR(script))\n    )\n  );\n}\n/**\n * Checks the taproot input fields for consistency.\n * @param inputData The original input data.\n * @param newInputData The new input data.\n * @param action The action being performed.\n * @throws Throws an error if the input fields are inconsistent.\n */\nexport function checkTaprootInputFields(inputData, newInputData, action) {\n  checkMixedTaprootAndNonTaprootInputFields(inputData, newInputData, action);\n  checkIfTapLeafInTree(inputData, newInputData, action);\n}\n/**\n * Checks the taproot output fields for consistency.\n * @param outputData The original output data.\n * @param newOutputData The new output data.\n * @param action The action being performed.\n * @throws Throws an error if the output fields are inconsistent.\n */\nexport function checkTaprootOutputFields(outputData, newOutputData, action) {\n  checkMixedTaprootAndNonTaprootOutputFields(outputData, newOutputData, action);\n  checkTaprootScriptPubkey(outputData, newOutputData);\n}\nfunction checkTaprootScriptPubkey(outputData, newOutputData) {\n  if (!newOutputData.tapTree && !newOutputData.tapInternalKey) return;\n  const tapInternalKey =\n    newOutputData.tapInternalKey || outputData.tapInternalKey;\n  const tapTree = newOutputData.tapTree || outputData.tapTree;\n  if (tapInternalKey) {\n    const { script: scriptPubkey } = outputData;\n    const script = getTaprootScripPubkey(tapInternalKey, tapTree);\n    if (scriptPubkey && tools.compare(script, scriptPubkey) !== 0)\n      throw new Error('Error adding output. Script or address mismatch.');\n  }\n}\n/**\n * Returns the Taproot script public key.\n *\n * @param tapInternalKey - The Taproot internal key.\n * @param tapTree - The Taproot tree (optional).\n * @returns The Taproot script public key.\n */\nfunction getTaprootScripPubkey(tapInternalKey, tapTree) {\n  const scriptTree = tapTree && tapTreeFromList(tapTree.leaves);\n  const { output } = p2tr({\n    internalPubkey: tapInternalKey,\n    scriptTree,\n  });\n  return output;\n}\n/**\n * Tweak the internal public key for a specific input.\n * @param inputIndex - The index of the input.\n * @param input - The PsbtInput object representing the input.\n * @returns The tweaked internal public key.\n * @throws Error if the tap internal key cannot be tweaked.\n */\nexport function tweakInternalPubKey(inputIndex, input) {\n  const tapInternalKey = input.tapInternalKey;\n  const outputKey =\n    tapInternalKey && tweakKey(tapInternalKey, input.tapMerkleRoot);\n  if (!outputKey)\n    throw new Error(\n      `Cannot tweak tap internal key for input #${inputIndex}. Public key: ${\n        // tapInternalKey && tapInternalKey.toString('hex')\n        tapInternalKey && tools.toHex(tapInternalKey)\n      }`,\n    );\n  return outputKey.x;\n}\n/**\n * Convert a binary tree to a BIP371 type list. Each element of the list is (according to BIP371):\n * One or more tuples representing the depth, leaf version, and script for a leaf in the Taproot tree,\n * allowing the entire tree to be reconstructed. The tuples must be in depth first search order so that\n * the tree is correctly reconstructed.\n * @param tree the binary tap tree\n * @returns a list of BIP 371 tapleaves\n */\nexport function tapTreeToList(tree) {\n  if (!isTaptree(tree))\n    throw new Error(\n      'Cannot convert taptree to tapleaf list. Expecting a tapree structure.',\n    );\n  return _tapTreeToList(tree);\n}\n/**\n * Convert a BIP371 TapLeaf list to a TapTree (binary).\n * @param leaves a list of tapleaves where each element of the list is (according to BIP371):\n * One or more tuples representing the depth, leaf version, and script for a leaf in the Taproot tree,\n * allowing the entire tree to be reconstructed. The tuples must be in depth first search order so that\n * the tree is correctly reconstructed.\n * @returns the corresponding taptree, or throws an exception if the tree cannot be reconstructed\n */\nexport function tapTreeFromList(leaves = []) {\n  if (leaves.length === 1 && leaves[0].depth === 0)\n    return {\n      output: leaves[0].script,\n      version: leaves[0].leafVersion,\n    };\n  return instertLeavesInTree(leaves);\n}\n/**\n * Checks the taproot input for signatures.\n * @param input The PSBT input to check.\n * @param action The action being performed.\n * @returns True if the input has taproot signatures, false otherwise.\n */\nexport function checkTaprootInputForSigs(input, action) {\n  const sigs = extractTaprootSigs(input);\n  return sigs.some(sig =>\n    signatureBlocksAction(sig, decodeSchnorrSignature, action),\n  );\n}\n/**\n * Decodes a Schnorr signature.\n * @param signature The signature to decode.\n * @returns The decoded Schnorr signature.\n */\nfunction decodeSchnorrSignature(signature) {\n  return {\n    signature: signature.slice(0, 64),\n    hashType: signature.slice(64)[0] || Transaction.SIGHASH_DEFAULT,\n  };\n}\n/**\n * Extracts taproot signatures from a PSBT input.\n * @param input The PSBT input to extract signatures from.\n * @returns An array of taproot signatures.\n */\nfunction extractTaprootSigs(input) {\n  const sigs = [];\n  if (input.tapKeySig) sigs.push(input.tapKeySig);\n  if (input.tapScriptSig)\n    sigs.push(...input.tapScriptSig.map(s => s.signature));\n  if (!sigs.length) {\n    const finalTapKeySig = getTapKeySigFromWithness(input.finalScriptWitness);\n    if (finalTapKeySig) sigs.push(finalTapKeySig);\n  }\n  return sigs;\n}\n/**\n * Gets the taproot signature from the witness.\n * @param finalScriptWitness The final script witness.\n * @returns The taproot signature, or undefined if not found.\n */\nfunction getTapKeySigFromWithness(finalScriptWitness) {\n  if (!finalScriptWitness) return;\n  const witness = finalScriptWitness.slice(2);\n  // todo: add schnorr signature validation\n  if (witness.length === 64 || witness.length === 65) return witness;\n}\n/**\n * Converts a binary tree to a BIP371 type list.\n * @param tree The binary tap tree.\n * @param leaves A list of tapleaves. Optional.\n * @param depth The current depth. Optional.\n * @returns A list of BIP 371 tapleaves.\n * @throws Throws an error if the taptree cannot be converted to a tapleaf list.\n */\nfunction _tapTreeToList(tree, leaves = [], depth = 0) {\n  if (depth > MAX_TAPTREE_DEPTH) throw new Error('Max taptree depth exceeded.');\n  if (!tree) return [];\n  if (isTapleaf(tree)) {\n    leaves.push({\n      depth,\n      leafVersion: tree.version || LEAF_VERSION_TAPSCRIPT,\n      script: tree.output,\n    });\n    return leaves;\n  }\n  if (tree[0]) _tapTreeToList(tree[0], leaves, depth + 1);\n  if (tree[1]) _tapTreeToList(tree[1], leaves, depth + 1);\n  return leaves;\n}\n/**\n * Inserts the tapleaves into the taproot tree.\n * @param leaves The tapleaves to insert.\n * @returns The taproot tree.\n * @throws Throws an error if there is no room left to insert a tapleaf in the tree.\n */\nfunction instertLeavesInTree(leaves) {\n  let tree;\n  for (const leaf of leaves) {\n    tree = instertLeafInTree(leaf, tree);\n    if (!tree) throw new Error(`No room left to insert tapleaf in tree`);\n  }\n  return tree;\n}\n/**\n * Inserts a tapleaf into the taproot tree.\n * @param leaf The tapleaf to insert.\n * @param tree The taproot tree.\n * @param depth The current depth. Optional.\n * @returns The updated taproot tree.\n */\nfunction instertLeafInTree(leaf, tree, depth = 0) {\n  if (depth > MAX_TAPTREE_DEPTH) throw new Error('Max taptree depth exceeded.');\n  if (leaf.depth === depth) {\n    if (!tree)\n      return {\n        output: leaf.script,\n        version: leaf.leafVersion,\n      };\n    return;\n  }\n  if (isTapleaf(tree)) return;\n  const leftSide = instertLeafInTree(leaf, tree && tree[0], depth + 1);\n  if (leftSide) return [leftSide, tree && tree[1]];\n  const rightSide = instertLeafInTree(leaf, tree && tree[1], depth + 1);\n  if (rightSide) return [tree && tree[0], rightSide];\n}\n/**\n * Checks the input fields for mixed taproot and non-taproot fields.\n * @param inputData The original input data.\n * @param newInputData The new input data.\n * @param action The action being performed.\n * @throws Throws an error if the input fields are inconsistent.\n */\nfunction checkMixedTaprootAndNonTaprootInputFields(\n  inputData,\n  newInputData,\n  action,\n) {\n  const isBadTaprootUpdate =\n    isTaprootInput(inputData) && hasNonTaprootFields(newInputData);\n  const isBadNonTaprootUpdate =\n    hasNonTaprootFields(inputData) && isTaprootInput(newInputData);\n  const hasMixedFields =\n    inputData === newInputData &&\n    isTaprootInput(newInputData) &&\n    hasNonTaprootFields(newInputData); // todo: bad? use !===\n  if (isBadTaprootUpdate || isBadNonTaprootUpdate || hasMixedFields)\n    throw new Error(\n      `Invalid arguments for Psbt.${action}. ` +\n        `Cannot use both taproot and non-taproot fields.`,\n    );\n}\n/**\n * Checks the output fields for mixed taproot and non-taproot fields.\n * @param inputData The original output data.\n * @param newInputData The new output data.\n * @param action The action being performed.\n * @throws Throws an error if the output fields are inconsistent.\n */\nfunction checkMixedTaprootAndNonTaprootOutputFields(\n  inputData,\n  newInputData,\n  action,\n) {\n  const isBadTaprootUpdate =\n    isTaprootOutput(inputData) && hasNonTaprootFields(newInputData);\n  const isBadNonTaprootUpdate =\n    hasNonTaprootFields(inputData) && isTaprootOutput(newInputData);\n  const hasMixedFields =\n    inputData === newInputData &&\n    isTaprootOutput(newInputData) &&\n    hasNonTaprootFields(newInputData);\n  if (isBadTaprootUpdate || isBadNonTaprootUpdate || hasMixedFields)\n    throw new Error(\n      `Invalid arguments for Psbt.${action}. ` +\n        `Cannot use both taproot and non-taproot fields.`,\n    );\n}\n/**\n * Checks if the tap leaf is part of the tap tree for the given input data.\n * Throws an error if the tap leaf is not part of the tap tree.\n * @param inputData - The original PsbtInput data.\n * @param newInputData - The new PsbtInput data.\n * @param action - The action being performed.\n * @throws {Error} - If the tap leaf is not part of the tap tree.\n */\nfunction checkIfTapLeafInTree(inputData, newInputData, action) {\n  if (newInputData.tapMerkleRoot) {\n    const newLeafsInTree = (newInputData.tapLeafScript || []).every(l =>\n      isTapLeafInTree(l, newInputData.tapMerkleRoot),\n    );\n    const oldLeafsInTree = (inputData.tapLeafScript || []).every(l =>\n      isTapLeafInTree(l, newInputData.tapMerkleRoot),\n    );\n    if (!newLeafsInTree || !oldLeafsInTree)\n      throw new Error(\n        `Invalid arguments for Psbt.${action}. Tapleaf not part of taptree.`,\n      );\n  } else if (inputData.tapMerkleRoot) {\n    const newLeafsInTree = (newInputData.tapLeafScript || []).every(l =>\n      isTapLeafInTree(l, inputData.tapMerkleRoot),\n    );\n    if (!newLeafsInTree)\n      throw new Error(\n        `Invalid arguments for Psbt.${action}. Tapleaf not part of taptree.`,\n      );\n  }\n}\n/**\n * Checks if a TapLeafScript is present in a Merkle tree.\n * @param tapLeaf The TapLeafScript to check.\n * @param merkleRoot The Merkle root of the tree. If not provided, the function assumes the TapLeafScript is present.\n * @returns A boolean indicating whether the TapLeafScript is present in the tree.\n */\nfunction isTapLeafInTree(tapLeaf, merkleRoot) {\n  if (!merkleRoot) return true;\n  const leafHash = tapleafHash({\n    output: tapLeaf.script,\n    version: tapLeaf.leafVersion,\n  });\n  const rootHash = rootHashFromPath(tapLeaf.controlBlock, leafHash);\n  return tools.compare(rootHash, merkleRoot) === 0;\n}\n/**\n * Sorts the signatures in the input's tapScriptSig array based on their position in the tapLeaf script.\n *\n * @param input - The PsbtInput object.\n * @param tapLeaf - The TapLeafScript object.\n * @returns An array of sorted signatures as Buffers.\n */\nfunction sortSignatures(input, tapLeaf) {\n  const leafHash = tapleafHash({\n    output: tapLeaf.script,\n    version: tapLeaf.leafVersion,\n  });\n  return (\n    (input.tapScriptSig || [])\n      // .filter(tss => tss.leafHash.equals(leafHash))\n      .filter(tss => tools.compare(tss.leafHash, leafHash) === 0)\n      .map(tss => addPubkeyPositionInScript(tapLeaf.script, tss))\n      .sort((t1, t2) => t2.positionInScript - t1.positionInScript)\n      .map(t => t.signature)\n  );\n}\n/**\n * Adds the position of a public key in a script to a TapScriptSig object.\n * @param script The script in which to find the position of the public key.\n * @param tss The TapScriptSig object to add the position to.\n * @returns A TapScriptSigWitPosition object with the added position.\n */\nfunction addPubkeyPositionInScript(script, tss) {\n  return Object.assign(\n    {\n      positionInScript: pubkeyPositionInScript(tss.pubkey, script),\n    },\n    tss,\n  );\n}\n/**\n * Find tapleaf by hash, or get the signed tapleaf with the shortest path.\n */\nfunction findTapLeafToFinalize(input, inputIndex, leafHashToFinalize) {\n  if (!input.tapScriptSig || !input.tapScriptSig.length)\n    throw new Error(\n      `Can not finalize taproot input #${inputIndex}. No tapleaf script signature provided.`,\n    );\n  const tapLeaf = (input.tapLeafScript || [])\n    .sort((a, b) => a.controlBlock.length - b.controlBlock.length)\n    .find(leaf =>\n      canFinalizeLeaf(leaf, input.tapScriptSig, leafHashToFinalize),\n    );\n  if (!tapLeaf)\n    throw new Error(\n      `Can not finalize taproot input #${inputIndex}. Signature for tapleaf script not found.`,\n    );\n  return tapLeaf;\n}\n/**\n * Determines whether a TapLeafScript can be finalized.\n *\n * @param leaf - The TapLeafScript to check.\n * @param tapScriptSig - The array of TapScriptSig objects.\n * @param hash - The optional hash to compare with the leaf hash.\n * @returns A boolean indicating whether the TapLeafScript can be finalized.\n */\nfunction canFinalizeLeaf(leaf, tapScriptSig, hash) {\n  const leafHash = tapleafHash({\n    output: leaf.script,\n    version: leaf.leafVersion,\n  });\n  const whiteListedHash = !hash || tools.compare(leafHash, hash) === 0;\n  return (\n    whiteListedHash &&\n    tapScriptSig.find(tss => tools.compare(tss.leafHash, leafHash) === 0) !==\n      undefined\n  );\n}\n/**\n * Checks if the given PsbtInput or PsbtOutput has non-taproot fields.\n * Non-taproot fields include redeemScript, witnessScript, and bip32Derivation.\n * @param io The PsbtInput or PsbtOutput to check.\n * @returns A boolean indicating whether the given input or output has non-taproot fields.\n */\nfunction hasNonTaprootFields(io) {\n  return (\n    io &&\n    !!(\n      io.redeemScript ||\n      io.witnessScript ||\n      (io.bip32Derivation && io.bip32Derivation.length)\n    )\n  );\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4522, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4528, "column": 0}, "map": {"version":3,"sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/bitcoinjs-lib/src/esm/psbt.js"],"sourcesContent":["import { Psbt as PsbtBase } from 'bip174';\nimport * as varuint from 'varuint-bitcoin';\nimport { checkForInput, checkForOutput } from 'bip174';\nimport { fromOutputScript, toOutputScript } from './address.js';\nimport { cloneBuffer, reverseBuffer } from './bufferutils.js';\nimport { bitcoin as btcNetwork } from './networks.js';\nimport * as payments from './payments/index.js';\nimport { tapleafHash } from './payments/bip341.js';\nimport * as bscript from './script.js';\nimport { Transaction } from './transaction.js';\nimport {\n  toXOnly,\n  tapScriptFinalizer,\n  serializeTaprootSignature,\n  isTaprootInput,\n  checkTaprootInputFields,\n  checkTaprootOutputFields,\n  checkTaprootInputForSigs,\n} from './psbt/bip371.js';\nimport {\n  witnessStackToScriptWitness,\n  checkInputForSig,\n  pubkeyInScript,\n  isP2MS,\n  isP2PK,\n  isP2PKH,\n  isP2WPKH,\n  isP2WSHScript,\n  isP2SHScript,\n  isP2TR,\n} from './psbt/psbtutils.js';\nimport * as tools from 'uint8array-tools';\n/**\n * These are the default arguments for a Psbt instance.\n */\nconst DEFAULT_OPTS = {\n  /**\n   * A bitcoinjs Network object. This is only used if you pass an `address`\n   * parameter to addOutput. Otherwise it is not needed and can be left default.\n   */\n  network: btcNetwork,\n  /**\n   * When extractTransaction is called, the fee rate is checked.\n   * THIS IS NOT TO BE RELIED ON.\n   * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.\n   */\n  maximumFeeRate: 5000, // satoshi per byte\n};\n/**\n * Psbt class can parse and generate a PSBT binary based off of the BIP174.\n * There are 6 roles that this class fulfills. (Explained in BIP174)\n *\n * Creator: This can be done with `new Psbt()`\n *\n * Updater: This can be done with `psbt.addInput(input)`, `psbt.addInputs(inputs)`,\n *   `psbt.addOutput(output)`, `psbt.addOutputs(outputs)` when you are looking to\n *   add new inputs and outputs to the PSBT, and `psbt.updateGlobal(itemObject)`,\n *   `psbt.updateInput(itemObject)`, `psbt.updateOutput(itemObject)`\n *   addInput requires hash: Buffer | string; and index: number; as attributes\n *   and can also include any attributes that are used in updateInput method.\n *   addOutput requires script: Buffer; and value: number; and likewise can include\n *   data for updateOutput.\n *   For a list of what attributes should be what types. Check the bip174 library.\n *   Also, check the integration tests for some examples of usage.\n *\n * Signer: There are a few methods. signAllInputs and signAllInputsAsync, which will search all input\n *   information for your pubkey or pubkeyhash, and only sign inputs where it finds\n *   your info. Or you can explicitly sign a specific input with signInput and\n *   signInputAsync. For the async methods you can create a SignerAsync object\n *   and use something like a hardware wallet to sign with. (You must implement this)\n *\n * Combiner: psbts can be combined easily with `psbt.combine(psbt2, psbt3, psbt4 ...)`\n *   the psbt calling combine will always have precedence when a conflict occurs.\n *   Combine checks if the internal bitcoin transaction is the same, so be sure that\n *   all sequences, version, locktime, etc. are the same before combining.\n *\n * Input Finalizer: This role is fairly important. Not only does it need to construct\n *   the input scriptSigs and witnesses, but it SHOULD verify the signatures etc.\n *   Before running `psbt.finalizeAllInputs()` please run `psbt.validateSignaturesOfAllInputs()`\n *   Running any finalize method will delete any data in the input(s) that are no longer\n *   needed due to the finalized scripts containing the information.\n *\n * Transaction Extractor: This role will perform some checks before returning a\n *   Transaction object. Such as fee rate not being larger than maximumFeeRate etc.\n */\nexport class Psbt {\n  data;\n  static fromBase64(data, opts = {}) {\n    const buffer = tools.fromBase64(data);\n    return this.fromBuffer(buffer, opts);\n  }\n  static fromHex(data, opts = {}) {\n    const buffer = tools.fromHex(data);\n    return this.fromBuffer(buffer, opts);\n  }\n  static fromBuffer(buffer, opts = {}) {\n    const psbtBase = PsbtBase.fromBuffer(buffer, transactionFromBuffer);\n    const psbt = new Psbt(opts, psbtBase);\n    checkTxForDupeIns(psbt.__CACHE.__TX, psbt.__CACHE);\n    return psbt;\n  }\n  __CACHE;\n  opts;\n  constructor(opts = {}, data = new PsbtBase(new PsbtTransaction())) {\n    this.data = data;\n    // set defaults\n    this.opts = Object.assign({}, DEFAULT_OPTS, opts);\n    this.__CACHE = {\n      __NON_WITNESS_UTXO_TX_CACHE: [],\n      __NON_WITNESS_UTXO_BUF_CACHE: [],\n      __TX_IN_CACHE: {},\n      __TX: this.data.globalMap.unsignedTx.tx,\n      // Psbt's predecessor (TransactionBuilder - now removed) behavior\n      // was to not confirm input values  before signing.\n      // Even though we highly encourage people to get\n      // the full parent transaction to verify values, the ability to\n      // sign non-segwit inputs without the full transaction was often\n      // requested. So the only way to activate is to use @ts-ignore.\n      // We will disable exporting the Psbt when unsafe sign is active.\n      // because it is not BIP174 compliant.\n      __UNSAFE_SIGN_NONSEGWIT: false,\n    };\n    if (this.data.inputs.length === 0) this.setVersion(2);\n    // Make data hidden when enumerating\n    const dpew = (obj, attr, enumerable, writable) =>\n      Object.defineProperty(obj, attr, {\n        enumerable,\n        writable,\n      });\n    dpew(this, '__CACHE', false, true);\n    dpew(this, 'opts', false, true);\n  }\n  get inputCount() {\n    return this.data.inputs.length;\n  }\n  get version() {\n    return this.__CACHE.__TX.version;\n  }\n  set version(version) {\n    this.setVersion(version);\n  }\n  get locktime() {\n    return this.__CACHE.__TX.locktime;\n  }\n  set locktime(locktime) {\n    this.setLocktime(locktime);\n  }\n  get txInputs() {\n    return this.__CACHE.__TX.ins.map(input => ({\n      hash: cloneBuffer(input.hash),\n      index: input.index,\n      sequence: input.sequence,\n    }));\n  }\n  get txOutputs() {\n    return this.__CACHE.__TX.outs.map(output => {\n      let address;\n      try {\n        address = fromOutputScript(output.script, this.opts.network);\n      } catch (_) {}\n      return {\n        script: cloneBuffer(output.script),\n        value: output.value,\n        address,\n      };\n    });\n  }\n  combine(...those) {\n    this.data.combine(...those.map(o => o.data));\n    return this;\n  }\n  clone() {\n    // TODO: more efficient cloning\n    const res = Psbt.fromBuffer(this.data.toBuffer());\n    res.opts = JSON.parse(JSON.stringify(this.opts));\n    return res;\n  }\n  setMaximumFeeRate(satoshiPerByte) {\n    check32Bit(satoshiPerByte); // 42.9 BTC per byte IS excessive... so throw\n    this.opts.maximumFeeRate = satoshiPerByte;\n  }\n  setVersion(version) {\n    check32Bit(version);\n    checkInputsForPartialSig(this.data.inputs, 'setVersion');\n    const c = this.__CACHE;\n    c.__TX.version = version;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  setLocktime(locktime) {\n    check32Bit(locktime);\n    checkInputsForPartialSig(this.data.inputs, 'setLocktime');\n    const c = this.__CACHE;\n    c.__TX.locktime = locktime;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  setInputSequence(inputIndex, sequence) {\n    check32Bit(sequence);\n    checkInputsForPartialSig(this.data.inputs, 'setInputSequence');\n    const c = this.__CACHE;\n    if (c.__TX.ins.length <= inputIndex) {\n      throw new Error('Input index too high');\n    }\n    c.__TX.ins[inputIndex].sequence = sequence;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  addInputs(inputDatas) {\n    inputDatas.forEach(inputData => this.addInput(inputData));\n    return this;\n  }\n  addInput(inputData) {\n    if (\n      arguments.length > 1 ||\n      !inputData ||\n      inputData.hash === undefined ||\n      inputData.index === undefined\n    ) {\n      throw new Error(\n        `Invalid arguments for Psbt.addInput. ` +\n          `Requires single object with at least [hash] and [index]`,\n      );\n    }\n    checkTaprootInputFields(inputData, inputData, 'addInput');\n    checkInputsForPartialSig(this.data.inputs, 'addInput');\n    if (inputData.witnessScript) checkInvalidP2WSH(inputData.witnessScript);\n    const c = this.__CACHE;\n    this.data.addInput(inputData);\n    const txIn = c.__TX.ins[c.__TX.ins.length - 1];\n    checkTxInputCache(c, txIn);\n    const inputIndex = this.data.inputs.length - 1;\n    const input = this.data.inputs[inputIndex];\n    if (input.nonWitnessUtxo) {\n      addNonWitnessTxCache(this.__CACHE, input, inputIndex);\n    }\n    c.__FEE = undefined;\n    c.__FEE_RATE = undefined;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  addOutputs(outputDatas) {\n    outputDatas.forEach(outputData => this.addOutput(outputData));\n    return this;\n  }\n  addOutput(outputData) {\n    if (\n      arguments.length > 1 ||\n      !outputData ||\n      outputData.value === undefined ||\n      (outputData.address === undefined && outputData.script === undefined)\n    ) {\n      throw new Error(\n        `Invalid arguments for Psbt.addOutput. ` +\n          `Requires single object with at least [script or address] and [value]`,\n      );\n    }\n    checkInputsForPartialSig(this.data.inputs, 'addOutput');\n    const { address } = outputData;\n    if (typeof address === 'string') {\n      const { network } = this.opts;\n      const script = toOutputScript(address, network);\n      outputData = Object.assign({}, outputData, { script });\n    }\n    checkTaprootOutputFields(outputData, outputData, 'addOutput');\n    const c = this.__CACHE;\n    this.data.addOutput(outputData);\n    c.__FEE = undefined;\n    c.__FEE_RATE = undefined;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  extractTransaction(disableFeeCheck) {\n    if (!this.data.inputs.every(isFinalized)) throw new Error('Not finalized');\n    const c = this.__CACHE;\n    if (!disableFeeCheck) {\n      checkFees(this, c, this.opts);\n    }\n    if (c.__EXTRACTED_TX) return c.__EXTRACTED_TX;\n    const tx = c.__TX.clone();\n    inputFinalizeGetAmts(this.data.inputs, tx, c, true);\n    return tx;\n  }\n  getFeeRate() {\n    return getTxCacheValue(\n      '__FEE_RATE',\n      'fee rate',\n      this.data.inputs,\n      this.__CACHE,\n    );\n  }\n  getFee() {\n    return getTxCacheValue('__FEE', 'fee', this.data.inputs, this.__CACHE);\n  }\n  finalizeAllInputs() {\n    checkForInput(this.data.inputs, 0); // making sure we have at least one\n    range(this.data.inputs.length).forEach(idx => this.finalizeInput(idx));\n    return this;\n  }\n  finalizeInput(inputIndex, finalScriptsFunc) {\n    const input = checkForInput(this.data.inputs, inputIndex);\n    if (isTaprootInput(input))\n      return this._finalizeTaprootInput(\n        inputIndex,\n        input,\n        undefined,\n        finalScriptsFunc,\n      );\n    return this._finalizeInput(inputIndex, input, finalScriptsFunc);\n  }\n  finalizeTaprootInput(\n    inputIndex,\n    tapLeafHashToFinalize,\n    finalScriptsFunc = tapScriptFinalizer,\n  ) {\n    const input = checkForInput(this.data.inputs, inputIndex);\n    if (isTaprootInput(input))\n      return this._finalizeTaprootInput(\n        inputIndex,\n        input,\n        tapLeafHashToFinalize,\n        finalScriptsFunc,\n      );\n    throw new Error(`Cannot finalize input #${inputIndex}. Not Taproot.`);\n  }\n  _finalizeInput(inputIndex, input, finalScriptsFunc = getFinalScripts) {\n    const { script, isP2SH, isP2WSH, isSegwit } = getScriptFromInput(\n      inputIndex,\n      input,\n      this.__CACHE,\n    );\n    if (!script) throw new Error(`No script found for input #${inputIndex}`);\n    checkPartialSigSighashes(input);\n    const { finalScriptSig, finalScriptWitness } = finalScriptsFunc(\n      inputIndex,\n      input,\n      script,\n      isSegwit,\n      isP2SH,\n      isP2WSH,\n    );\n    if (finalScriptSig) this.data.updateInput(inputIndex, { finalScriptSig });\n    if (finalScriptWitness)\n      this.data.updateInput(inputIndex, { finalScriptWitness });\n    if (!finalScriptSig && !finalScriptWitness)\n      throw new Error(`Unknown error finalizing input #${inputIndex}`);\n    this.data.clearFinalizedInput(inputIndex);\n    return this;\n  }\n  _finalizeTaprootInput(\n    inputIndex,\n    input,\n    tapLeafHashToFinalize,\n    finalScriptsFunc = tapScriptFinalizer,\n  ) {\n    if (!input.witnessUtxo)\n      throw new Error(\n        `Cannot finalize input #${inputIndex}. Missing withness utxo.`,\n      );\n    // Check key spend first. Increased privacy and reduced block space.\n    if (input.tapKeySig) {\n      const payment = payments.p2tr({\n        output: input.witnessUtxo.script,\n        signature: input.tapKeySig,\n      });\n      const finalScriptWitness = witnessStackToScriptWitness(payment.witness);\n      this.data.updateInput(inputIndex, { finalScriptWitness });\n    } else {\n      const { finalScriptWitness } = finalScriptsFunc(\n        inputIndex,\n        input,\n        tapLeafHashToFinalize,\n      );\n      this.data.updateInput(inputIndex, { finalScriptWitness });\n    }\n    this.data.clearFinalizedInput(inputIndex);\n    return this;\n  }\n  getInputType(inputIndex) {\n    const input = checkForInput(this.data.inputs, inputIndex);\n    const script = getScriptFromUtxo(inputIndex, input, this.__CACHE);\n    const result = getMeaningfulScript(\n      script,\n      inputIndex,\n      'input',\n      input.redeemScript || redeemFromFinalScriptSig(input.finalScriptSig),\n      input.witnessScript ||\n        redeemFromFinalWitnessScript(input.finalScriptWitness),\n    );\n    const type = result.type === 'raw' ? '' : result.type + '-';\n    const mainType = classifyScript(result.meaningfulScript);\n    return type + mainType;\n  }\n  inputHasPubkey(inputIndex, pubkey) {\n    const input = checkForInput(this.data.inputs, inputIndex);\n    return pubkeyInInput(pubkey, input, inputIndex, this.__CACHE);\n  }\n  inputHasHDKey(inputIndex, root) {\n    const input = checkForInput(this.data.inputs, inputIndex);\n    const derivationIsMine = bip32DerivationIsMine(root);\n    return (\n      !!input.bip32Derivation && input.bip32Derivation.some(derivationIsMine)\n    );\n  }\n  outputHasPubkey(outputIndex, pubkey) {\n    const output = checkForOutput(this.data.outputs, outputIndex);\n    return pubkeyInOutput(pubkey, output, outputIndex, this.__CACHE);\n  }\n  outputHasHDKey(outputIndex, root) {\n    const output = checkForOutput(this.data.outputs, outputIndex);\n    const derivationIsMine = bip32DerivationIsMine(root);\n    return (\n      !!output.bip32Derivation && output.bip32Derivation.some(derivationIsMine)\n    );\n  }\n  validateSignaturesOfAllInputs(validator) {\n    checkForInput(this.data.inputs, 0); // making sure we have at least one\n    const results = range(this.data.inputs.length).map(idx =>\n      this.validateSignaturesOfInput(idx, validator),\n    );\n    return results.reduce((final, res) => res === true && final, true);\n  }\n  validateSignaturesOfInput(inputIndex, validator, pubkey) {\n    const input = this.data.inputs[inputIndex];\n    if (isTaprootInput(input))\n      return this.validateSignaturesOfTaprootInput(\n        inputIndex,\n        validator,\n        pubkey,\n      );\n    return this._validateSignaturesOfInput(inputIndex, validator, pubkey);\n  }\n  _validateSignaturesOfInput(inputIndex, validator, pubkey) {\n    const input = this.data.inputs[inputIndex];\n    const partialSig = (input || {}).partialSig;\n    if (!input || !partialSig || partialSig.length < 1)\n      throw new Error('No signatures to validate');\n    if (typeof validator !== 'function')\n      throw new Error('Need validator function to validate signatures');\n    const mySigs = pubkey\n      ? partialSig.filter(sig => tools.compare(sig.pubkey, pubkey) === 0)\n      : partialSig;\n    if (mySigs.length < 1) throw new Error('No signatures for this pubkey');\n    const results = [];\n    let hashCache;\n    let scriptCache;\n    let sighashCache;\n    for (const pSig of mySigs) {\n      const sig = bscript.signature.decode(pSig.signature);\n      const { hash, script } =\n        sighashCache !== sig.hashType\n          ? getHashForSig(\n              inputIndex,\n              Object.assign({}, input, { sighashType: sig.hashType }),\n              this.__CACHE,\n              true,\n            )\n          : { hash: hashCache, script: scriptCache };\n      sighashCache = sig.hashType;\n      hashCache = hash;\n      scriptCache = script;\n      checkScriptForPubkey(pSig.pubkey, script, 'verify');\n      results.push(validator(pSig.pubkey, hash, sig.signature));\n    }\n    return results.every(res => res === true);\n  }\n  validateSignaturesOfTaprootInput(inputIndex, validator, pubkey) {\n    const input = this.data.inputs[inputIndex];\n    const tapKeySig = (input || {}).tapKeySig;\n    const tapScriptSig = (input || {}).tapScriptSig;\n    if (!input && !tapKeySig && !(tapScriptSig && !tapScriptSig.length))\n      throw new Error('No signatures to validate');\n    if (typeof validator !== 'function')\n      throw new Error('Need validator function to validate signatures');\n    pubkey = pubkey && toXOnly(pubkey);\n    const allHashses = pubkey\n      ? getTaprootHashesForSig(\n          inputIndex,\n          input,\n          this.data.inputs,\n          pubkey,\n          this.__CACHE,\n        )\n      : getAllTaprootHashesForSig(\n          inputIndex,\n          input,\n          this.data.inputs,\n          this.__CACHE,\n        );\n    if (!allHashses.length) throw new Error('No signatures for this pubkey');\n    const tapKeyHash = allHashses.find(h => !h.leafHash);\n    let validationResultCount = 0;\n    if (tapKeySig && tapKeyHash) {\n      const isValidTapkeySig = validator(\n        tapKeyHash.pubkey,\n        tapKeyHash.hash,\n        trimTaprootSig(tapKeySig),\n      );\n      if (!isValidTapkeySig) return false;\n      validationResultCount++;\n    }\n    if (tapScriptSig) {\n      for (const tapSig of tapScriptSig) {\n        const tapSigHash = allHashses.find(\n          h => tools.compare(h.pubkey, tapSig.pubkey) === 0,\n        );\n        if (tapSigHash) {\n          const isValidTapScriptSig = validator(\n            tapSig.pubkey,\n            tapSigHash.hash,\n            trimTaprootSig(tapSig.signature),\n          );\n          if (!isValidTapScriptSig) return false;\n          validationResultCount++;\n        }\n      }\n    }\n    return validationResultCount > 0;\n  }\n  signAllInputsHD(hdKeyPair, sighashTypes = [Transaction.SIGHASH_ALL]) {\n    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n      throw new Error('Need HDSigner to sign input');\n    }\n    const results = [];\n    for (const i of range(this.data.inputs.length)) {\n      try {\n        this.signInputHD(i, hdKeyPair, sighashTypes);\n        results.push(true);\n      } catch (err) {\n        results.push(false);\n      }\n    }\n    if (results.every(v => v === false)) {\n      throw new Error('No inputs were signed');\n    }\n    return this;\n  }\n  signAllInputsHDAsync(hdKeyPair, sighashTypes = [Transaction.SIGHASH_ALL]) {\n    return new Promise((resolve, reject) => {\n      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n        return reject(new Error('Need HDSigner to sign input'));\n      }\n      const results = [];\n      const promises = [];\n      for (const i of range(this.data.inputs.length)) {\n        promises.push(\n          this.signInputHDAsync(i, hdKeyPair, sighashTypes).then(\n            () => {\n              results.push(true);\n            },\n            () => {\n              results.push(false);\n            },\n          ),\n        );\n      }\n      return Promise.all(promises).then(() => {\n        if (results.every(v => v === false)) {\n          return reject(new Error('No inputs were signed'));\n        }\n        resolve();\n      });\n    });\n  }\n  signInputHD(inputIndex, hdKeyPair, sighashTypes = [Transaction.SIGHASH_ALL]) {\n    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n      throw new Error('Need HDSigner to sign input');\n    }\n    const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);\n    signers.forEach(signer => this.signInput(inputIndex, signer, sighashTypes));\n    return this;\n  }\n  signInputHDAsync(\n    inputIndex,\n    hdKeyPair,\n    sighashTypes = [Transaction.SIGHASH_ALL],\n  ) {\n    return new Promise((resolve, reject) => {\n      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n        return reject(new Error('Need HDSigner to sign input'));\n      }\n      const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);\n      const promises = signers.map(signer =>\n        this.signInputAsync(inputIndex, signer, sighashTypes),\n      );\n      return Promise.all(promises)\n        .then(() => {\n          resolve();\n        })\n        .catch(reject);\n    });\n  }\n  signAllInputs(keyPair, sighashTypes) {\n    if (!keyPair || !keyPair.publicKey)\n      throw new Error('Need Signer to sign input');\n    // TODO: Add a pubkey/pubkeyhash cache to each input\n    // as input information is added, then eventually\n    // optimize this method.\n    const results = [];\n    for (const i of range(this.data.inputs.length)) {\n      try {\n        this.signInput(i, keyPair, sighashTypes);\n        results.push(true);\n      } catch (err) {\n        results.push(false);\n      }\n    }\n    if (results.every(v => v === false)) {\n      throw new Error('No inputs were signed');\n    }\n    return this;\n  }\n  signAllInputsAsync(keyPair, sighashTypes) {\n    return new Promise((resolve, reject) => {\n      if (!keyPair || !keyPair.publicKey)\n        return reject(new Error('Need Signer to sign input'));\n      // TODO: Add a pubkey/pubkeyhash cache to each input\n      // as input information is added, then eventually\n      // optimize this method.\n      const results = [];\n      const promises = [];\n      for (const [i] of this.data.inputs.entries()) {\n        promises.push(\n          this.signInputAsync(i, keyPair, sighashTypes).then(\n            () => {\n              results.push(true);\n            },\n            () => {\n              results.push(false);\n            },\n          ),\n        );\n      }\n      return Promise.all(promises).then(() => {\n        if (results.every(v => v === false)) {\n          return reject(new Error('No inputs were signed'));\n        }\n        resolve();\n      });\n    });\n  }\n  signInput(inputIndex, keyPair, sighashTypes) {\n    if (!keyPair || !keyPair.publicKey)\n      throw new Error('Need Signer to sign input');\n    const input = checkForInput(this.data.inputs, inputIndex);\n    if (isTaprootInput(input)) {\n      return this._signTaprootInput(\n        inputIndex,\n        input,\n        keyPair,\n        undefined,\n        sighashTypes,\n      );\n    }\n    return this._signInput(inputIndex, keyPair, sighashTypes);\n  }\n  signTaprootInput(inputIndex, keyPair, tapLeafHashToSign, sighashTypes) {\n    if (!keyPair || !keyPair.publicKey)\n      throw new Error('Need Signer to sign input');\n    const input = checkForInput(this.data.inputs, inputIndex);\n    if (isTaprootInput(input))\n      return this._signTaprootInput(\n        inputIndex,\n        input,\n        keyPair,\n        tapLeafHashToSign,\n        sighashTypes,\n      );\n    throw new Error(`Input #${inputIndex} is not of type Taproot.`);\n  }\n  _signInput(inputIndex, keyPair, sighashTypes = [Transaction.SIGHASH_ALL]) {\n    const { hash, sighashType } = getHashAndSighashType(\n      this.data.inputs,\n      inputIndex,\n      keyPair.publicKey,\n      this.__CACHE,\n      sighashTypes,\n    );\n    const partialSig = [\n      {\n        pubkey: keyPair.publicKey,\n        signature: bscript.signature.encode(keyPair.sign(hash), sighashType),\n      },\n    ];\n    this.data.updateInput(inputIndex, { partialSig });\n    return this;\n  }\n  _signTaprootInput(\n    inputIndex,\n    input,\n    keyPair,\n    tapLeafHashToSign,\n    allowedSighashTypes = [Transaction.SIGHASH_DEFAULT],\n  ) {\n    const hashesForSig = this.checkTaprootHashesForSig(\n      inputIndex,\n      input,\n      keyPair,\n      tapLeafHashToSign,\n      allowedSighashTypes,\n    );\n    const tapKeySig = hashesForSig\n      .filter(h => !h.leafHash)\n      .map(h =>\n        serializeTaprootSignature(\n          keyPair.signSchnorr(h.hash),\n          input.sighashType,\n        ),\n      )[0];\n    const tapScriptSig = hashesForSig\n      .filter(h => !!h.leafHash)\n      .map(h => ({\n        pubkey: toXOnly(keyPair.publicKey),\n        signature: serializeTaprootSignature(\n          keyPair.signSchnorr(h.hash),\n          input.sighashType,\n        ),\n        leafHash: h.leafHash,\n      }));\n    if (tapKeySig) {\n      this.data.updateInput(inputIndex, { tapKeySig });\n    }\n    if (tapScriptSig.length) {\n      this.data.updateInput(inputIndex, { tapScriptSig });\n    }\n    return this;\n  }\n  signInputAsync(inputIndex, keyPair, sighashTypes) {\n    return Promise.resolve().then(() => {\n      if (!keyPair || !keyPair.publicKey)\n        throw new Error('Need Signer to sign input');\n      const input = checkForInput(this.data.inputs, inputIndex);\n      if (isTaprootInput(input))\n        return this._signTaprootInputAsync(\n          inputIndex,\n          input,\n          keyPair,\n          undefined,\n          sighashTypes,\n        );\n      return this._signInputAsync(inputIndex, keyPair, sighashTypes);\n    });\n  }\n  signTaprootInputAsync(inputIndex, keyPair, tapLeafHash, sighashTypes) {\n    return Promise.resolve().then(() => {\n      if (!keyPair || !keyPair.publicKey)\n        throw new Error('Need Signer to sign input');\n      const input = checkForInput(this.data.inputs, inputIndex);\n      if (isTaprootInput(input))\n        return this._signTaprootInputAsync(\n          inputIndex,\n          input,\n          keyPair,\n          tapLeafHash,\n          sighashTypes,\n        );\n      throw new Error(`Input #${inputIndex} is not of type Taproot.`);\n    });\n  }\n  _signInputAsync(\n    inputIndex,\n    keyPair,\n    sighashTypes = [Transaction.SIGHASH_ALL],\n  ) {\n    const { hash, sighashType } = getHashAndSighashType(\n      this.data.inputs,\n      inputIndex,\n      keyPair.publicKey,\n      this.__CACHE,\n      sighashTypes,\n    );\n    return Promise.resolve(keyPair.sign(hash)).then(signature => {\n      const partialSig = [\n        {\n          pubkey: keyPair.publicKey,\n          signature: bscript.signature.encode(signature, sighashType),\n        },\n      ];\n      this.data.updateInput(inputIndex, { partialSig });\n    });\n  }\n  async _signTaprootInputAsync(\n    inputIndex,\n    input,\n    keyPair,\n    tapLeafHash,\n    sighashTypes = [Transaction.SIGHASH_DEFAULT],\n  ) {\n    const hashesForSig = this.checkTaprootHashesForSig(\n      inputIndex,\n      input,\n      keyPair,\n      tapLeafHash,\n      sighashTypes,\n    );\n    const signaturePromises = [];\n    const tapKeyHash = hashesForSig.filter(h => !h.leafHash)[0];\n    if (tapKeyHash) {\n      const tapKeySigPromise = Promise.resolve(\n        keyPair.signSchnorr(tapKeyHash.hash),\n      ).then(sig => {\n        return { tapKeySig: serializeTaprootSignature(sig, input.sighashType) };\n      });\n      signaturePromises.push(tapKeySigPromise);\n    }\n    const tapScriptHashes = hashesForSig.filter(h => !!h.leafHash);\n    if (tapScriptHashes.length) {\n      const tapScriptSigPromises = tapScriptHashes.map(tsh => {\n        return Promise.resolve(keyPair.signSchnorr(tsh.hash)).then(\n          signature => {\n            const tapScriptSig = [\n              {\n                pubkey: toXOnly(keyPair.publicKey),\n                signature: serializeTaprootSignature(\n                  signature,\n                  input.sighashType,\n                ),\n                leafHash: tsh.leafHash,\n              },\n            ];\n            return { tapScriptSig };\n          },\n        );\n      });\n      signaturePromises.push(...tapScriptSigPromises);\n    }\n    return Promise.all(signaturePromises).then(results => {\n      results.forEach(v => this.data.updateInput(inputIndex, v));\n    });\n  }\n  checkTaprootHashesForSig(\n    inputIndex,\n    input,\n    keyPair,\n    tapLeafHashToSign,\n    allowedSighashTypes,\n  ) {\n    if (typeof keyPair.signSchnorr !== 'function')\n      throw new Error(\n        `Need Schnorr Signer to sign taproot input #${inputIndex}.`,\n      );\n    const hashesForSig = getTaprootHashesForSig(\n      inputIndex,\n      input,\n      this.data.inputs,\n      keyPair.publicKey,\n      this.__CACHE,\n      tapLeafHashToSign,\n      allowedSighashTypes,\n    );\n    if (!hashesForSig || !hashesForSig.length)\n      throw new Error(\n        `Can not sign for input #${inputIndex} with the key ${tools.toHex(keyPair.publicKey)}`,\n      );\n    return hashesForSig;\n  }\n  toBuffer() {\n    checkCache(this.__CACHE);\n    return this.data.toBuffer();\n  }\n  toHex() {\n    checkCache(this.__CACHE);\n    return this.data.toHex();\n  }\n  toBase64() {\n    checkCache(this.__CACHE);\n    return this.data.toBase64();\n  }\n  updateGlobal(updateData) {\n    this.data.updateGlobal(updateData);\n    return this;\n  }\n  updateInput(inputIndex, updateData) {\n    if (updateData.witnessScript) checkInvalidP2WSH(updateData.witnessScript);\n    checkTaprootInputFields(\n      this.data.inputs[inputIndex],\n      updateData,\n      'updateInput',\n    );\n    this.data.updateInput(inputIndex, updateData);\n    if (updateData.nonWitnessUtxo) {\n      addNonWitnessTxCache(\n        this.__CACHE,\n        this.data.inputs[inputIndex],\n        inputIndex,\n      );\n    }\n    return this;\n  }\n  updateOutput(outputIndex, updateData) {\n    const outputData = this.data.outputs[outputIndex];\n    checkTaprootOutputFields(outputData, updateData, 'updateOutput');\n    this.data.updateOutput(outputIndex, updateData);\n    return this;\n  }\n  addUnknownKeyValToGlobal(keyVal) {\n    this.data.addUnknownKeyValToGlobal(keyVal);\n    return this;\n  }\n  addUnknownKeyValToInput(inputIndex, keyVal) {\n    this.data.addUnknownKeyValToInput(inputIndex, keyVal);\n    return this;\n  }\n  addUnknownKeyValToOutput(outputIndex, keyVal) {\n    this.data.addUnknownKeyValToOutput(outputIndex, keyVal);\n    return this;\n  }\n  clearFinalizedInput(inputIndex) {\n    this.data.clearFinalizedInput(inputIndex);\n    return this;\n  }\n}\n/**\n * This function is needed to pass to the bip174 base class's fromBuffer.\n * It takes the \"transaction buffer\" portion of the psbt buffer and returns a\n * Transaction (From the bip174 library) interface.\n */\nconst transactionFromBuffer = buffer => new PsbtTransaction(buffer);\n/**\n * This class implements the Transaction interface from bip174 library.\n * It contains a bitcoinjs-lib Transaction object.\n */\nclass PsbtTransaction {\n  tx;\n  constructor(buffer = Uint8Array.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0])) {\n    this.tx = Transaction.fromBuffer(buffer);\n    checkTxEmpty(this.tx);\n    Object.defineProperty(this, 'tx', {\n      enumerable: false,\n      writable: true,\n    });\n  }\n  getInputOutputCounts() {\n    return {\n      inputCount: this.tx.ins.length,\n      outputCount: this.tx.outs.length,\n    };\n  }\n  addInput(input) {\n    if (\n      input.hash === undefined ||\n      input.index === undefined ||\n      (!(input.hash instanceof Uint8Array) && typeof input.hash !== 'string') ||\n      typeof input.index !== 'number'\n    ) {\n      throw new Error('Error adding input.');\n    }\n    const hash =\n      typeof input.hash === 'string'\n        ? reverseBuffer(tools.fromHex(input.hash))\n        : input.hash;\n    this.tx.addInput(hash, input.index, input.sequence);\n  }\n  addOutput(output) {\n    if (\n      output.script === undefined ||\n      output.value === undefined ||\n      !(output.script instanceof Uint8Array) ||\n      typeof output.value !== 'bigint'\n    ) {\n      throw new Error('Error adding output.');\n    }\n    this.tx.addOutput(output.script, output.value);\n  }\n  toBuffer() {\n    return this.tx.toBuffer();\n  }\n}\nfunction canFinalize(input, script, scriptType) {\n  switch (scriptType) {\n    case 'pubkey':\n    case 'pubkeyhash':\n    case 'witnesspubkeyhash':\n      return hasSigs(1, input.partialSig);\n    case 'multisig':\n      const p2ms = payments.p2ms({ output: script });\n      return hasSigs(p2ms.m, input.partialSig, p2ms.pubkeys);\n    default:\n      return false;\n  }\n}\nfunction checkCache(cache) {\n  if (cache.__UNSAFE_SIGN_NONSEGWIT !== false) {\n    throw new Error('Not BIP174 compliant, can not export');\n  }\n}\nfunction hasSigs(neededSigs, partialSig, pubkeys) {\n  if (!partialSig) return false;\n  let sigs;\n  if (pubkeys) {\n    sigs = pubkeys\n      .map(pkey => {\n        const pubkey = compressPubkey(pkey);\n        return partialSig.find(\n          pSig => tools.compare(pSig.pubkey, pubkey) === 0,\n        );\n      })\n      .filter(v => !!v);\n  } else {\n    sigs = partialSig;\n  }\n  if (sigs.length > neededSigs) throw new Error('Too many signatures');\n  return sigs.length === neededSigs;\n}\nfunction isFinalized(input) {\n  return !!input.finalScriptSig || !!input.finalScriptWitness;\n}\nfunction bip32DerivationIsMine(root) {\n  return d => {\n    if (tools.compare(root.fingerprint, d.masterFingerprint)) return false;\n    if (tools.compare(root.derivePath(d.path).publicKey, d.pubkey))\n      return false;\n    return true;\n  };\n}\nfunction check32Bit(num) {\n  if (\n    typeof num !== 'number' ||\n    num !== Math.floor(num) ||\n    num > 0xffffffff ||\n    num < 0\n  ) {\n    throw new Error('Invalid 32 bit integer');\n  }\n}\nfunction checkFees(psbt, cache, opts) {\n  const feeRate = cache.__FEE_RATE || psbt.getFeeRate();\n  const vsize = cache.__EXTRACTED_TX.virtualSize();\n  const satoshis = feeRate * vsize;\n  if (feeRate >= opts.maximumFeeRate) {\n    throw new Error(\n      `Warning: You are paying around ${(satoshis / 1e8).toFixed(8)} in ` +\n        `fees, which is ${feeRate} satoshi per byte for a transaction ` +\n        `with a VSize of ${vsize} bytes (segwit counted as 0.25 byte per ` +\n        `byte). Use setMaximumFeeRate method to raise your threshold, or ` +\n        `pass true to the first arg of extractTransaction.`,\n    );\n  }\n}\nfunction checkInputsForPartialSig(inputs, action) {\n  inputs.forEach(input => {\n    const throws = isTaprootInput(input)\n      ? checkTaprootInputForSigs(input, action)\n      : checkInputForSig(input, action);\n    if (throws)\n      throw new Error('Can not modify transaction, signatures exist.');\n  });\n}\nfunction checkPartialSigSighashes(input) {\n  if (!input.sighashType || !input.partialSig) return;\n  const { partialSig, sighashType } = input;\n  partialSig.forEach(pSig => {\n    const { hashType } = bscript.signature.decode(pSig.signature);\n    if (sighashType !== hashType) {\n      throw new Error('Signature sighash does not match input sighash type');\n    }\n  });\n}\nfunction checkScriptForPubkey(pubkey, script, action) {\n  if (!pubkeyInScript(pubkey, script)) {\n    throw new Error(\n      `Can not ${action} for this input with the key ${tools.toHex(pubkey)}`,\n    );\n  }\n}\nfunction checkTxEmpty(tx) {\n  const isEmpty = tx.ins.every(\n    input =>\n      input.script &&\n      input.script.length === 0 &&\n      input.witness &&\n      input.witness.length === 0,\n  );\n  if (!isEmpty) {\n    throw new Error('Format Error: Transaction ScriptSigs are not empty');\n  }\n}\nfunction checkTxForDupeIns(tx, cache) {\n  tx.ins.forEach(input => {\n    checkTxInputCache(cache, input);\n  });\n}\nfunction checkTxInputCache(cache, input) {\n  const key =\n    tools.toHex(reverseBuffer(Uint8Array.from(input.hash))) + ':' + input.index;\n  if (cache.__TX_IN_CACHE[key]) throw new Error('Duplicate input detected.');\n  cache.__TX_IN_CACHE[key] = 1;\n}\nfunction scriptCheckerFactory(payment, paymentScriptName) {\n  return (inputIndex, scriptPubKey, redeemScript, ioType) => {\n    const redeemScriptOutput = payment({\n      redeem: { output: redeemScript },\n    }).output;\n    if (tools.compare(scriptPubKey, redeemScriptOutput)) {\n      throw new Error(\n        `${paymentScriptName} for ${ioType} #${inputIndex} doesn't match the scriptPubKey in the prevout`,\n      );\n    }\n  };\n}\nconst checkRedeemScript = scriptCheckerFactory(payments.p2sh, 'Redeem script');\nconst checkWitnessScript = scriptCheckerFactory(\n  payments.p2wsh,\n  'Witness script',\n);\nfunction getTxCacheValue(key, name, inputs, c) {\n  if (!inputs.every(isFinalized))\n    throw new Error(`PSBT must be finalized to calculate ${name}`);\n  if (key === '__FEE_RATE' && c.__FEE_RATE) return c.__FEE_RATE;\n  if (key === '__FEE' && c.__FEE) return c.__FEE;\n  let tx;\n  let mustFinalize = true;\n  if (c.__EXTRACTED_TX) {\n    tx = c.__EXTRACTED_TX;\n    mustFinalize = false;\n  } else {\n    tx = c.__TX.clone();\n  }\n  inputFinalizeGetAmts(inputs, tx, c, mustFinalize);\n  if (key === '__FEE_RATE') return c.__FEE_RATE;\n  else if (key === '__FEE') return c.__FEE;\n}\nfunction getFinalScripts(inputIndex, input, script, isSegwit, isP2SH, isP2WSH) {\n  const scriptType = classifyScript(script);\n  if (!canFinalize(input, script, scriptType))\n    throw new Error(`Can not finalize input #${inputIndex}`);\n  return prepareFinalScripts(\n    script,\n    scriptType,\n    input.partialSig,\n    isSegwit,\n    isP2SH,\n    isP2WSH,\n  );\n}\nfunction prepareFinalScripts(\n  script,\n  scriptType,\n  partialSig,\n  isSegwit,\n  isP2SH,\n  isP2WSH,\n) {\n  let finalScriptSig;\n  let finalScriptWitness;\n  // Wow, the payments API is very handy\n  const payment = getPayment(script, scriptType, partialSig);\n  const p2wsh = !isP2WSH ? null : payments.p2wsh({ redeem: payment });\n  const p2sh = !isP2SH ? null : payments.p2sh({ redeem: p2wsh || payment });\n  if (isSegwit) {\n    if (p2wsh) {\n      finalScriptWitness = witnessStackToScriptWitness(p2wsh.witness);\n    } else {\n      finalScriptWitness = witnessStackToScriptWitness(payment.witness);\n    }\n    if (p2sh) {\n      finalScriptSig = p2sh.input;\n    }\n  } else {\n    if (p2sh) {\n      finalScriptSig = p2sh.input;\n    } else {\n      finalScriptSig = payment.input;\n    }\n  }\n  return {\n    finalScriptSig,\n    finalScriptWitness,\n  };\n}\nfunction getHashAndSighashType(\n  inputs,\n  inputIndex,\n  pubkey,\n  cache,\n  sighashTypes,\n) {\n  const input = checkForInput(inputs, inputIndex);\n  const { hash, sighashType, script } = getHashForSig(\n    inputIndex,\n    input,\n    cache,\n    false,\n    sighashTypes,\n  );\n  checkScriptForPubkey(pubkey, script, 'sign');\n  return {\n    hash,\n    sighashType,\n  };\n}\nfunction getHashForSig(inputIndex, input, cache, forValidate, sighashTypes) {\n  const unsignedTx = cache.__TX;\n  const sighashType = input.sighashType || Transaction.SIGHASH_ALL;\n  checkSighashTypeAllowed(sighashType, sighashTypes);\n  let hash;\n  let prevout;\n  if (input.nonWitnessUtxo) {\n    const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(\n      cache,\n      input,\n      inputIndex,\n    );\n    const prevoutHash = unsignedTx.ins[inputIndex].hash;\n    const utxoHash = nonWitnessUtxoTx.getHash();\n    // If a non-witness UTXO is provided, its hash must match the hash specified in the prevout\n    if (tools.compare(prevoutHash, utxoHash) !== 0) {\n      throw new Error(\n        `Non-witness UTXO hash for input #${inputIndex} doesn't match the hash specified in the prevout`,\n      );\n    }\n    const prevoutIndex = unsignedTx.ins[inputIndex].index;\n    prevout = nonWitnessUtxoTx.outs[prevoutIndex];\n  } else if (input.witnessUtxo) {\n    prevout = input.witnessUtxo;\n  } else {\n    throw new Error('Need a Utxo input item for signing');\n  }\n  const { meaningfulScript, type } = getMeaningfulScript(\n    prevout.script,\n    inputIndex,\n    'input',\n    input.redeemScript,\n    input.witnessScript,\n  );\n  if (['p2sh-p2wsh', 'p2wsh'].indexOf(type) >= 0) {\n    hash = unsignedTx.hashForWitnessV0(\n      inputIndex,\n      meaningfulScript,\n      prevout.value,\n      sighashType,\n    );\n  } else if (isP2WPKH(meaningfulScript)) {\n    // P2WPKH uses the P2PKH template for prevoutScript when signing\n    const signingScript = payments.p2pkh({\n      hash: meaningfulScript.slice(2),\n    }).output;\n    hash = unsignedTx.hashForWitnessV0(\n      inputIndex,\n      signingScript,\n      prevout.value,\n      sighashType,\n    );\n  } else {\n    // non-segwit\n    if (\n      input.nonWitnessUtxo === undefined &&\n      cache.__UNSAFE_SIGN_NONSEGWIT === false\n    )\n      throw new Error(\n        `Input #${inputIndex} has witnessUtxo but non-segwit script: ` +\n          `${tools.toHex(meaningfulScript)}`,\n      );\n    if (!forValidate && cache.__UNSAFE_SIGN_NONSEGWIT !== false)\n      console.warn(\n        'Warning: Signing non-segwit inputs without the full parent transaction ' +\n          'means there is a chance that a miner could feed you incorrect information ' +\n          \"to trick you into paying large fees. This behavior is the same as Psbt's predecessor \" +\n          '(TransactionBuilder - now removed) when signing non-segwit scripts. You are not ' +\n          'able to export this Psbt with toBuffer|toBase64|toHex since it is not ' +\n          'BIP174 compliant.\\n*********************\\nPROCEED WITH CAUTION!\\n' +\n          '*********************',\n      );\n    hash = unsignedTx.hashForSignature(\n      inputIndex,\n      meaningfulScript,\n      sighashType,\n    );\n  }\n  return {\n    script: meaningfulScript,\n    sighashType,\n    hash,\n  };\n}\nfunction getAllTaprootHashesForSig(inputIndex, input, inputs, cache) {\n  const allPublicKeys = [];\n  if (input.tapInternalKey) {\n    const key = getPrevoutTaprootKey(inputIndex, input, cache);\n    if (key) {\n      allPublicKeys.push(key);\n    }\n  }\n  if (input.tapScriptSig) {\n    const tapScriptPubkeys = input.tapScriptSig.map(tss => tss.pubkey);\n    allPublicKeys.push(...tapScriptPubkeys);\n  }\n  const allHashes = allPublicKeys.map(publicKey =>\n    getTaprootHashesForSig(inputIndex, input, inputs, publicKey, cache),\n  );\n  return allHashes.flat();\n}\nfunction getPrevoutTaprootKey(inputIndex, input, cache) {\n  const { script } = getScriptAndAmountFromUtxo(inputIndex, input, cache);\n  return isP2TR(script) ? script.subarray(2, 34) : null;\n}\nfunction trimTaprootSig(signature) {\n  return signature.length === 64 ? signature : signature.subarray(0, 64);\n}\nfunction getTaprootHashesForSig(\n  inputIndex,\n  input,\n  inputs,\n  pubkey,\n  cache,\n  tapLeafHashToSign,\n  allowedSighashTypes,\n) {\n  const unsignedTx = cache.__TX;\n  const sighashType = input.sighashType || Transaction.SIGHASH_DEFAULT;\n  checkSighashTypeAllowed(sighashType, allowedSighashTypes);\n  const prevOuts = inputs.map((i, index) =>\n    getScriptAndAmountFromUtxo(index, i, cache),\n  );\n  const signingScripts = prevOuts.map(o => o.script);\n  const values = prevOuts.map(o => o.value);\n  const hashes = [];\n  if (input.tapInternalKey && !tapLeafHashToSign) {\n    const outputKey =\n      getPrevoutTaprootKey(inputIndex, input, cache) || Uint8Array.from([]);\n    if (tools.compare(toXOnly(pubkey), outputKey) === 0) {\n      const tapKeyHash = unsignedTx.hashForWitnessV1(\n        inputIndex,\n        signingScripts,\n        values,\n        sighashType,\n      );\n      hashes.push({ pubkey, hash: tapKeyHash });\n    }\n  }\n  const tapLeafHashes = (input.tapLeafScript || [])\n    .filter(tapLeaf => pubkeyInScript(pubkey, tapLeaf.script))\n    .map(tapLeaf => {\n      const hash = tapleafHash({\n        output: tapLeaf.script,\n        version: tapLeaf.leafVersion,\n      });\n      return Object.assign({ hash }, tapLeaf);\n    })\n    .filter(\n      tapLeaf =>\n        !tapLeafHashToSign ||\n        tools.compare(tapLeafHashToSign, tapLeaf.hash) === 0,\n    )\n    .map(tapLeaf => {\n      const tapScriptHash = unsignedTx.hashForWitnessV1(\n        inputIndex,\n        signingScripts,\n        values,\n        sighashType,\n        tapLeaf.hash,\n      );\n      return {\n        pubkey,\n        hash: tapScriptHash,\n        leafHash: tapLeaf.hash,\n      };\n    });\n  return hashes.concat(tapLeafHashes);\n}\nfunction checkSighashTypeAllowed(sighashType, sighashTypes) {\n  if (sighashTypes && sighashTypes.indexOf(sighashType) < 0) {\n    const str = sighashTypeToString(sighashType);\n    throw new Error(\n      `Sighash type is not allowed. Retry the sign method passing the ` +\n        `sighashTypes array of whitelisted types. Sighash type: ${str}`,\n    );\n  }\n}\nfunction getPayment(script, scriptType, partialSig) {\n  let payment;\n  switch (scriptType) {\n    case 'multisig':\n      const sigs = getSortedSigs(script, partialSig);\n      payment = payments.p2ms({\n        output: script,\n        signatures: sigs,\n      });\n      break;\n    case 'pubkey':\n      payment = payments.p2pk({\n        output: script,\n        signature: partialSig[0].signature,\n      });\n      break;\n    case 'pubkeyhash':\n      payment = payments.p2pkh({\n        output: script,\n        pubkey: partialSig[0].pubkey,\n        signature: partialSig[0].signature,\n      });\n      break;\n    case 'witnesspubkeyhash':\n      payment = payments.p2wpkh({\n        output: script,\n        pubkey: partialSig[0].pubkey,\n        signature: partialSig[0].signature,\n      });\n      break;\n  }\n  return payment;\n}\nfunction getScriptFromInput(inputIndex, input, cache) {\n  const unsignedTx = cache.__TX;\n  const res = {\n    script: null,\n    isSegwit: false,\n    isP2SH: false,\n    isP2WSH: false,\n  };\n  res.isP2SH = !!input.redeemScript;\n  res.isP2WSH = !!input.witnessScript;\n  if (input.witnessScript) {\n    res.script = input.witnessScript;\n  } else if (input.redeemScript) {\n    res.script = input.redeemScript;\n  } else {\n    if (input.nonWitnessUtxo) {\n      const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(\n        cache,\n        input,\n        inputIndex,\n      );\n      const prevoutIndex = unsignedTx.ins[inputIndex].index;\n      res.script = nonWitnessUtxoTx.outs[prevoutIndex].script;\n    } else if (input.witnessUtxo) {\n      res.script = input.witnessUtxo.script;\n    }\n  }\n  if (input.witnessScript || isP2WPKH(res.script)) {\n    res.isSegwit = true;\n  }\n  return res;\n}\nfunction getSignersFromHD(inputIndex, inputs, hdKeyPair) {\n  const input = checkForInput(inputs, inputIndex);\n  if (!input.bip32Derivation || input.bip32Derivation.length === 0) {\n    throw new Error('Need bip32Derivation to sign with HD');\n  }\n  const myDerivations = input.bip32Derivation\n    .map(bipDv => {\n      if (tools.compare(bipDv.masterFingerprint, hdKeyPair.fingerprint) === 0) {\n        return bipDv;\n      } else {\n        return;\n      }\n    })\n    .filter(v => !!v);\n  if (myDerivations.length === 0) {\n    throw new Error(\n      'Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint',\n    );\n  }\n  const signers = myDerivations.map(bipDv => {\n    const node = hdKeyPair.derivePath(bipDv.path);\n    if (tools.compare(bipDv.pubkey, node.publicKey) !== 0) {\n      throw new Error('pubkey did not match bip32Derivation');\n    }\n    return node;\n  });\n  return signers;\n}\nfunction getSortedSigs(script, partialSig) {\n  const p2ms = payments.p2ms({ output: script });\n  // for each pubkey in order of p2ms script\n  return p2ms.pubkeys\n    .map(pk => {\n      // filter partialSig array by pubkey being equal\n      return (\n        partialSig.filter(ps => {\n          return tools.compare(ps.pubkey, pk) === 0;\n        })[0] || {}\n      ).signature;\n      // Any pubkey without a match will return undefined\n      // this last filter removes all the undefined items in the array.\n    })\n    .filter(v => !!v);\n}\nfunction scriptWitnessToWitnessStack(buffer) {\n  let offset = 0;\n  function readSlice(n) {\n    offset += n;\n    return buffer.slice(offset - n, offset);\n  }\n  function readVarInt() {\n    const vi = varuint.decode(buffer, offset);\n    offset += varuint.encodingLength(vi.bigintValue);\n    return vi.numberValue;\n  }\n  function readVarSlice() {\n    return readSlice(readVarInt());\n  }\n  function readVector() {\n    const count = readVarInt();\n    const vector = [];\n    for (let i = 0; i < count; i++) vector.push(readVarSlice());\n    return vector;\n  }\n  return readVector();\n}\nfunction sighashTypeToString(sighashType) {\n  let text =\n    sighashType & Transaction.SIGHASH_ANYONECANPAY\n      ? 'SIGHASH_ANYONECANPAY | '\n      : '';\n  const sigMod = sighashType & 0x1f;\n  switch (sigMod) {\n    case Transaction.SIGHASH_ALL:\n      text += 'SIGHASH_ALL';\n      break;\n    case Transaction.SIGHASH_SINGLE:\n      text += 'SIGHASH_SINGLE';\n      break;\n    case Transaction.SIGHASH_NONE:\n      text += 'SIGHASH_NONE';\n      break;\n  }\n  return text;\n}\nfunction addNonWitnessTxCache(cache, input, inputIndex) {\n  cache.__NON_WITNESS_UTXO_BUF_CACHE[inputIndex] = input.nonWitnessUtxo;\n  const tx = Transaction.fromBuffer(input.nonWitnessUtxo);\n  cache.__NON_WITNESS_UTXO_TX_CACHE[inputIndex] = tx;\n  const self = cache;\n  const selfIndex = inputIndex;\n  delete input.nonWitnessUtxo;\n  Object.defineProperty(input, 'nonWitnessUtxo', {\n    enumerable: true,\n    get() {\n      const buf = self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex];\n      const txCache = self.__NON_WITNESS_UTXO_TX_CACHE[selfIndex];\n      if (buf !== undefined) {\n        return buf;\n      } else {\n        const newBuf = txCache.toBuffer();\n        self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = newBuf;\n        return newBuf;\n      }\n    },\n    set(data) {\n      self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = data;\n    },\n  });\n}\nfunction inputFinalizeGetAmts(inputs, tx, cache, mustFinalize) {\n  let inputAmount = 0n;\n  inputs.forEach((input, idx) => {\n    if (mustFinalize && input.finalScriptSig)\n      tx.ins[idx].script = input.finalScriptSig;\n    if (mustFinalize && input.finalScriptWitness) {\n      tx.ins[idx].witness = scriptWitnessToWitnessStack(\n        input.finalScriptWitness,\n      );\n    }\n    if (input.witnessUtxo) {\n      inputAmount += input.witnessUtxo.value;\n    } else if (input.nonWitnessUtxo) {\n      const nwTx = nonWitnessUtxoTxFromCache(cache, input, idx);\n      const vout = tx.ins[idx].index;\n      const out = nwTx.outs[vout];\n      inputAmount += out.value;\n    }\n  });\n  const outputAmount = tx.outs.reduce((total, o) => total + o.value, 0n);\n  const fee = inputAmount - outputAmount;\n  if (fee < 0) {\n    throw new Error('Outputs are spending more than Inputs');\n  }\n  const bytes = tx.virtualSize();\n  cache.__FEE = fee;\n  cache.__EXTRACTED_TX = tx;\n  cache.__FEE_RATE = Math.floor(Number(fee / BigInt(bytes)));\n}\nfunction nonWitnessUtxoTxFromCache(cache, input, inputIndex) {\n  const c = cache.__NON_WITNESS_UTXO_TX_CACHE;\n  if (!c[inputIndex]) {\n    addNonWitnessTxCache(cache, input, inputIndex);\n  }\n  return c[inputIndex];\n}\nfunction getScriptFromUtxo(inputIndex, input, cache) {\n  const { script } = getScriptAndAmountFromUtxo(inputIndex, input, cache);\n  return script;\n}\nfunction getScriptAndAmountFromUtxo(inputIndex, input, cache) {\n  if (input.witnessUtxo !== undefined) {\n    return {\n      script: input.witnessUtxo.script,\n      value: input.witnessUtxo.value,\n    };\n  } else if (input.nonWitnessUtxo !== undefined) {\n    const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(\n      cache,\n      input,\n      inputIndex,\n    );\n    const o = nonWitnessUtxoTx.outs[cache.__TX.ins[inputIndex].index];\n    return { script: o.script, value: o.value };\n  } else {\n    throw new Error(\"Can't find pubkey in input without Utxo data\");\n  }\n}\nfunction pubkeyInInput(pubkey, input, inputIndex, cache) {\n  const script = getScriptFromUtxo(inputIndex, input, cache);\n  const { meaningfulScript } = getMeaningfulScript(\n    script,\n    inputIndex,\n    'input',\n    input.redeemScript,\n    input.witnessScript,\n  );\n  return pubkeyInScript(pubkey, meaningfulScript);\n}\nfunction pubkeyInOutput(pubkey, output, outputIndex, cache) {\n  const script = cache.__TX.outs[outputIndex].script;\n  const { meaningfulScript } = getMeaningfulScript(\n    script,\n    outputIndex,\n    'output',\n    output.redeemScript,\n    output.witnessScript,\n  );\n  return pubkeyInScript(pubkey, meaningfulScript);\n}\nfunction redeemFromFinalScriptSig(finalScript) {\n  if (!finalScript) return;\n  const decomp = bscript.decompile(finalScript);\n  if (!decomp) return;\n  const lastItem = decomp[decomp.length - 1];\n  if (\n    !(lastItem instanceof Uint8Array) ||\n    isPubkeyLike(lastItem) ||\n    isSigLike(lastItem)\n  )\n    return;\n  const sDecomp = bscript.decompile(lastItem);\n  if (!sDecomp) return;\n  return lastItem;\n}\nfunction redeemFromFinalWitnessScript(finalScript) {\n  if (!finalScript) return;\n  const decomp = scriptWitnessToWitnessStack(finalScript);\n  const lastItem = decomp[decomp.length - 1];\n  if (isPubkeyLike(lastItem)) return;\n  const sDecomp = bscript.decompile(lastItem);\n  if (!sDecomp) return;\n  return lastItem;\n}\nfunction compressPubkey(pubkey) {\n  if (pubkey.length === 65) {\n    const parity = pubkey[64] & 1;\n    const newKey = pubkey.slice(0, 33);\n    newKey[0] = 2 | parity;\n    return newKey;\n  }\n  return pubkey.slice();\n}\nfunction isPubkeyLike(buf) {\n  return buf.length === 33 && bscript.isCanonicalPubKey(buf);\n}\nfunction isSigLike(buf) {\n  return bscript.isCanonicalScriptSignature(buf);\n}\nfunction getMeaningfulScript(\n  script,\n  index,\n  ioType,\n  redeemScript,\n  witnessScript,\n) {\n  const isP2SH = isP2SHScript(script);\n  const isP2SHP2WSH = isP2SH && redeemScript && isP2WSHScript(redeemScript);\n  const isP2WSH = isP2WSHScript(script);\n  if (isP2SH && redeemScript === undefined)\n    throw new Error('scriptPubkey is P2SH but redeemScript missing');\n  if ((isP2WSH || isP2SHP2WSH) && witnessScript === undefined)\n    throw new Error(\n      'scriptPubkey or redeemScript is P2WSH but witnessScript missing',\n    );\n  let meaningfulScript;\n  if (isP2SHP2WSH) {\n    meaningfulScript = witnessScript;\n    checkRedeemScript(index, script, redeemScript, ioType);\n    checkWitnessScript(index, redeemScript, witnessScript, ioType);\n    checkInvalidP2WSH(meaningfulScript);\n  } else if (isP2WSH) {\n    meaningfulScript = witnessScript;\n    checkWitnessScript(index, script, witnessScript, ioType);\n    checkInvalidP2WSH(meaningfulScript);\n  } else if (isP2SH) {\n    meaningfulScript = redeemScript;\n    checkRedeemScript(index, script, redeemScript, ioType);\n  } else {\n    meaningfulScript = script;\n  }\n  return {\n    meaningfulScript,\n    type: isP2SHP2WSH\n      ? 'p2sh-p2wsh'\n      : isP2SH\n        ? 'p2sh'\n        : isP2WSH\n          ? 'p2wsh'\n          : 'raw',\n  };\n}\nfunction checkInvalidP2WSH(script) {\n  if (isP2WPKH(script) || isP2SHScript(script)) {\n    throw new Error('P2WPKH or P2SH can not be contained within P2WSH');\n  }\n}\nfunction classifyScript(script) {\n  if (isP2WPKH(script)) return 'witnesspubkeyhash';\n  if (isP2PKH(script)) return 'pubkeyhash';\n  if (isP2MS(script)) return 'multisig';\n  if (isP2PK(script)) return 'pubkey';\n  return 'nonstandard';\n}\nfunction range(n) {\n  return [...Array(n).keys()];\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5823, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 5829, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 5841, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}