{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"file":"config.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/config.ts"],"sourcesContent":["import { ChainId, type ExtendedChain } from '@lifi/types'\nimport type { SDKProvider } from './core/types.js'\nimport type { RPCUrls, SDKBaseConfig, SDKConfig } from './types/internal.js'\n\nexport const config = (() => {\n  const _config: SDKBaseConfig = {\n    integrator: 'lifi-sdk',\n    apiUrl: 'https://li.quest/v1',\n    rpcUrls: {},\n    chains: [],\n    providers: [],\n    preloadChains: true,\n    debug: false,\n  }\n  let _loading: Promise<void> | undefined\n  return {\n    set loading(loading: Promise<void>) {\n      _loading = loading\n    },\n    get() {\n      return _config\n    },\n    set(options: SDKConfig) {\n      const { chains, providers, rpcUrls, ...otherOptions } = options\n      Object.assign(_config, otherOptions)\n      if (chains) {\n        this.setChains(chains)\n      }\n      if (providers) {\n        this.setProviders(providers)\n      }\n      if (rpcUrls) {\n        this.setRPCUrls(rpcUrls)\n      }\n      return _config\n    },\n    setProviders(providers: SDKProvider[]) {\n      const providerMap = new Map(\n        _config.providers.map((provider) => [provider.type, provider])\n      )\n      for (const provider of providers) {\n        providerMap.set(provider.type, provider)\n      }\n      _config.providers = Array.from(providerMap.values())\n    },\n    setChains(chains: ExtendedChain[]) {\n      const rpcUrls = chains.reduce((rpcUrls, chain) => {\n        if (chain.metamask?.rpcUrls?.length) {\n          rpcUrls[chain.id as ChainId] = chain.metamask.rpcUrls\n        }\n        return rpcUrls\n      }, {} as RPCUrls)\n      this.setRPCUrls(rpcUrls, [ChainId.SOL])\n      _config.chains = chains\n      _loading = undefined\n    },\n    async getChains() {\n      if (_loading) {\n        await _loading\n      }\n      return _config.chains\n    },\n    async getChainById(chainId: ChainId) {\n      if (_loading) {\n        await _loading\n      }\n      const chain = _config.chains?.find((chain) => chain.id === chainId)\n      if (!chain) {\n        throw new Error(`ChainId ${chainId} not found`)\n      }\n      return chain\n    },\n    setRPCUrls(rpcUrls: RPCUrls, skipChains?: ChainId[]) {\n      for (const rpcUrlsKey in rpcUrls) {\n        const chainId = Number(rpcUrlsKey) as ChainId\n        const urls = rpcUrls[chainId]\n        if (!urls?.length) {\n          continue\n        }\n        if (!_config.rpcUrls[chainId]?.length) {\n          _config.rpcUrls[chainId] = Array.from(urls)\n        } else if (!skipChains?.includes(chainId)) {\n          const filteredUrls = urls.filter(\n            (url) => !_config.rpcUrls[chainId]?.includes(url)\n          )\n          _config.rpcUrls[chainId].push(...filteredUrls)\n        }\n      }\n    },\n    async getRPCUrls() {\n      if (_loading) {\n        await _loading\n      }\n      return _config.rpcUrls\n    },\n  }\n})()\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 106, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 112, "column": 0}, "map": {"version":3,"file":"version.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/version.ts"],"sourcesContent":["export const name = '@lifi/sdk'\nexport const version = '3.5.0'\n"],"names":[],"mappings":";;;;AAAO,MAAM,IAAI,GAAG,WAAW,CAAA;AACxB,MAAM,OAAO,GAAG,OAAO,CAAA","ignoreList":[0]}},
    {"offset": {"line": 118, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 124, "column": 0}, "map": {"version":3,"file":"SDKError.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/errors/SDKError.ts"],"sourcesContent":["import type { LiFiStep, Process } from '@lifi/types'\nimport { version } from '../version.js'\nimport type { BaseError } from './baseError.js'\nimport type { ErrorCode } from './constants.js'\n\n// Note: SDKError is used to wrapper and present errors at the top level\n// Where opportunity allows we also add the step and the process related to the error\nexport class SDKError extends Error {\n  step?: LiFiStep\n  process?: Process\n  code: ErrorCode\n  override name = 'SDKError'\n  override cause: BaseError\n\n  constructor(cause: BaseError, step?: LiFiStep, process?: Process) {\n    const errorMessage = `${cause.message ? `[${cause.name}] ${cause.message}` : 'Unknown error occurred'}\\nLI.FI SDK version: ${version}`\n    super(errorMessage)\n    this.name = 'SDKError'\n    this.step = step\n    this.process = process\n    this.cause = cause\n    this.stack = this.cause.stack\n    this.code = cause.code\n  }\n}\n"],"names":[],"mappings":";;;AACA,OAAO,EAAE,OAAO,EAAE,MAAM,eAAe,CAAA;;AAMjC,MAAO,QAAS,SAAQ,KAAK;IAOjC,YAAY,KAAgB,EAAE,IAAe,EAAE,OAAiB,CAAA;QAC9D,MAAM,YAAY,GAAG,GAAG,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAA,CAAA,EAAI,KAAK,CAAC,IAAI,CAAA,EAAA,EAAK,KAAK,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC,wBAAwB,CAAA,qBAAA,0JAAwB,UAAO,EAAE,CAAA;QACtI,KAAK,CAAC,YAAY,CAAC,CAAA;QARrB,OAAA,cAAA,CAAA,IAAA,EAAA,QAAA;;;;;WAAe;QACf,OAAA,cAAA,CAAA,IAAA,EAAA,WAAA;;;;;WAAiB;QACjB,OAAA,cAAA,CAAA,IAAA,EAAA,QAAA;;;;;WAAe;QACN,OAAA,cAAA,CAAA,IAAA,EAAA,QAAA;;;;mBAAO,UAAU;WAAA;QACjB,OAAA,cAAA,CAAA,IAAA,EAAA,SAAA;;;;;WAAgB;QAKvB,IAAI,CAAC,IAAI,GAAG,UAAU,CAAA;QACtB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAA;QAChB,IAAI,CAAC,OAAO,GAAG,OAAO,CAAA;QACtB,IAAI,CAAC,KAAK,GAAG,KAAK,CAAA;QAClB,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAA;QAC7B,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC,IAAI,CAAA;IACxB,CAAC;CACF","ignoreList":[0]}},
    {"offset": {"line": 171, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 177, "column": 0}, "map": {"version":3,"file":"constants.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/errors/constants.ts"],"sourcesContent":["export enum ErrorName {\n  RPCError = 'RPCError',\n  ProviderError = 'ProviderError',\n  ServerError = 'ServerError',\n  TransactionError = 'TransactionError',\n  ValidationError = 'ValidationError',\n  BalanceError = 'BalanceError',\n  NotFoundError = 'NotFoundError',\n  UnknownError = 'UnknownError',\n  SlippageError = 'SlippageError',\n  HTTPError = 'HTTPError',\n}\n\nexport type ErrorCode = LiFiErrorCode\n\nexport enum LiFiErrorCode {\n  InternalError = 1000,\n  ValidationError = 1001,\n  TransactionUnderpriced = 1002,\n  TransactionFailed = 1003,\n  Timeout = 1004,\n  ProviderUnavailable = 1005,\n  NotFound = 1006,\n  ChainSwitchError = 1007,\n  TransactionUnprepared = 1008,\n  GasLimitError = 1009,\n  TransactionCanceled = 1010,\n  SlippageError = 1011,\n  SignatureRejected = 1012,\n  BalanceError = 1013,\n  AllowanceRequired = 1014,\n  InsufficientFunds = 1015,\n  ExchangeRateUpdateCanceled = 1016,\n  WalletChangedDuringExecution = 1017,\n  TransactionExpired = 1018,\n  TransactionSimulationFailed = 1019,\n  TransactionConflict = 1020,\n}\n\nexport enum ErrorMessage {\n  UnknownError = 'Unknown error occurred.',\n  SlippageError = 'The slippage is larger than the defined threshold. Please request a new route to get a fresh quote.',\n  GasLimitLow = 'Gas limit is too low.',\n  TransactionUnderpriced = 'Transaction is underpriced.',\n  TransactionReverted = 'Transaction was reverted.',\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 227, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 233, "column": 0}, "map": {"version":3,"file":"rootCause.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/errors/utils/rootCause.ts"],"sourcesContent":["export const getRootCause = (e: Error | undefined) => {\n  let rootCause = e\n  while (rootCause?.cause) {\n    rootCause = rootCause.cause as Error\n  }\n  return rootCause\n}\n"],"names":[],"mappings":";;;AAAO,MAAM,YAAY,GAAG,CAAC,CAAoB,EAAE,EAAE;IACnD,IAAI,SAAS,GAAG,CAAC,CAAA;IACjB,MAAO,SAAS,EAAE,KAAK,CAAE,CAAC;QACxB,SAAS,GAAG,SAAS,CAAC,KAAc,CAAA;IACtC,CAAC;IACD,OAAO,SAAS,CAAA;AAClB,CAAC,CAAA","ignoreList":[0]}},
    {"offset": {"line": 243, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 249, "column": 0}, "map": {"version":3,"file":"baseError.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/errors/baseError.ts"],"sourcesContent":["import type { ErrorCode, ErrorName } from './constants.js'\nimport { getRootCause } from './utils/rootCause.js'\n\n// Note: we use the BaseErrors to capture errors at specific points in the code\n// they can carry addition to help give more context\nexport class BaseError extends Error {\n  code: ErrorCode\n  override cause?: Error\n\n  constructor(name: ErrorName, code: number, message: string, cause?: Error) {\n    super(message)\n\n    this.name = name\n    this.code = code\n    this.cause = cause\n\n    const rootCause = getRootCause(this.cause)\n    if (rootCause?.stack) {\n      this.stack = rootCause.stack\n    }\n  }\n}\n"],"names":[],"mappings":";;;AACA,OAAO,EAAE,YAAY,EAAE,MAAM,sBAAsB,CAAA;;AAI7C,MAAO,SAAU,SAAQ,KAAK;IAIlC,YAAY,IAAe,EAAE,IAAY,EAAE,OAAe,EAAE,KAAa,CAAA;QACvE,KAAK,CAAC,OAAO,CAAC,CAAA;QAJhB,OAAA,cAAA,CAAA,IAAA,EAAA,QAAA;;;;;WAAe;QACN,OAAA,cAAA,CAAA,IAAA,EAAA,SAAA;;;;;WAAa;QAKpB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAA;QAChB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAA;QAChB,IAAI,CAAC,KAAK,GAAG,KAAK,CAAA;QAElB,MAAM,SAAS,oLAAG,eAAA,AAAY,EAAC,IAAI,CAAC,KAAK,CAAC,CAAA;QAC1C,IAAI,SAAS,EAAE,KAAK,EAAE,CAAC;YACrB,IAAI,CAAC,KAAK,GAAG,SAAS,CAAC,KAAK,CAAA;QAC9B,CAAC;IACH,CAAC;CACF","ignoreList":[0]}},
    {"offset": {"line": 278, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 284, "column": 0}, "map": {"version":3,"file":"errors.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/errors/errors.ts"],"sourcesContent":["import { BaseError } from './baseError.js'\nimport { ErrorName, LiFiErrorCode } from './constants.js'\n\nexport class RPCError extends BaseError {\n  constructor(code: LiFiErrorCode, message: string, cause?: Error) {\n    super(ErrorName.RPCError, code, message, cause)\n  }\n}\n\nexport class ProviderError extends BaseError {\n  constructor(code: LiFiErrorCode, message: string, cause?: Error) {\n    super(ErrorName.ProviderError, code, message, cause)\n  }\n}\n\nexport class TransactionError extends BaseError {\n  constructor(code: LiFiErrorCode, message: string, cause?: Error) {\n    super(ErrorName.TransactionError, code, message, cause)\n  }\n}\n\nexport class UnknownError extends BaseError {\n  constructor(message: string, cause?: Error) {\n    super(ErrorName.UnknownError, LiFiErrorCode.InternalError, message, cause)\n  }\n}\n\nexport class BalanceError extends BaseError {\n  constructor(message: string, cause?: Error) {\n    super(ErrorName.BalanceError, LiFiErrorCode.BalanceError, message, cause)\n  }\n}\n\nexport class ServerError extends BaseError {\n  constructor(message: string) {\n    super(ErrorName.ServerError, LiFiErrorCode.InternalError, message)\n  }\n}\n\nexport class ValidationError extends BaseError {\n  constructor(message: string) {\n    super(ErrorName.ValidationError, LiFiErrorCode.ValidationError, message)\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;AACA,OAAO,EAAE,SAAS,EAAE,aAAa,EAAE,MAAM,gBAAgB,CAAA;AADzD,OAAO,EAAE,SAAS,EAAE,MAAM,gBAAgB,CAAA;;;AAGpC,MAAO,QAAS,6KAAQ,YAAS;IACrC,YAAY,IAAmB,EAAE,OAAe,EAAE,KAAa,CAAA;QAC7D,KAAK,qKAAC,YAAS,CAAC,QAAQ,EAAE,IAAI,EAAE,OAAO,EAAE,KAAK,CAAC,CAAA;IACjD,CAAC;CACF;AAEK,MAAO,aAAc,4KAAQ,aAAS;IAC1C,YAAY,IAAmB,EAAE,OAAe,EAAE,KAAa,CAAA;QAC7D,KAAK,qKAAC,YAAS,CAAC,aAAa,EAAE,IAAI,EAAE,OAAO,EAAE,KAAK,CAAC,CAAA;IACtD,CAAC;CACF;AAEK,MAAO,gBAAiB,SAAQ,gLAAS;IAC7C,YAAY,IAAmB,EAAE,OAAe,EAAE,KAAa,CAAA;QAC7D,KAAK,qKAAC,YAAS,CAAC,gBAAgB,EAAE,IAAI,EAAE,OAAO,EAAE,KAAK,CAAC,CAAA;IACzD,CAAC;CACF;AAEK,MAAO,YAAa,6KAAQ,YAAS;IACzC,YAAY,OAAe,EAAE,KAAa,CAAA;QACxC,KAAK,qKAAC,YAAS,CAAC,YAAY,sKAAE,gBAAa,CAAC,aAAa,EAAE,OAAO,EAAE,KAAK,CAAC,CAAA;IAC5E,CAAC;CACF;AAEK,MAAO,YAAa,6KAAQ,YAAS;IACzC,YAAY,OAAe,EAAE,KAAa,CAAA;QACxC,KAAK,qKAAC,YAAS,CAAC,YAAY,sKAAE,gBAAa,CAAC,YAAY,EAAE,OAAO,EAAE,KAAK,CAAC,CAAA;IAC3E,CAAC;CACF;AAEK,MAAO,WAAY,6KAAQ,YAAS;IACxC,YAAY,OAAe,CAAA;QACzB,KAAK,oKAAC,aAAS,CAAC,WAAW,sKAAE,gBAAa,CAAC,aAAa,EAAE,OAAO,CAAC,CAAA;IACpE,CAAC;CACF;AAEK,MAAO,eAAgB,6KAAQ,YAAS;IAC5C,YAAY,OAAe,CAAA;QACzB,KAAK,qKAAC,YAAS,CAAC,eAAe,sKAAE,gBAAa,CAAC,eAAe,EAAE,OAAO,CAAC,CAAA;IAC1E,CAAC;CACF","ignoreList":[0]}},
    {"offset": {"line": 332, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 338, "column": 0}, "map": {"version":3,"file":"helpers.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/helpers.ts"],"sourcesContent":["import type { LiFiStep, Route } from '@lifi/types'\nimport { SDKError } from './errors/SDKError.js'\nimport { ValidationError } from './errors/errors.js'\nimport { name, version } from './version.js'\n\nexport const checkPackageUpdates = async (\n  packageName?: string,\n  packageVersion?: string\n) => {\n  try {\n    const pkgName = packageName ?? name\n    const response = await fetch(`https://registry.npmjs.org/${pkgName}/latest`)\n    const reponseBody = await response.json()\n    const latestVersion = reponseBody.version\n    const currentVersion = packageVersion ?? version\n\n    if (latestVersion > currentVersion) {\n      console.warn(\n        `${pkgName}: new package version is available. Please update as soon as possible to enjoy the newest features. Current version: ${currentVersion}. Latest version: ${latestVersion}.`\n      )\n    }\n  } catch (_error) {\n    // Cannot verify version, might be network error etc. We don't bother showing anything in that case\n  }\n}\n\n/**\n * Converts a quote to Route\n * @param step - Step returned from the quote endpoint.\n * @param txHash\n * @param chainId\n * @returns - The route to be executed.\n * @throws {BaseError} Throws a ValidationError if the step has missing values.\n */\nexport const convertQuoteToRoute = (step: LiFiStep): Route => {\n  if (!step.estimate.fromAmountUSD) {\n    throw new SDKError(\n      new ValidationError(\"Missing 'fromAmountUSD' in step estimate.\")\n    )\n  }\n\n  if (!step.estimate.toAmountUSD) {\n    throw new SDKError(\n      new ValidationError(\"Missing 'toAmountUSD' in step estimate.\")\n    )\n  }\n\n  const route: Route = {\n    fromToken: step.action.fromToken,\n    toToken: step.action.toToken,\n    fromAmount: step.action.fromAmount,\n    toAmount: step.estimate.toAmount,\n    id: step.id,\n    fromChainId: step.action.fromToken.chainId,\n    toChainId: step.action.toToken.chainId,\n    fromAmountUSD: step.estimate.fromAmountUSD,\n    toAmountUSD: step.estimate.toAmountUSD,\n    steps: [step],\n    toAmountMin: step.estimate.toAmountMin,\n    insurance: { state: 'NOT_INSURABLE', feeAmountUsd: '0' },\n  }\n\n  return route\n}\n\nexport const fetchTxErrorDetails = async (txHash: string, chainId: number) => {\n  try {\n    const response = await fetch(\n      `https://api.tenderly.co/api/v1/public-contract/${chainId}/tx/${txHash}`\n    )\n    const reponseBody = await response.json()\n\n    return reponseBody\n  } catch (_) {}\n}\n"],"names":[],"mappings":";;;;;AAGA,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE,MAAM,cAAc,CAAA;AAF5C,OAAO,EAAE,QAAQ,EAAE,MAAM,sBAAsB,CAAA;AAC/C,OAAO,EAAE,eAAe,EAAE,MAAM,oBAAoB,CAAA;;;;AAG7C,MAAM,mBAAmB,GAAG,KAAK,EACtC,WAAoB,EACpB,cAAuB,EACvB,EAAE;IACF,IAAI,CAAC;QACH,MAAM,OAAO,GAAG,WAAW,4JAAI,OAAI,CAAA;QACnC,MAAM,QAAQ,GAAG,MAAM,KAAK,CAAC,CAAA,2BAAA,EAA8B,OAAO,CAAA,OAAA,CAAS,CAAC,CAAA;QAC5E,MAAM,WAAW,GAAG,MAAM,QAAQ,CAAC,IAAI,EAAE,CAAA;QACzC,MAAM,aAAa,GAAG,WAAW,CAAC,OAAO,CAAA;QACzC,MAAM,cAAc,GAAG,cAAc,4JAAI,UAAO,CAAA;QAEhD,IAAI,aAAa,GAAG,cAAc,EAAE,CAAC;YACnC,OAAO,CAAC,IAAI,CACV,GAAG,OAAO,CAAA,qHAAA,EAAwH,cAAc,CAAA,kBAAA,EAAqB,aAAa,CAAA,CAAA,CAAG,CACtL,CAAA;QACH,CAAC;IACH,CAAC,CAAC,OAAO,MAAM,EAAE,CAAC;IAChB,mGAAmG;IACrG,CAAC;AACH,CAAC,CAAA;AAUM,MAAM,mBAAmB,GAAG,CAAC,IAAc,EAAS,EAAE;IAC3D,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,aAAa,EAAE,CAAC;QACjC,MAAM,uKAAI,WAAQ,CAChB,qKAAI,kBAAe,CAAC,2CAA2C,CAAC,CACjE,CAAA;IACH,CAAC;IAED,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,WAAW,EAAE,CAAC;QAC/B,MAAM,uKAAI,WAAQ,CAChB,qKAAI,kBAAe,CAAC,yCAAyC,CAAC,CAC/D,CAAA;IACH,CAAC;IAED,MAAM,KAAK,GAAU;QACnB,SAAS,EAAE,IAAI,CAAC,MAAM,CAAC,SAAS;QAChC,OAAO,EAAE,IAAI,CAAC,MAAM,CAAC,OAAO;QAC5B,UAAU,EAAE,IAAI,CAAC,MAAM,CAAC,UAAU;QAClC,QAAQ,EAAE,IAAI,CAAC,QAAQ,CAAC,QAAQ;QAChC,EAAE,EAAE,IAAI,CAAC,EAAE;QACX,WAAW,EAAE,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,OAAO;QAC1C,SAAS,EAAE,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,OAAO;QACtC,aAAa,EAAE,IAAI,CAAC,QAAQ,CAAC,aAAa;QAC1C,WAAW,EAAE,IAAI,CAAC,QAAQ,CAAC,WAAW;QACtC,KAAK,EAAE;YAAC,IAAI;SAAC;QACb,WAAW,EAAE,IAAI,CAAC,QAAQ,CAAC,WAAW;QACtC,SAAS,EAAE;YAAE,KAAK,EAAE,eAAe;YAAE,YAAY,EAAE,GAAG;QAAA,CAAE;KACzD,CAAA;IAED,OAAO,KAAK,CAAA;AACd,CAAC,CAAA;AAEM,MAAM,mBAAmB,GAAG,KAAK,EAAE,MAAc,EAAE,OAAe,EAAE,EAAE;IAC3E,IAAI,CAAC;QACH,MAAM,QAAQ,GAAG,MAAM,KAAK,CAC1B,CAAA,+CAAA,EAAkD,OAAO,CAAA,IAAA,EAAO,MAAM,EAAE,CACzE,CAAA;QACD,MAAM,WAAW,GAAG,MAAM,QAAQ,CAAC,IAAI,EAAE,CAAA;QAEzC,OAAO,WAAW,CAAA;IACpB,CAAC,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;AAChB,CAAC,CAAA","ignoreList":[0]}},
    {"offset": {"line": 398, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 404, "column": 0}, "map": {"version":3,"file":"httpError.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/errors/httpError.ts"],"sourcesContent":["import type { UnavailableRoutes } from '@lifi/types'\nimport type { ExtendedRequestInit } from '../types/request.js'\nimport { BaseError } from './baseError.js'\nimport { LiFiErrorCode } from './constants.js'\nimport { ErrorMessage, ErrorName } from './constants.js'\n\ninterface ServerErrorResponseBody {\n  code: number\n  message: string\n  errors?: UnavailableRoutes\n}\n\nconst statusCodeToErrorClassificationMap = new Map([\n  [\n    400,\n    { type: ErrorName.ValidationError, code: LiFiErrorCode.ValidationError },\n  ],\n  [404, { type: ErrorName.NotFoundError, code: LiFiErrorCode.NotFound }],\n  [\n    409,\n    {\n      type: ErrorName.SlippageError,\n      code: LiFiErrorCode.SlippageError,\n      message: ErrorMessage.SlippageError,\n    },\n  ],\n  [500, { type: ErrorName.ServerError, code: LiFiErrorCode.InternalError }],\n])\n\nconst getErrorClassificationFromStatusCode = (code: number) =>\n  statusCodeToErrorClassificationMap.get(code) ?? {\n    type: ErrorName.ServerError,\n    code: LiFiErrorCode.InternalError,\n  }\n\nconst createInitialMessage = (response: Response) => {\n  const statusCode =\n    response.status || response.status === 0 ? response.status : ''\n  const title = response.statusText || ''\n  const status = `${statusCode} ${title}`.trim()\n  const reason = status ? `status code ${status}` : 'an unknown error'\n  return `Request failed with ${reason}`\n}\n\nexport class HTTPError extends BaseError {\n  public response: Response\n  public status: number\n  public url: RequestInfo | URL\n  public fetchOptions: ExtendedRequestInit\n  public type?: ErrorName\n  public responseBody?: ServerErrorResponseBody\n\n  constructor(\n    response: Response,\n    url: RequestInfo | URL,\n    options: ExtendedRequestInit\n  ) {\n    const errorClassification = getErrorClassificationFromStatusCode(\n      response.status\n    )\n    const additionalMessage = errorClassification?.message\n      ? `\\n${errorClassification.message}`\n      : ''\n    const message = createInitialMessage(response) + additionalMessage\n\n    super(ErrorName.HTTPError, errorClassification.code, message)\n\n    this.type = errorClassification.type\n    this.response = response\n    this.status = response.status\n    this.message = message\n    this.url = url\n    this.fetchOptions = options\n  }\n\n  async buildAdditionalDetails() {\n    if (this.type) {\n      this.message = `[${this.type}] ${this.message}`\n    }\n\n    try {\n      this.responseBody = await this.response.json()\n\n      if (this.responseBody) {\n        this.message += this.message.endsWith('.')\n          ? ` ${this.responseBody?.message.toString()}`\n          : `. ${this.responseBody?.message.toString()}`\n      }\n    } catch {}\n\n    return this\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 516, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 522, "column": 0}, "map": {"version":3,"file":"sleep.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/utils/sleep.ts"],"sourcesContent":["export function sleep(ms: number): Promise<null> {\n  return new Promise((resolve) => {\n    setTimeout(() => resolve(null), ms)\n  })\n}\n"],"names":[],"mappings":";;;AAAM,SAAU,KAAK,CAAC,EAAU;IAC9B,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE;QAC7B,UAAU,CAAC,GAAG,CAAG,CAAD,MAAQ,CAAC,IAAI,CAAC,EAAE,EAAE,CAAC,CAAA;IACrC,CAAC,CAAC,CAAA;AACJ,CAAC","ignoreList":[0]}},
    {"offset": {"line": 530, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 536, "column": 0}, "map": {"version":3,"file":"request.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/request.ts"],"sourcesContent":["import { config } from './config.js'\nimport { SDKError } from './errors/SDKError.js'\nimport { ValidationError } from './errors/errors.js'\nimport { HTTPError } from './errors/httpError.js'\nimport type { ExtendedRequestInit } from './types/request.js'\nimport { sleep } from './utils/sleep.js'\nimport { version } from './version.js'\n\nexport const requestSettings = {\n  retries: 1,\n}\n\nconst stripExtendRequestInitProperties = ({\n  retries,\n  ...rest\n}: ExtendedRequestInit): RequestInit => ({\n  ...rest,\n})\n\nexport const request = async <T = Response>(\n  url: RequestInfo | URL,\n  options: ExtendedRequestInit = {\n    retries: requestSettings.retries,\n  }\n): Promise<T> => {\n  const { userId, integrator, widgetVersion, apiKey } = config.get()\n\n  if (!integrator) {\n    throw new SDKError(\n      new ValidationError(\n        'You need to provide the Integrator property. Please see documentation https://docs.li.fi/integrate-li.fi-js-sdk/set-up-the-sdk'\n      )\n    )\n  }\n\n  options.retries = options.retries ?? requestSettings.retries\n\n  try {\n    if (apiKey) {\n      options.headers = {\n        ...options.headers,\n        'x-lifi-api-key': apiKey,\n      }\n    }\n\n    if (userId) {\n      options.headers = {\n        ...options.headers,\n        'x-lifi-userid': userId,\n      }\n    }\n\n    if (widgetVersion) {\n      options.headers = {\n        ...options.headers,\n        'x-lifi-widget': widgetVersion,\n      }\n    }\n\n    if (version) {\n      options.headers = {\n        ...options.headers,\n        'x-lifi-sdk': version,\n      }\n    }\n\n    // integrator is mandatory during SDK initialization\n    options.headers = {\n      ...options.headers,\n      'x-lifi-integrator': integrator,\n    }\n\n    const response: Response = await fetch(\n      url,\n      stripExtendRequestInitProperties(options)\n    )\n\n    if (!response.ok) {\n      throw new HTTPError(response, url, options)\n    }\n\n    return await response.json()\n  } catch (error) {\n    if (options.retries > 0 && (error as HTTPError).status === 500) {\n      await sleep(500)\n      return request<T>(url, { ...options, retries: options.retries - 1 })\n    }\n\n    await (error as HTTPError).buildAdditionalDetails?.()\n\n    throw new SDKError(error as HTTPError)\n  }\n}\n"],"names":[],"mappings":";;;;AAAA,OAAO,EAAE,MAAM,EAAE,MAAM,aAAa,CAAA;AACpC,OAAO,EAAE,QAAQ,EAAE,MAAM,sBAAsB,CAAA;AAC/C,OAAO,EAAE,eAAe,EAAE,MAAM,oBAAoB,CAAA;AAIpD,OAAO,EAAE,OAAO,EAAE,MAAM,cAAc,CAAA;AAHtC,OAAO,EAAE,SAAS,EAAE,MAAM,uBAAuB,CAAA;AAEjD,OAAO,EAAE,KAAK,EAAE,MAAM,kBAAkB,CAAA;;;;;;;AAGjC,MAAM,eAAe,GAAG;IAC7B,OAAO,EAAE,CAAC;CACX,CAAA;AAED,MAAM,gCAAgC,GAAG,CAAC,EACxC,OAAO,EACP,GAAG,IAAI,EACa,EAAe,CAAG,CAAD,AAAE;QACvC,GAAG,IAAI;KACR,CAAC,CAAA;AAEK,MAAM,OAAO,GAAG,KAAK,EAC1B,GAAsB,EACtB,UAA+B;IAC7B,OAAO,EAAE,eAAe,CAAC,OAAO;CACjC,EACW,EAAE;IACd,MAAM,EAAE,MAAM,EAAE,UAAU,EAAE,aAAa,EAAE,MAAM,EAAE,0JAAG,SAAM,CAAC,GAAG,EAAE,CAAA;IAElE,IAAI,CAAC,UAAU,EAAE,CAAC;QAChB,MAAM,uKAAI,WAAQ,CAChB,qKAAI,kBAAe,CACjB,gIAAgI,CACjI,CACF,CAAA;IACH,CAAC;IAED,OAAO,CAAC,OAAO,GAAG,OAAO,CAAC,OAAO,IAAI,eAAe,CAAC,OAAO,CAAA;IAE5D,IAAI,CAAC;QACH,IAAI,MAAM,EAAE,CAAC;YACX,OAAO,CAAC,OAAO,GAAG;gBAChB,GAAG,OAAO,CAAC,OAAO;gBAClB,gBAAgB,EAAE,MAAM;aACzB,CAAA;QACH,CAAC;QAED,IAAI,MAAM,EAAE,CAAC;YACX,OAAO,CAAC,OAAO,GAAG;gBAChB,GAAG,OAAO,CAAC,OAAO;gBAClB,eAAe,EAAE,MAAM;aACxB,CAAA;QACH,CAAC;QAED,IAAI,aAAa,EAAE,CAAC;YAClB,OAAO,CAAC,OAAO,GAAG;gBAChB,GAAG,OAAO,CAAC,OAAO;gBAClB,eAAe,EAAE,aAAa;aAC/B,CAAA;QACH,CAAC;QAED,IAAI,kKAAO,EAAE,CAAC;YACZ,OAAO,CAAC,OAAO,GAAG;gBAChB,GAAG,OAAO,CAAC,OAAO;gBAClB,YAAY,0JAAE,UAAO;aACtB,CAAA;QACH,CAAC;QAED,oDAAoD;QACpD,OAAO,CAAC,OAAO,GAAG;YAChB,GAAG,OAAO,CAAC,OAAO;YAClB,mBAAmB,EAAE,UAAU;SAChC,CAAA;QAED,MAAM,QAAQ,GAAa,MAAM,KAAK,CACpC,GAAG,EACH,gCAAgC,CAAC,OAAO,CAAC,CAC1C,CAAA;QAED,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE,CAAC;YACjB,MAAM,wKAAI,YAAS,CAAC,QAAQ,EAAE,GAAG,EAAE,OAAO,CAAC,CAAA;QAC7C,CAAC;QAED,OAAO,MAAM,QAAQ,CAAC,IAAI,EAAE,CAAA;IAC9B,CAAC,CAAC,OAAO,KAAK,EAAE,CAAC;QACf,IAAI,OAAO,CAAC,OAAO,GAAG,CAAC,IAAK,KAAmB,CAAC,MAAM,KAAK,GAAG,EAAE,CAAC;YAC/D,yKAAM,QAAA,AAAK,EAAC,GAAG,CAAC,CAAA;YAChB,OAAO,OAAO,CAAI,GAAG,EAAE;gBAAE,GAAG,OAAO;gBAAE,OAAO,EAAE,OAAO,CAAC,OAAO,GAAG,CAAC;YAAA,CAAE,CAAC,CAAA;QACtE,CAAC;QAED,MAAO,KAAmB,CAAC,sBAAsB,EAAE,EAAE,CAAA;QAErD,MAAM,uKAAI,WAAQ,CAAC,KAAkB,CAAC,CAAA;IACxC,CAAC;AACH,CAAC,CAAA","ignoreList":[0]}},
    {"offset": {"line": 613, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 619, "column": 0}, "map": {"version":3,"file":"withDedupe.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/utils/withDedupe.ts"],"sourcesContent":["/**\n * Map with a LRU (Least recently used) policy.\n *\n * https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU\n */\nexport class LruMap<value = unknown> extends Map<string, value> {\n  maxSize: number\n\n  constructor(size: number) {\n    super()\n    this.maxSize = size\n  }\n\n  override set(key: string, value: value) {\n    super.set(key, value)\n    if (this.maxSize && this.size > this.maxSize) {\n      this.delete(this.keys().next().value!)\n    }\n    return this\n  }\n}\n\n/** @internal */\nexport const promiseCache = /*#__PURE__*/ new LruMap<Promise<any>>(8192)\n\ntype WithDedupeOptions = {\n  enabled?: boolean | undefined\n  id?: string | undefined\n}\n\n/** Deduplicates in-flight promises. */\nexport function withDedupe<T>(\n  fn: () => Promise<T>,\n  { enabled = true, id }: WithDedupeOptions\n): Promise<T> {\n  if (!enabled || !id) {\n    return fn()\n  }\n  if (promiseCache.get(id)) {\n    return promiseCache.get(id)!\n  }\n  const promise = fn().finally(() => promiseCache.delete(id))\n  promiseCache.set(id, promise)\n  return promise\n}\n"],"names":[],"mappings":"AAAA;;;;GAIG;;;;;AACG,MAAO,MAAwB,SAAQ,GAAkB;IAG7D,YAAY,IAAY,CAAA;QACtB,KAAK,EAAE,CAAA;QAHT,OAAA,cAAA,CAAA,IAAA,EAAA,WAAA;;;;;WAAe;QAIb,IAAI,CAAC,OAAO,GAAG,IAAI,CAAA;IACrB,CAAC;IAEQ,GAAG,CAAC,GAAW,EAAE,KAAY,EAAA;QACpC,KAAK,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC,CAAA;QACrB,IAAI,IAAI,CAAC,OAAO,IAAI,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,OAAO,EAAE,CAAC;YAC7C,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,IAAI,EAAE,CAAC,KAAM,CAAC,CAAA;QACxC,CAAC;QACD,OAAO,IAAI,CAAA;IACb,CAAC;CACF;AAGM,MAAM,YAAY,GAAG,WAAA,EAAa,CAAC,IAAI,MAAM,CAAe,IAAI,CAAC,CAAA;AAQlE,SAAU,UAAU,CACxB,EAAoB,EACpB,EAAE,OAAO,GAAG,IAAI,EAAE,EAAE,EAAqB;IAEzC,IAAI,CAAC,OAAO,IAAI,CAAC,EAAE,EAAE,CAAC;QACpB,OAAO,EAAE,EAAE,CAAA;IACb,CAAC;IACD,IAAI,YAAY,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,CAAC;QACzB,OAAO,YAAY,CAAC,GAAG,CAAC,EAAE,CAAE,CAAA;IAC9B,CAAC;IACD,MAAM,OAAO,GAAG,EAAE,EAAE,CAAC,OAAO,CAAC,GAAG,CAAG,CAAD,WAAa,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,CAAA;IAC3D,YAAY,CAAC,GAAG,CAAC,EAAE,EAAE,OAAO,CAAC,CAAA;IAC7B,OAAO,OAAO,CAAA;AAChB,CAAC","ignoreList":[0]}},
    {"offset": {"line": 659, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 665, "column": 0}, "map": {"version":3,"file":"typeguards.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/typeguards.ts"],"sourcesContent":["import type {\n  Action,\n  Estimate,\n  LiFiStep,\n  RouteOptions,\n  RoutesRequest,\n  StaticToken,\n} from '@lifi/types'\n\nexport const isRoutesRequest = (\n  routesRequest: RoutesRequest\n): routesRequest is RoutesRequest => {\n  const {\n    fromChainId,\n    fromAmount,\n    fromTokenAddress,\n    toChainId,\n    toTokenAddress,\n    options,\n  } = routesRequest\n\n  return (\n    typeof fromChainId === 'number' &&\n    typeof fromAmount === 'string' &&\n    fromAmount !== '' &&\n    typeof fromTokenAddress === 'string' &&\n    fromTokenAddress !== '' &&\n    typeof toChainId === 'number' &&\n    typeof toTokenAddress === 'string' &&\n    toTokenAddress !== '' &&\n    (!options || isRoutesOptions(options))\n  )\n}\n\nconst isRoutesOptions = (\n  routeOptions: RouteOptions\n): routeOptions is RouteOptions =>\n  !routeOptions?.slippage || typeof routeOptions.slippage === 'number'\n\nexport const isStep = (step: LiFiStep): step is LiFiStep => {\n  const { id, type, tool, action, estimate } = step\n\n  return (\n    typeof id === 'string' &&\n    ['swap', 'cross', 'lifi'].includes(type) &&\n    typeof tool === 'string' &&\n    isAction(action) &&\n    isEstimate(estimate)\n  )\n}\n\nconst isAction = (action: Action): action is Action => {\n  const { fromChainId, fromAmount, fromToken, toChainId, toToken, slippage } =\n    action\n\n  return (\n    typeof fromChainId === 'number' &&\n    typeof fromAmount === 'string' &&\n    fromAmount !== '' &&\n    isToken(fromToken) &&\n    typeof toChainId === 'number' &&\n    isToken(toToken) &&\n    typeof slippage === 'number'\n  )\n}\n\nconst isEstimate = (estimate: Estimate): estimate is Estimate => {\n  const { fromAmount, toAmount, toAmountMin, approvalAddress } = estimate\n\n  return (\n    typeof fromAmount === 'string' &&\n    fromAmount !== '' &&\n    typeof toAmount === 'string' &&\n    toAmount !== '' &&\n    typeof toAmountMin === 'string' &&\n    toAmountMin !== '' &&\n    typeof approvalAddress === 'string'\n  )\n}\n\nexport const isToken = (token: StaticToken): token is StaticToken => {\n  const { address, decimals, chainId } = token\n\n  return (\n    typeof address === 'string' &&\n    typeof decimals === 'number' &&\n    typeof chainId === 'number'\n  )\n}\n"],"names":[],"mappings":";;;;;AASO,MAAM,eAAe,GAAG,CAC7B,aAA4B,EACI,EAAE;IAClC,MAAM,EACJ,WAAW,EACX,UAAU,EACV,gBAAgB,EAChB,SAAS,EACT,cAAc,EACd,OAAO,EACR,GAAG,aAAa,CAAA;IAEjB,OAAO,AACL,OAAO,WAAW,KAAK,QAAQ,IAC/B,OAAO,UAAU,KAAK,QAAQ,IAC9B,UAAU,KAAK,EAAE,IACjB,OAAO,gBAAgB,KAAK,QAAQ,IACpC,gBAAgB,KAAK,EAAE,IACvB,OAAO,SAAS,KAAK,QAAQ,IAC7B,OAAO,cAAc,KAAK,QAAQ,IAClC,cAAc,KAAK,EAAE,IACrB,CAAC,CAAC,OAAO,IAAI,eAAe,CAAC,OAAO,CAAC,CAAC,CACvC,CAAA;AACH,CAAC,CAAA;AAED,MAAM,eAAe,GAAG,CACtB,YAA0B,EACI,CAC9B,CADgC,AAC/B,YAAY,EAAE,QAAQ,IAAI,OAAO,YAAY,CAAC,QAAQ,KAAK,QAAQ,CAAA;AAE/D,MAAM,MAAM,GAAG,CAAC,IAAc,EAAoB,EAAE;IACzD,MAAM,EAAE,EAAE,EAAE,IAAI,EAAE,IAAI,EAAE,MAAM,EAAE,QAAQ,EAAE,GAAG,IAAI,CAAA;IAEjD,OACE,AADK,OACE,EAAE,KAAK,QAAQ,IACtB;QAAC,MAAM;QAAE,OAAO;QAAE,MAAM;KAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,IACxC,OAAO,IAAI,KAAK,QAAQ,IACxB,QAAQ,CAAC,MAAM,CAAC,IAChB,UAAU,CAAC,QAAQ,CAAC,CACrB,CAAA;AACH,CAAC,CAAA;AAED,MAAM,QAAQ,GAAG,CAAC,MAAc,EAAoB,EAAE;IACpD,MAAM,EAAE,WAAW,EAAE,UAAU,EAAE,SAAS,EAAE,SAAS,EAAE,OAAO,EAAE,QAAQ,EAAE,GACxE,MAAM,CAAA;IAER,OAAO,AACL,OAAO,WAAW,KAAK,QAAQ,IAC/B,OAAO,UAAU,KAAK,QAAQ,IAC9B,UAAU,KAAK,EAAE,IACjB,OAAO,CAAC,SAAS,CAAC,IAClB,OAAO,SAAS,KAAK,QAAQ,IAC7B,OAAO,CAAC,OAAO,CAAC,IAChB,OAAO,QAAQ,KAAK,QAAQ,CAC7B,CAAA;AACH,CAAC,CAAA;AAED,MAAM,UAAU,GAAG,CAAC,QAAkB,EAAwB,EAAE;IAC9D,MAAM,EAAE,UAAU,EAAE,QAAQ,EAAE,WAAW,EAAE,eAAe,EAAE,GAAG,QAAQ,CAAA;IAEvE,OAAO,AACL,OAAO,UAAU,KAAK,QAAQ,IAC9B,UAAU,KAAK,EAAE,IACjB,OAAO,QAAQ,KAAK,QAAQ,IAC5B,QAAQ,KAAK,EAAE,IACf,OAAO,WAAW,KAAK,QAAQ,IAC/B,WAAW,KAAK,EAAE,IAClB,OAAO,eAAe,KAAK,QAAQ,CACpC,CAAA;AACH,CAAC,CAAA;AAEM,MAAM,OAAO,GAAG,CAAC,KAAkB,EAAwB,EAAE;IAClE,MAAM,EAAE,OAAO,EAAE,QAAQ,EAAE,OAAO,EAAE,GAAG,KAAK,CAAA;IAE5C,OAAO,AACL,OAAO,OAAO,KAAK,QAAQ,IAC3B,OAAO,QAAQ,KAAK,QAAQ,IAC5B,OAAO,OAAO,KAAK,QAAQ,CAC5B,CAAA;AACH,CAAC,CAAA","ignoreList":[0]}},
    {"offset": {"line": 695, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 701, "column": 0}, "map": {"version":3,"file":"api.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/services/api.ts"],"sourcesContent":["import {\n  type ChainId,\n  type ChainKey,\n  type ChainsRequest,\n  type ChainsResponse,\n  type ConnectionsRequest,\n  type ConnectionsResponse,\n  type ContractCallsQuoteRequest,\n  type ExtendedChain,\n  type GasRecommendationRequest,\n  type GasRecommendationResponse,\n  type GetStatusRequest,\n  type LiFiStep,\n  type QuoteRequest,\n  type RequestOptions,\n  type RoutesRequest,\n  type RoutesResponse,\n  type StatusResponse,\n  type Token,\n  type TokensRequest,\n  type TokensResponse,\n  type ToolsRequest,\n  type ToolsResponse,\n  type TransactionAnalyticsRequest,\n  type TransactionAnalyticsResponse,\n  isContractCallsRequestWithFromAmount,\n  isContractCallsRequestWithToAmount,\n} from '@lifi/types'\nimport { config } from '../config.js'\nimport { SDKError } from '../errors/SDKError.js'\nimport { ValidationError } from '../errors/errors.js'\nimport { request } from '../request.js'\nimport { isRoutesRequest, isStep } from '../typeguards.js'\nimport { withDedupe } from '../utils/withDedupe.js'\n/**\n * Fetch information about a Token\n * @param chain - Id or key of the chain that contains the token\n * @param token - Address or symbol of the token on the requested chain\n * @param options - Request options\n * @throws {LiFiError} - Throws a LiFiError if request fails\n * @returns Token information\n */\nexport const getToken = async (\n  chain: ChainKey | ChainId,\n  token: string,\n  options?: RequestOptions\n): Promise<Token> => {\n  if (!chain) {\n    throw new SDKError(\n      new ValidationError('Required parameter \"chain\" is missing.')\n    )\n  }\n  if (!token) {\n    throw new SDKError(\n      new ValidationError('Required parameter \"token\" is missing.')\n    )\n  }\n  return await request<Token>(\n    `${config.get().apiUrl}/token?${new URLSearchParams({\n      chain,\n      token,\n    } as Record<string, string>)}`,\n    {\n      signal: options?.signal,\n    }\n  )\n}\n\n/**\n * Get a quote for a token transfer\n * @param params - The configuration of the requested quote\n * @param options - Request options\n * @throws {LiFiError} - Throws a LiFiError if request fails\n * @returns Quote for a token transfer\n */\nexport const getQuote = async (\n  params: QuoteRequest,\n  options?: RequestOptions\n): Promise<LiFiStep> => {\n  const requiredParameters: Array<keyof QuoteRequest> = [\n    'fromChain',\n    'fromToken',\n    'fromAddress',\n    'fromAmount',\n    'toChain',\n    'toToken',\n  ]\n  for (const requiredParameter of requiredParameters) {\n    if (!params[requiredParameter]) {\n      throw new SDKError(\n        new ValidationError(\n          `Required parameter \"${requiredParameter}\" is missing.`\n        )\n      )\n    }\n  }\n  const _config = config.get()\n  // apply defaults\n  params.integrator ??= _config.integrator\n  params.order ??= _config.routeOptions?.order\n  params.slippage ??= _config.routeOptions?.slippage\n  params.referrer ??= _config.routeOptions?.referrer\n  params.fee ??= _config.routeOptions?.fee\n  params.allowBridges ??= _config.routeOptions?.bridges?.allow\n  params.denyBridges ??= _config.routeOptions?.bridges?.deny\n  params.preferBridges ??= _config.routeOptions?.bridges?.prefer\n  params.allowExchanges ??= _config.routeOptions?.exchanges?.allow\n  params.denyExchanges ??= _config.routeOptions?.exchanges?.deny\n  params.preferExchanges ??= _config.routeOptions?.exchanges?.prefer\n\n  for (const key of Object.keys(params)) {\n    if (!params[key as keyof QuoteRequest]) {\n      delete params[key as keyof QuoteRequest]\n    }\n  }\n\n  return await request<LiFiStep>(\n    `${_config.apiUrl}/quote?${new URLSearchParams(\n      params as unknown as Record<string, string>\n    )}`,\n    {\n      signal: options?.signal,\n    }\n  )\n}\n\n/**\n * Get a quote for a destination contract call\n * @param params - The configuration of the requested destination call\n * @param options - Request options\n * @throws {LiFiError} - Throws a LiFiError if request fails\n * @returns - Returns step.\n */\nexport const getContractCallsQuote = async (\n  params: ContractCallsQuoteRequest,\n  options?: RequestOptions\n): Promise<LiFiStep> => {\n  // validation\n  const requiredParameters: Array<keyof ContractCallsQuoteRequest> = [\n    'fromChain',\n    'fromToken',\n    'fromAddress',\n    'toChain',\n    'toToken',\n    'contractCalls',\n  ]\n  for (const requiredParameter of requiredParameters) {\n    if (!params[requiredParameter]) {\n      throw new SDKError(\n        new ValidationError(\n          `Required parameter \"${requiredParameter}\" is missing.`\n        )\n      )\n    }\n  }\n  if (\n    !isContractCallsRequestWithFromAmount(params) &&\n    !isContractCallsRequestWithToAmount(params)\n  ) {\n    throw new SDKError(\n      new ValidationError(\n        `Required parameter \"fromAmount\" or \"toAmount\" is missing.`\n      )\n    )\n  }\n  const _config = config.get()\n  // apply defaults\n  // option.order is not used in this endpoint\n  params.integrator ??= _config.integrator\n  params.slippage ??= _config.routeOptions?.slippage\n  params.referrer ??= _config.routeOptions?.referrer\n  params.fee ??= _config.routeOptions?.fee\n  params.allowBridges ??= _config.routeOptions?.bridges?.allow\n  params.denyBridges ??= _config.routeOptions?.bridges?.deny\n  params.preferBridges ??= _config.routeOptions?.bridges?.prefer\n  params.allowExchanges ??= _config.routeOptions?.exchanges?.allow\n  params.denyExchanges ??= _config.routeOptions?.exchanges?.deny\n  params.preferExchanges ??= _config.routeOptions?.exchanges?.prefer\n  // send request\n  return await request<LiFiStep>(`${_config.apiUrl}/quote/contractCalls`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify(params),\n    signal: options?.signal,\n  })\n}\n\n/**\n * Check the status of a transfer. For cross chain transfers, the \"bridge\" parameter is required.\n * @param params - Configuration of the requested status\n * @param options - Request options.\n * @throws {LiFiError} - Throws a LiFiError if request fails\n * @returns Returns status response.\n */\nexport const getStatus = async (\n  params: GetStatusRequest,\n  options?: RequestOptions\n): Promise<StatusResponse> => {\n  if (!params.txHash) {\n    throw new SDKError(\n      new ValidationError('Required parameter \"txHash\" is missing.')\n    )\n  }\n  const queryParams = new URLSearchParams(\n    params as unknown as Record<string, string>\n  )\n  return await request<StatusResponse>(\n    `${config.get().apiUrl}/status?${queryParams}`,\n    {\n      signal: options?.signal,\n    }\n  )\n}\n\n/**\n * Get all available chains\n * @param params - The configuration of the requested chains\n * @param options - Request options\n * @returns A list of all available chains\n * @throws {LiFiError} Throws a LiFiError if request fails.\n */\nexport const getChains = async (\n  params?: ChainsRequest,\n  options?: RequestOptions\n): Promise<ExtendedChain[]> => {\n  if (params) {\n    for (const key of Object.keys(params)) {\n      if (!params[key as keyof ChainsRequest]) {\n        delete params[key as keyof ChainsRequest]\n      }\n    }\n  }\n  const urlSearchParams = new URLSearchParams(\n    params as Record<string, string>\n  ).toString()\n  const response = await withDedupe(\n    () =>\n      request<ChainsResponse>(\n        `${config.get().apiUrl}/chains?${urlSearchParams}`,\n        {\n          signal: options?.signal,\n        }\n      ),\n    { id: `${getChains.name}.${urlSearchParams}` }\n  )\n  return response.chains\n}\n\n/**\n * Get a set of routes for a request that describes a transfer of tokens.\n * @param params - A description of the transfer.\n * @param options - Request options\n * @returns The resulting routes that can be used to realize the described transfer of tokens.\n * @throws {LiFiError} Throws a LiFiError if request fails.\n */\nexport const getRoutes = async (\n  params: RoutesRequest,\n  options?: RequestOptions\n): Promise<RoutesResponse> => {\n  if (!isRoutesRequest(params)) {\n    throw new SDKError(new ValidationError('Invalid routes request.'))\n  }\n  const _config = config.get()\n  // apply defaults\n  params.options = {\n    integrator: _config.integrator,\n    ..._config.routeOptions,\n    ...params.options,\n  }\n\n  return await request<RoutesResponse>(`${_config.apiUrl}/advanced/routes`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify(params),\n    signal: options?.signal,\n  })\n}\n\n/**\n * Get the transaction data for a single step of a route\n * @param step - The step object.\n * @param options - Request options\n * @returns The step populated with the transaction data.\n * @throws {LiFiError} Throws a LiFiError if request fails.\n */\nexport const getStepTransaction = async (\n  step: LiFiStep,\n  options?: RequestOptions\n): Promise<LiFiStep> => {\n  if (!isStep(step)) {\n    // While the validation fails for some users we should not enforce it\n    console.warn('SDK Validation: Invalid Step', step)\n  }\n\n  return await request<LiFiStep>(\n    `${config.get().apiUrl}/advanced/stepTransaction`,\n    {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(step),\n      signal: options?.signal,\n    }\n  )\n}\n\n/**\n * Get the available tools to bridge and swap tokens.\n * @param params - The configuration of the requested tools\n * @param options - Request options\n * @returns The tools that are available on the requested chains\n */\nexport const getTools = async (\n  params?: ToolsRequest,\n  options?: RequestOptions\n): Promise<ToolsResponse> => {\n  if (params) {\n    for (const key of Object.keys(params)) {\n      if (!params[key as keyof ToolsRequest]) {\n        delete params[key as keyof ToolsRequest]\n      }\n    }\n  }\n  return await request<ToolsResponse>(\n    `${config.get().apiUrl}/tools?${new URLSearchParams(\n      params as Record<string, string>\n    )}`,\n    {\n      signal: options?.signal,\n    }\n  )\n}\n\n/**\n * Get all known tokens.\n * @param params - The configuration of the requested tokens\n * @param options - Request options\n * @returns The tokens that are available on the requested chains\n */\nexport const getTokens = async (\n  params?: TokensRequest,\n  options?: RequestOptions\n): Promise<TokensResponse> => {\n  if (params) {\n    for (const key of Object.keys(params)) {\n      if (!params[key as keyof TokensRequest]) {\n        delete params[key as keyof TokensRequest]\n      }\n    }\n  }\n  const urlSearchParams = new URLSearchParams(\n    params as Record<string, string>\n  ).toString()\n  const response = await withDedupe(\n    () =>\n      request<TokensResponse>(\n        `${config.get().apiUrl}/tokens?${urlSearchParams}`,\n        {\n          signal: options?.signal,\n        }\n      ),\n    { id: `${getTokens.name}.${urlSearchParams}` }\n  )\n  return response\n}\n\n/**\n * Get gas recommendation for a certain chain\n * @param params - Configuration of the requested gas recommendation.\n * @param options - Request options\n * @throws {LiFiError} Throws a LiFiError if request fails.\n * @returns Gas recommendation response.\n */\nexport const getGasRecommendation = async (\n  params: GasRecommendationRequest,\n  options?: RequestOptions\n): Promise<GasRecommendationResponse> => {\n  if (!params.chainId) {\n    throw new SDKError(\n      new ValidationError('Required parameter \"chainId\" is missing.')\n    )\n  }\n\n  const url = new URL(`${config.get().apiUrl}/gas/suggestion/${params.chainId}`)\n  if (params.fromChain) {\n    url.searchParams.append('fromChain', params.fromChain as unknown as string)\n  }\n  if (params.fromToken) {\n    url.searchParams.append('fromToken', params.fromToken)\n  }\n\n  return await request<GasRecommendationResponse>(url.toString(), {\n    signal: options?.signal,\n  })\n}\n\n/**\n * Get all the available connections for swap/bridging tokens\n * @param connectionRequest ConnectionsRequest\n * @param options - Request options\n * @returns ConnectionsResponse\n */\nexport const getConnections = async (\n  connectionRequest: ConnectionsRequest,\n  options?: RequestOptions\n): Promise<ConnectionsResponse> => {\n  const url = new URL(`${config.get().apiUrl}/connections`)\n\n  const { fromChain, fromToken, toChain, toToken } = connectionRequest\n\n  if (fromChain) {\n    url.searchParams.append('fromChain', fromChain as unknown as string)\n  }\n  if (fromToken) {\n    url.searchParams.append('fromToken', fromToken)\n  }\n  if (toChain) {\n    url.searchParams.append('toChain', toChain as unknown as string)\n  }\n  if (toToken) {\n    url.searchParams.append('toToken', toToken)\n  }\n  const connectionRequestArrayParams: Array<keyof ConnectionsRequest> = [\n    'allowBridges',\n    'denyBridges',\n    'preferBridges',\n    'allowExchanges',\n    'denyExchanges',\n    'preferExchanges',\n  ]\n  for (const parameter of connectionRequestArrayParams) {\n    const connectionRequestArrayParam = connectionRequest[parameter] as string[]\n\n    if (connectionRequestArrayParam?.length) {\n      for (const value of connectionRequestArrayParam) {\n        url.searchParams.append(parameter, value)\n      }\n    }\n  }\n  return await request<ConnectionsResponse>(url, options)\n}\n\nexport const getTransactionHistory = async (\n  { wallet, status, fromTimestamp, toTimestamp }: TransactionAnalyticsRequest,\n  options?: RequestOptions\n): Promise<TransactionAnalyticsResponse> => {\n  if (!wallet) {\n    throw new SDKError(\n      new ValidationError('Required parameter \"wallet\" is missing.')\n    )\n  }\n\n  const _config = config.get()\n\n  const url = new URL(`${_config.apiUrl}/analytics/transfers`)\n\n  url.searchParams.append('integrator', _config.integrator)\n  url.searchParams.append('wallet', wallet)\n\n  if (status) {\n    url.searchParams.append('status', status)\n  }\n\n  if (fromTimestamp) {\n    url.searchParams.append('fromTimestamp', fromTimestamp.toString())\n  }\n\n  if (toTimestamp) {\n    url.searchParams.append('toTimestamp', toTimestamp.toString())\n  }\n\n  return await request<TransactionAnalyticsResponse>(url, options)\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 974, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 980, "column": 0}, "map": {"version":3,"file":"createConfig.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/createConfig.ts"],"sourcesContent":["import { ChainType } from '@lifi/types'\nimport { config } from './config.js'\nimport { checkPackageUpdates } from './helpers.js'\nimport { getChains } from './services/api.js'\nimport type { SDKConfig } from './types/internal.js'\nimport { name, version } from './version.js'\n\nfunction createBaseConfig(options: SDKConfig) {\n  if (!options.integrator) {\n    throw new Error(\n      'Integrator not found. Please see documentation https://docs.li.fi/integrate-li.fi-js-sdk/set-up-the-sdk'\n    )\n  }\n  const _config = config.set(options)\n  if (!options.disableVersionCheck && process.env.NODE_ENV === 'development') {\n    checkPackageUpdates(name, version)\n  }\n  return _config\n}\n\nexport async function createChainsConfig() {\n  config.loading = getChains({\n    chainTypes: [ChainType.EVM, ChainType.SVM, ChainType.UTXO],\n  })\n    .then((chains) => config.setChains(chains))\n    .catch()\n  await config.loading\n}\n\nexport function createConfig(options: SDKConfig) {\n  const _config = createBaseConfig(options)\n  if (_config.preloadChains) {\n    createChainsConfig()\n  }\n  return _config\n}\n"],"names":[],"mappings":";;;;AACA,OAAO,EAAE,MAAM,EAAE,MAAM,aAAa,CAAA;AACpC,OAAO,EAAE,mBAAmB,EAAE,MAAM,cAAc,CAAA;AAGlD,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE,MAAM,cAAc,CAAA;AAF5C,OAAO,EAAE,SAAS,EAAE,MAAM,mBAAmB,CAAA;AAH7C,OAAO,EAAE,SAAS,EAAE,MAAM,aAAa,CAAA;;;;;;AAOvC,SAAS,gBAAgB,CAAC,OAAkB;IAC1C,IAAI,CAAC,OAAO,CAAC,UAAU,EAAE,CAAC;QACxB,MAAM,IAAI,KAAK,CACb,yGAAyG,CAC1G,CAAA;IACH,CAAC;IACD,MAAM,OAAO,0JAAG,SAAM,CAAC,GAAG,CAAC,OAAO,CAAC,CAAA;IACnC,IAAI,CAAC,OAAO,CAAC,mBAAmB,IAAI,OAAO,CAAC,GAAG,CAAC,QAAQ,gCAAK,aAAa,EAAE,CAAC;SAC3E,iLAAA,AAAmB,0JAAC,OAAI,0JAAE,UAAO,CAAC,CAAA;IACpC,CAAC;IACD,OAAO,OAAO,CAAA;AAChB,CAAC;AAEM,KAAK,UAAU,kBAAkB;2JACtC,SAAM,CAAC,OAAO,uKAAG,YAAA,AAAS,EAAC;QACzB,UAAU,EAAE;8KAAC,YAAS,CAAC,GAAG;8KAAE,YAAS,CAAC,GAAG;8KAAE,YAAS,CAAC,IAAI;SAAC;KAC3D,CAAC,CACC,IAAI,CAAC,CAAC,MAAM,EAAE,EAAE,sJAAC,SAAM,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,CAC1C,KAAK,EAAE,CAAA;IACV,6JAAM,SAAM,CAAC,OAAO,CAAA;AACtB,CAAC;AAEK,SAAU,YAAY,CAAC,OAAkB;IAC7C,MAAM,OAAO,GAAG,gBAAgB,CAAC,OAAO,CAAC,CAAA;IACzC,IAAI,OAAO,CAAC,aAAa,EAAE,CAAC;QAC1B,kBAAkB,EAAE,CAAA;IACtB,CAAC;IACD,OAAO,OAAO,CAAA;AAChB,CAAC","ignoreList":[0]}},
    {"offset": {"line": 1021, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1027, "column": 0}, "map": {"version":3,"file":"rpc.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/core/rpc.ts"],"sourcesContent":["import type { ChainId } from '@lifi/types'\nimport { config } from '../config.js'\n\nexport const getRpcUrl = async (chainId: ChainId): Promise<string> => {\n  const rpcUrls = await getRpcUrls(chainId)\n  return rpcUrls[0]\n}\n\nexport const getRpcUrls = async (chainId: ChainId): Promise<string[]> => {\n  const rpcUrls = (await config.getRPCUrls())[chainId]\n  if (!rpcUrls?.length) {\n    throw new Error('RPC URL not found')\n  }\n  return rpcUrls\n}\n"],"names":[],"mappings":";;;;AACA,OAAO,EAAE,MAAM,EAAE,MAAM,cAAc,CAAA;;AAE9B,MAAM,SAAS,GAAG,KAAK,EAAE,OAAgB,EAAmB,EAAE;IACnE,MAAM,OAAO,GAAG,MAAM,UAAU,CAAC,OAAO,CAAC,CAAA;IACzC,OAAO,OAAO,CAAC,CAAC,CAAC,CAAA;AACnB,CAAC,CAAA;AAEM,MAAM,UAAU,GAAG,KAAK,EAAE,OAAgB,EAAqB,EAAE;IACtE,MAAM,OAAO,GAAG,CAAC,6JAAM,SAAM,CAAC,UAAU,EAAE,CAAC,CAAC,OAAO,CAAC,CAAA;IACpD,IAAI,CAAC,OAAO,EAAE,MAAM,EAAE,CAAC;QACrB,MAAM,IAAI,KAAK,CAAC,mBAAmB,CAAC,CAAA;IACtC,CAAC;IACD,OAAO,OAAO,CAAA;AAChB,CAAC,CAAA","ignoreList":[0]}},
    {"offset": {"line": 1044, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1050, "column": 0}, "map": {"version":3,"file":"publicClient.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/core/EVM/publicClient.ts"],"sourcesContent":["import { ChainId } from '@lifi/types'\nimport type { Client } from 'viem'\nimport { http, createClient, fallback, webSocket } from 'viem'\nimport { type Chain, mainnet } from 'viem/chains'\nimport { config } from '../../config.js'\nimport { getRpcUrls } from '../rpc.js'\n\n// cached providers\nconst publicClients: Record<number, Client> = {}\n\n/**\n * Get an instance of a provider for a specific chain\n * @param chainId - Id of the chain the provider is for\n * @returns The public client for the given chain\n */\nexport const getPublicClient = async (chainId: number): Promise<Client> => {\n  if (!publicClients[chainId]) {\n    const urls = await getRpcUrls(chainId)\n    const fallbackTransports = urls.map((url) =>\n      url.startsWith('wss')\n        ? webSocket(url)\n        : http(url, {\n            batch: {\n              batchSize: 64,\n            },\n          })\n    )\n    const _chain = await config.getChainById(chainId)\n    const chain: Chain = {\n      ..._chain,\n      ..._chain.metamask,\n      name: _chain.metamask.chainName,\n      rpcUrls: {\n        default: { http: _chain.metamask.rpcUrls },\n        public: { http: _chain.metamask.rpcUrls },\n      },\n    }\n    // Add ENS contracts\n    if (chain.id === ChainId.ETH) {\n      chain.contracts = {\n        ...mainnet.contracts,\n        ...chain.contracts,\n      }\n    }\n    publicClients[chainId] = createClient({\n      chain: chain,\n      transport: fallback(fallbackTransports),\n      batch: {\n        multicall: true,\n      },\n    })\n  }\n\n  if (!publicClients[chainId]) {\n    throw new Error(`Unable to configure provider for chain ${chainId}`)\n  }\n\n  return publicClients[chainId]\n}\n"],"names":[],"mappings":";;;AAKA,OAAO,EAAE,UAAU,EAAE,MAAM,WAAW,CAAA;AAHtC,OAAO,EAAE,IAAI,EAAE,YAAY,EAAE,QAAQ,EAAE,SAAS,EAAE,MAAM,MAAM,CAAA;;AAE9D,OAAO,EAAE,MAAM,EAAE,MAAM,iBAAiB,CAAA;AAJxC,OAAO,EAAE,OAAO,EAAE,MAAM,aAAa,CAAA;AAGrC,OAAO,EAAc,OAAO,EAAE,MAAM,aAAa,CAAA;;;;;;;;AAIjD,mBAAmB;AACnB,MAAM,aAAa,GAA2B,CAAA,CAAE,CAAA;AAOzC,MAAM,eAAe,GAAG,KAAK,EAAE,OAAe,EAAmB,EAAE;IACxE,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,EAAE,CAAC;QAC5B,MAAM,IAAI,GAAG,MAAM,6KAAA,AAAU,EAAC,OAAO,CAAC,CAAA;QACtC,MAAM,kBAAkB,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,CACxC,CAD0C,EACvC,CAAC,UAAU,CAAC,KAAK,CAAC,0KACjB,YAAA,AAAS,EAAC,GAAG,CAAC,qKACd,OAAI,AAAJ,EAAK,GAAG,EAAE;gBACR,KAAK,EAAE;oBACL,SAAS,EAAE,EAAE;iBACd;aACF,CAAC,CACP,CAAA;QACD,MAAM,MAAM,GAAG,6JAAM,SAAM,CAAC,YAAY,CAAC,OAAO,CAAC,CAAA;QACjD,MAAM,KAAK,GAAU;YACnB,GAAG,MAAM;YACT,GAAG,MAAM,CAAC,QAAQ;YAClB,IAAI,EAAE,MAAM,CAAC,QAAQ,CAAC,SAAS;YAC/B,OAAO,EAAE;gBACP,OAAO,EAAE;oBAAE,IAAI,EAAE,MAAM,CAAC,QAAQ,CAAC,OAAO;gBAAA,CAAE;gBAC1C,MAAM,EAAE;oBAAE,IAAI,EAAE,MAAM,CAAC,QAAQ,CAAC,OAAO;gBAAA,CAAE;aAC1C;SACF,CAAA;QACD,oBAAoB;QACpB,IAAI,KAAK,CAAC,EAAE,sKAAK,UAAO,CAAC,GAAG,EAAE,CAAC;YAC7B,KAAK,CAAC,SAAS,GAAG;gBAChB,mKAAG,WAAO,CAAC,SAAS;gBACpB,GAAG,KAAK,CAAC,SAAS;aACnB,CAAA;QACH,CAAC;QACD,aAAa,CAAC,OAAO,CAAC,+JAAG,eAAA,AAAY,EAAC;YACpC,KAAK,EAAE,KAAK;YACZ,SAAS,wKAAE,WAAA,AAAQ,EAAC,kBAAkB,CAAC;YACvC,KAAK,EAAE;gBACL,SAAS,EAAE,IAAI;aAChB;SACF,CAAC,CAAA;IACJ,CAAC;IAED,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,EAAE,CAAC;QAC5B,MAAM,IAAI,KAAK,CAAC,CAAA,uCAAA,EAA0C,OAAO,EAAE,CAAC,CAAA;IACtE,CAAC;IAED,OAAO,aAAa,CAAC,OAAO,CAAC,CAAA;AAC/B,CAAC,CAAA","ignoreList":[0]}},
    {"offset": {"line": 1110, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1116, "column": 0}, "map": {"version":3,"file":"getENSAddress.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/core/EVM/getENSAddress.ts"],"sourcesContent":["import { ChainId } from '@lifi/types'\nimport { getEnsAddress, normalize } from 'viem/ens'\nimport { getPublicClient } from './publicClient.js'\n\nexport const getENSAddress = async (\n  name: string\n): Promise<string | undefined> => {\n  try {\n    const client = await getPublicClient(ChainId.ETH)\n    const address = await getEnsAddress(client, {\n      name: normalize(name),\n    })\n    return address as string | undefined\n  } catch (_) {\n    // ignore\n    return\n  }\n}\n"],"names":[],"mappings":";;;AAEA,OAAO,EAAE,eAAe,EAAE,MAAM,mBAAmB,CAAA;AAFnD,OAAO,EAAE,OAAO,EAAE,MAAM,aAAa,CAAA;;AACrC,OAAO,EAAE,aAAa,EAAE,SAAS,EAAE,MAAM,UAAU,CAAA;;;;AAG5C,MAAM,aAAa,GAAG,KAAK,EAChC,IAAY,EACiB,EAAE;IAC/B,IAAI,CAAC;QACH,MAAM,MAAM,GAAG,sLAAM,kBAAA,AAAe,mKAAC,UAAO,CAAC,GAAG,CAAC,CAAA;QACjD,MAAM,OAAO,GAAG,0KAAM,gBAAA,AAAa,EAAC,MAAM,EAAE;YAC1C,IAAI,gKAAE,YAAA,AAAS,EAAC,IAAI,CAAC;SACtB,CAAC,CAAA;QACF,OAAO,OAA6B,CAAA;IACtC,CAAC,CAAC,OAAO,CAAC,EAAE,CAAC;QACX,SAAS;QACT,OAAM;IACR,CAAC;AACH,CAAC,CAAA","ignoreList":[0]}},
    {"offset": {"line": 1138, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1144, "column": 0}, "map": {"version":3,"file":"median.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/utils/median.ts"],"sourcesContent":["export const median = (arr: bigint[]): bigint | undefined => {\n  if (!arr.length) {\n    return\n  }\n  const s = [...arr].sort((a, b) => (a > b ? 1 : a < b ? -1 : 0))\n  const mid = Math.floor(s.length / 2)\n  if (s.length % 2 === 0) {\n    return (s[mid - 1] + s[mid]) / 2n\n  }\n  return s[mid]\n}\n"],"names":[],"mappings":";;;AAAO,MAAM,MAAM,GAAG,CAAC,GAAa,EAAsB,EAAE;IAC1D,IAAI,CAAC,GAAG,CAAC,MAAM,EAAE,CAAC;QAChB,OAAM;IACR,CAAC;IACD,MAAM,CAAC,GAAG,CAAC;WAAG,GAAG;KAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAI,CAAF,AAAG,CAAF,EAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAA;IAC/D,MAAM,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,CAAA;IACpC,IAAI,CAAC,CAAC,MAAM,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC;QACvB,OAAO,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,CAAA;IACnC,CAAC;IACD,OAAO,CAAC,CAAC,GAAG,CAAC,CAAA;AACf,CAAC,CAAA","ignoreList":[0]}},
    {"offset": {"line": 1160, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1166, "column": 0}, "map": {"version":3,"file":"utils.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/core/EVM/utils.ts"],"sourcesContent":["import type { ChainId } from '@lifi/types'\nimport type { Client, Transaction } from 'viem'\nimport { getBlock } from 'viem/actions'\nimport { config } from '../../config.js'\nimport { median } from '../../utils/median.js'\n\nexport const getMaxPriorityFeePerGas = async (\n  client: Client\n): Promise<bigint | undefined> => {\n  const block = await getBlock(client, {\n    includeTransactions: true,\n  })\n\n  const maxPriorityFeePerGasList = (block.transactions as Transaction[])\n    .filter((tx) => tx.maxPriorityFeePerGas)\n    .map((tx) => tx.maxPriorityFeePerGas) as bigint[]\n\n  if (!maxPriorityFeePerGasList.length) {\n    return\n  }\n\n  let maxPriorityFeePerGasSum = 0n\n  for (const value of maxPriorityFeePerGasList) {\n    maxPriorityFeePerGasSum += value\n  }\n\n  const maxPriorityFeePerGasMedian = median(maxPriorityFeePerGasList) ?? 0n\n\n  const maxPriorityFeePerGasAvg =\n    maxPriorityFeePerGasSum / BigInt(maxPriorityFeePerGasList.length)\n\n  return maxPriorityFeePerGasMedian > maxPriorityFeePerGasAvg\n    ? maxPriorityFeePerGasAvg\n    : maxPriorityFeePerGasMedian\n}\n\n// Multicall\nexport const getMulticallAddress = async (\n  chainId: ChainId\n): Promise<string | undefined> => {\n  const chains = await config.getChains()\n  return chains.find((chain) => chain.id === chainId)?.multicallAddress\n}\n\n// Modified viem retryDelay exponential backoff function.\nexport const retryDelay = ({ count }: { count: number; error: Error }) =>\n  Math.min(~~(1 << count) * 200, 3000)\n\nexport const retryCount = 30\n"],"names":[],"mappings":";;;;;;AAEA,OAAO,EAAE,QAAQ,EAAE,MAAM,cAAc,CAAA;AAEvC,OAAO,EAAE,MAAM,EAAE,MAAM,uBAAuB,CAAA;AAD9C,OAAO,EAAE,MAAM,EAAE,MAAM,iBAAiB,CAAA;;;;AAGjC,MAAM,uBAAuB,GAAG,KAAK,EAC1C,MAAc,EACe,EAAE;IAC/B,MAAM,KAAK,GAAG,wKAAM,WAAA,AAAQ,EAAC,MAAM,EAAE;QACnC,mBAAmB,EAAE,IAAI;KAC1B,CAAC,CAAA;IAEF,MAAM,wBAAwB,GAAI,KAAK,CAAC,YAA8B,CACnE,MAAM,CAAC,CAAC,EAAE,EAAE,CAAG,CAAD,CAAG,CAAC,oBAAoB,CAAC,CACvC,GAAG,CAAC,CAAC,EAAE,EAAE,CAAG,CAAD,CAAG,CAAC,oBAAoB,CAAa,CAAA;IAEnD,IAAI,CAAC,wBAAwB,CAAC,MAAM,EAAE,CAAC;QACrC,OAAM;IACR,CAAC;IAED,IAAI,uBAAuB,GAAG,EAAE,CAAA;IAChC,KAAK,MAAM,KAAK,IAAI,wBAAwB,CAAE,CAAC;QAC7C,uBAAuB,IAAI,KAAK,CAAA;IAClC,CAAC;IAED,MAAM,0BAA0B,uKAAG,SAAA,AAAM,EAAC,wBAAwB,CAAC,IAAI,EAAE,CAAA;IAEzE,MAAM,uBAAuB,GAC3B,uBAAuB,GAAG,MAAM,CAAC,wBAAwB,CAAC,MAAM,CAAC,CAAA;IAEnE,OAAO,0BAA0B,GAAG,uBAAuB,GACvD,uBAAuB,GACvB,0BAA0B,CAAA;AAChC,CAAC,CAAA;AAGM,MAAM,mBAAmB,GAAG,KAAK,EACtC,OAAgB,EACa,EAAE;IAC/B,MAAM,MAAM,GAAG,6JAAM,SAAM,CAAC,SAAS,EAAE,CAAA;IACvC,OAAO,MAAM,CAAC,IAAI,CAAC,CAAC,KAAK,EAAE,CAAG,CAAD,IAAM,CAAC,EAAE,KAAK,OAAO,CAAC,EAAE,gBAAgB,CAAA;AACvE,CAAC,CAAA;AAGM,MAAM,UAAU,GAAG,CAAC,EAAE,KAAK,EAAmC,EAAE,CACrE,CADuE,GACnE,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,KAAK,CAAC,GAAG,GAAG,EAAE,IAAI,CAAC,CAAA;AAE/B,MAAM,UAAU,GAAG,EAAE,CAAA","ignoreList":[0]}},
    {"offset": {"line": 1200, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1206, "column": 0}, "map": {"version":3,"file":"constants.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/constants.ts"],"sourcesContent":["export const AddressZero = '0x0000000000000000000000000000000000000000'\nexport const AlternativeAddressZero =\n  '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee'\nexport const wrappedSolAddress = 'So11111111111111111111111111111111111111112'\nexport const SolSystemProgram = '11111111111111111111111111111111'\n"],"names":[],"mappings":";;;;;;AAAO,MAAM,WAAW,GAAG,4CAA4C,CAAA;AAChE,MAAM,sBAAsB,GACjC,4CAA4C,CAAA;AACvC,MAAM,iBAAiB,GAAG,6CAA6C,CAAA;AACvE,MAAM,gBAAgB,GAAG,kCAAkC,CAAA","ignoreList":[0]}},
    {"offset": {"line": 1216, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1222, "column": 0}, "map": {"version":3,"file":"isZeroAddress.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/utils/isZeroAddress.ts"],"sourcesContent":["import { AddressZero, AlternativeAddressZero } from '../constants.js'\n\nexport const isZeroAddress = (address: string): boolean => {\n  if (address === AddressZero || address === AlternativeAddressZero) {\n    return true\n  }\n  return false\n}\n\nexport const isNativeTokenAddress = (address: string): boolean => {\n  if (\n    address === AddressZero ||\n    address === AlternativeAddressZero ||\n    // CELO native token\n    address === '0x471ece3750da237f93b8e339c536989b8978a438'\n  ) {\n    return true\n  }\n  return false\n}\n"],"names":[],"mappings":";;;;AAAA,OAAO,EAAE,WAAW,EAAE,sBAAsB,EAAE,MAAM,iBAAiB,CAAA;;AAE9D,MAAM,aAAa,GAAG,CAAC,OAAe,EAAW,EAAE;IACxD,IAAI,OAAO,+JAAK,cAAW,IAAI,OAAO,+JAAK,yBAAsB,EAAE,CAAC;QAClE,OAAO,IAAI,CAAA;IACb,CAAC;IACD,OAAO,KAAK,CAAA;AACd,CAAC,CAAA;AAEM,MAAM,oBAAoB,GAAG,CAAC,OAAe,EAAW,EAAE;IAC/D,IACE,OAAO,+JAAK,cAAW,IACvB,OAAO,+JAAK,yBAAsB,IAClC,oBAAoB;IACpB,OAAO,KAAK,4CAA4C,EACxD,CAAC;QACD,OAAO,IAAI,CAAA;IACb,CAAC;IACD,OAAO,KAAK,CAAA;AACd,CAAC,CAAA","ignoreList":[0]}},
    {"offset": {"line": 1241, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1247, "column": 0}, "map": {"version":3,"file":"abi.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/core/EVM/abi.ts"],"sourcesContent":["import type { Abi } from 'viem'\n\nexport const approveAbi: Abi = [\n  {\n    name: 'approve',\n    inputs: [\n      { internalType: 'address', name: 'spender', type: 'address' },\n      { internalType: 'uint256', name: 'amount', type: 'uint256' },\n    ],\n    outputs: [{ internalType: 'bool', name: 'approved', type: 'bool' }],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n]\n\nexport const allowanceAbi: Abi = [\n  {\n    name: 'allowance',\n    inputs: [\n      { internalType: 'address', name: 'owner', type: 'address' },\n      { internalType: 'address', name: 'spender', type: 'address' },\n    ],\n    outputs: [{ internalType: 'uint256', name: 'allowance', type: 'uint256' }],\n    stateMutability: 'view',\n    type: 'function',\n  },\n]\n\nexport const getEthBalanceAbi: Abi = [\n  {\n    inputs: [{ name: '_owner', type: 'address' }],\n    name: 'getEthBalance',\n    outputs: [{ name: 'balance', type: 'uint256' }],\n    type: 'function',\n    stateMutability: 'view',\n  },\n]\n\nexport const balanceOfAbi: Abi = [\n  {\n    inputs: [{ name: '_owner', type: 'address' }],\n    name: 'balanceOf',\n    outputs: [{ name: 'balance', type: 'uint256' }],\n    type: 'function',\n    stateMutability: 'view',\n  },\n]\n"],"names":[],"mappings":";;;;;;AAEO,MAAM,UAAU,GAAQ;IAC7B;QACE,IAAI,EAAE,SAAS;QACf,MAAM,EAAE;YACN;gBAAE,YAAY,EAAE,SAAS;gBAAE,IAAI,EAAE,SAAS;gBAAE,IAAI,EAAE,SAAS;YAAA,CAAE;YAC7D;gBAAE,YAAY,EAAE,SAAS;gBAAE,IAAI,EAAE,QAAQ;gBAAE,IAAI,EAAE,SAAS;YAAA,CAAE;SAC7D;QACD,OAAO,EAAE;YAAC;gBAAE,YAAY,EAAE,MAAM;gBAAE,IAAI,EAAE,UAAU;gBAAE,IAAI,EAAE,MAAM;YAAA,CAAE;SAAC;QACnE,eAAe,EAAE,YAAY;QAC7B,IAAI,EAAE,UAAU;KACjB;CACF,CAAA;AAEM,MAAM,YAAY,GAAQ;IAC/B;QACE,IAAI,EAAE,WAAW;QACjB,MAAM,EAAE;YACN;gBAAE,YAAY,EAAE,SAAS;gBAAE,IAAI,EAAE,OAAO;gBAAE,IAAI,EAAE,SAAS;YAAA,CAAE;YAC3D;gBAAE,YAAY,EAAE,SAAS;gBAAE,IAAI,EAAE,SAAS;gBAAE,IAAI,EAAE,SAAS;YAAA,CAAE;SAC9D;QACD,OAAO,EAAE;YAAC;gBAAE,YAAY,EAAE,SAAS;gBAAE,IAAI,EAAE,WAAW;gBAAE,IAAI,EAAE,SAAS;YAAA,CAAE;SAAC;QAC1E,eAAe,EAAE,MAAM;QACvB,IAAI,EAAE,UAAU;KACjB;CACF,CAAA;AAEM,MAAM,gBAAgB,GAAQ;IACnC;QACE,MAAM,EAAE;YAAC;gBAAE,IAAI,EAAE,QAAQ;gBAAE,IAAI,EAAE,SAAS;YAAA,CAAE;SAAC;QAC7C,IAAI,EAAE,eAAe;QACrB,OAAO,EAAE;YAAC;gBAAE,IAAI,EAAE,SAAS;gBAAE,IAAI,EAAE,SAAS;YAAA,CAAE;SAAC;QAC/C,IAAI,EAAE,UAAU;QAChB,eAAe,EAAE,MAAM;KACxB;CACF,CAAA;AAEM,MAAM,YAAY,GAAQ;IAC/B;QACE,MAAM,EAAE;YAAC;gBAAE,IAAI,EAAE,QAAQ;gBAAE,IAAI,EAAE,SAAS;YAAA,CAAE;SAAC;QAC7C,IAAI,EAAE,WAAW;QACjB,OAAO,EAAE;YAAC;gBAAE,IAAI,EAAE,SAAS;gBAAE,IAAI,EAAE,SAAS;YAAA,CAAE;SAAC;QAC/C,IAAI,EAAE,UAAU;QAChB,eAAe,EAAE,MAAM;KACxB;CACF,CAAA","ignoreList":[0]}},
    {"offset": {"line": 1343, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1349, "column": 0}, "map": {"version":3,"file":"getEVMBalance.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/core/EVM/getEVMBalance.ts"],"sourcesContent":["import type { ChainId, Token, TokenAmount } from '@lifi/types'\nimport type { Address } from 'viem'\nimport {\n  getBalance,\n  getBlockNumber,\n  multicall,\n  readContract,\n} from 'viem/actions'\nimport { isZeroAddress } from '../../utils/isZeroAddress.js'\nimport { balanceOfAbi, getEthBalanceAbi } from './abi.js'\nimport { getPublicClient } from './publicClient.js'\nimport { getMulticallAddress } from './utils.js'\n\nexport const getEVMBalance = async (\n  walletAddress: string,\n  tokens: Token[]\n): Promise<TokenAmount[]> => {\n  if (tokens.length === 0) {\n    return []\n  }\n  const { chainId } = tokens[0]\n  for (const token of tokens) {\n    if (token.chainId !== chainId) {\n      console.warn('Requested tokens have to be on the same chain.')\n    }\n  }\n\n  const multicallAddress = await getMulticallAddress(chainId)\n\n  if (multicallAddress && tokens.length > 1) {\n    return getEVMBalanceMulticall(\n      chainId,\n      tokens,\n      walletAddress,\n      multicallAddress\n    )\n  }\n  return getEVMBalanceDefault(chainId, tokens, walletAddress)\n}\n\nconst getEVMBalanceMulticall = async (\n  chainId: ChainId,\n  tokens: Token[],\n  walletAddress: string,\n  multicallAddress: string\n): Promise<TokenAmount[]> => {\n  const client = await getPublicClient(chainId)\n\n  const contracts = tokens.map((token) => {\n    if (isZeroAddress(token.address)) {\n      return {\n        address: multicallAddress as Address,\n        abi: getEthBalanceAbi,\n        functionName: 'getEthBalance',\n        args: [walletAddress],\n      }\n    }\n    return {\n      address: token.address as Address,\n      abi: balanceOfAbi,\n      functionName: 'balanceOf',\n      args: [walletAddress],\n    }\n  })\n  const blockNumber = await getBlockNumber(client)\n  const results = await multicall(client, {\n    contracts,\n    multicallAddress: multicallAddress as Address,\n    blockNumber,\n  })\n\n  if (!results.length) {\n    return []\n  }\n\n  return tokens.map((token, i: number) => {\n    return {\n      ...token,\n      amount: results[i].result as bigint,\n      blockNumber,\n    }\n  })\n}\n\nconst getEVMBalanceDefault = async (\n  chainId: ChainId,\n  tokens: Token[],\n  walletAddress: string\n): Promise<TokenAmount[]> => {\n  const client = await getPublicClient(chainId)\n  const blockNumber = await getBlockNumber(client)\n  const queue: Promise<bigint>[] = tokens.map((token) => {\n    if (isZeroAddress(token.address)) {\n      return getBalance(client, {\n        address: walletAddress as Address,\n      })\n    }\n    return readContract(client, {\n      address: token.address as Address,\n      abi: balanceOfAbi,\n      functionName: 'balanceOf',\n      args: [walletAddress],\n    }) as Promise<bigint>\n  })\n\n  const results = await Promise.allSettled(queue)\n\n  const tokenAmounts: TokenAmount[] = tokens.map((token, index) => {\n    const result = results[index]\n    if (result.status === 'rejected') {\n      return {\n        ...token,\n        blockNumber,\n      }\n    }\n    return {\n      ...token,\n      amount: result.value,\n      blockNumber,\n    }\n  })\n  return tokenAmounts\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1455, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1461, "column": 0}, "map": {"version":3,"file":"switchChain.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/core/EVM/switchChain.ts"],"sourcesContent":["import type { Client, GetChainIdReturnType } from 'viem'\nimport { getChainId } from 'viem/actions'\nimport { getAction } from 'viem/utils'\nimport { LiFiErrorCode } from '../../errors/constants.js'\nimport { ProviderError } from '../../errors/errors.js'\nimport type { StatusManager } from '../StatusManager.js'\nimport type { LiFiStepExtended, SwitchChainHook } from '../types.js'\n\n/**\n * This method checks whether the wallet client is configured for the correct chain.\n * If yes it returns the wallet clien.\n * If no and if user interaction is allowed it triggers the switchChainHook. If no user interaction is allowed it aborts.\n *\n * Account Type: local -\n * We need to create and return a new connector client from the switchChainHook in order to continue execution on a new chain.\n *\n * Account Type: json-rpc -\n * We can switch chain and return existing connector client from the switchChainHook in order to continue execution on a new chain.\n * @param client\n * @param statusManager\n * @param step\n * @param switchChainHook\n * @param allowUserInteraction\n * @returns New connector client\n */\nexport const switchChain = async (\n  client: Client,\n  statusManager: StatusManager,\n  step: LiFiStepExtended,\n  allowUserInteraction: boolean,\n  switchChainHook?: SwitchChainHook\n): Promise<Client | undefined> => {\n  // if we are already on the correct chain we can proceed directly\n  const currentChainId = (await getAction(\n    client,\n    getChainId,\n    'getChainId'\n  )(undefined)) as GetChainIdReturnType\n  if (currentChainId === step.action.fromChainId) {\n    return client\n  }\n\n  // -> set status message\n  step.execution = statusManager.initExecutionObject(step)\n  statusManager.updateExecution(step, 'ACTION_REQUIRED')\n\n  let switchProcess = statusManager.findOrCreateProcess({\n    step,\n    type: 'SWITCH_CHAIN',\n    status: 'ACTION_REQUIRED',\n  })\n\n  if (!allowUserInteraction) {\n    return\n  }\n\n  try {\n    const updatedClient = await switchChainHook?.(step.action.fromChainId)\n    let updatedChainId: number | undefined\n    if (updatedClient) {\n      updatedChainId = (await getAction(\n        updatedClient,\n        getChainId,\n        'getChainId'\n      )(undefined)) as GetChainIdReturnType\n    }\n    if (updatedChainId !== step.action.fromChainId) {\n      throw new ProviderError(\n        LiFiErrorCode.ChainSwitchError,\n        'Chain switch required.'\n      )\n    }\n\n    switchProcess = statusManager.updateProcess(\n      step,\n      switchProcess.type,\n      'DONE'\n    )\n    statusManager.updateExecution(step, 'PENDING')\n    return updatedClient\n  } catch (error: any) {\n    statusManager.updateProcess(step, switchProcess.type, 'FAILED', {\n      error: {\n        message: error.message,\n        code: LiFiErrorCode.ChainSwitchError,\n      },\n    })\n    statusManager.updateExecution(step, 'FAILED')\n    throw error\n  }\n}\n"],"names":[],"mappings":";;;AAEA,OAAO,EAAE,SAAS,EAAE,MAAM,YAAY,CAAA;AADtC,OAAO,EAAE,UAAU,EAAE,MAAM,cAAc,CAAA;AAGzC,OAAO,EAAE,aAAa,EAAE,MAAM,wBAAwB,CAAA;AADtD,OAAO,EAAE,aAAa,EAAE,MAAM,2BAA2B,CAAA;;;;;AAsBlD,MAAM,WAAW,GAAG,KAAK,EAC9B,MAAc,EACd,aAA4B,EAC5B,IAAsB,EACtB,oBAA6B,EAC7B,eAAiC,EACJ,EAAE;IAC/B,iEAAiE;IACjE,MAAM,cAAc,GAAG,AAAC,6JAAM,YAAA,AAAS,EACrC,MAAM,kKACN,aAAU,EACV,YAAY,CACb,CAAC,SAAS,CAAC,CAAyB,CAAA;IACrC,IAAI,cAAc,KAAK,IAAI,CAAC,MAAM,CAAC,WAAW,EAAE,CAAC;QAC/C,OAAO,MAAM,CAAA;IACf,CAAC;IAED,wBAAwB;IACxB,IAAI,CAAC,SAAS,GAAG,aAAa,CAAC,mBAAmB,CAAC,IAAI,CAAC,CAAA;IACxD,aAAa,CAAC,eAAe,CAAC,IAAI,EAAE,iBAAiB,CAAC,CAAA;IAEtD,IAAI,aAAa,GAAG,aAAa,CAAC,mBAAmB,CAAC;QACpD,IAAI;QACJ,IAAI,EAAE,cAAc;QACpB,MAAM,EAAE,iBAAiB;KAC1B,CAAC,CAAA;IAEF,IAAI,CAAC,oBAAoB,EAAE,CAAC;QAC1B,OAAM;IACR,CAAC;IAED,IAAI,CAAC;QACH,MAAM,aAAa,GAAG,MAAM,eAAe,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC,CAAA;QACtE,IAAI,cAAkC,CAAA;QACtC,IAAI,aAAa,EAAE,CAAC;YAClB,cAAc,GAAG,AAAC,6JAAM,YAAA,AAAS,EAC/B,aAAa,iKACb,cAAU,EACV,YAAY,CACb,CAAC,SAAS,CAAC,CAAyB,CAAA;QACvC,CAAC;QACD,IAAI,cAAc,KAAK,IAAI,CAAC,MAAM,CAAC,WAAW,EAAE,CAAC;YAC/C,MAAM,qKAAI,gBAAa,CACrB,oLAAa,CAAC,gBAAgB,EAC9B,wBAAwB,CACzB,CAAA;QACH,CAAC;QAED,aAAa,GAAG,aAAa,CAAC,aAAa,CACzC,IAAI,EACJ,aAAa,CAAC,IAAI,EAClB,MAAM,CACP,CAAA;QACD,aAAa,CAAC,eAAe,CAAC,IAAI,EAAE,SAAS,CAAC,CAAA;QAC9C,OAAO,aAAa,CAAA;IACtB,CAAC,CAAC,OAAO,KAAU,EAAE,CAAC;QACpB,aAAa,CAAC,aAAa,CAAC,IAAI,EAAE,aAAa,CAAC,IAAI,EAAE,QAAQ,EAAE;YAC9D,KAAK,EAAE;gBACL,OAAO,EAAE,KAAK,CAAC,OAAO;gBACtB,IAAI,sKAAE,gBAAa,CAAC,gBAAgB;aACrC;SACF,CAAC,CAAA;QACF,aAAa,CAAC,eAAe,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAA;QAC7C,MAAM,KAAK,CAAA;IACb,CAAC;AACH,CAAC,CAAA","ignoreList":[0]}},
    {"offset": {"line": 1512, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1518, "column": 0}, "map": {"version":3,"file":"parseEVMErrors.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/core/EVM/parseEVMErrors.ts"],"sourcesContent":["import type { LiFiStep, Process } from '@lifi/types'\nimport { SDKError } from '../../errors/SDKError.js'\nimport { BaseError } from '../../errors/baseError.js'\nimport { ErrorMessage, LiFiErrorCode } from '../../errors/constants.js'\nimport { TransactionError, UnknownError } from '../../errors/errors.js'\nimport { fetchTxErrorDetails } from '../../helpers.js'\n\nexport const parseEVMErrors = async (\n  e: Error,\n  step?: LiFiStep,\n  process?: Process\n): Promise<SDKError> => {\n  if (e instanceof SDKError) {\n    e.step = e.step ?? step\n    e.process = e.process ?? process\n    return e\n  }\n\n  const baseError = await handleSpecificErrors(e, step, process)\n\n  return new SDKError(baseError, step, process)\n}\n\nconst handleSpecificErrors = async (\n  e: any,\n  step?: LiFiStep,\n  process?: Process\n) => {\n  if (e.cause?.name === 'UserRejectedRequestError') {\n    return new TransactionError(LiFiErrorCode.SignatureRejected, e.message, e)\n  }\n\n  if (\n    step &&\n    process?.txHash &&\n    e.code === LiFiErrorCode.TransactionFailed &&\n    e.message === ErrorMessage.TransactionReverted\n  ) {\n    const response = await fetchTxErrorDetails(\n      process.txHash,\n      step.action.fromChainId\n    )\n\n    const errorMessage = response?.error_message\n\n    if (errorMessage?.toLowerCase().includes('out of gas')) {\n      return new TransactionError(\n        LiFiErrorCode.GasLimitError,\n        ErrorMessage.GasLimitLow,\n        e\n      )\n    }\n  }\n\n  if (e instanceof BaseError) {\n    return e\n  }\n\n  return new UnknownError(e.message || ErrorMessage.UnknownError, e)\n}\n"],"names":[],"mappings":";;;AACA,OAAO,EAAE,QAAQ,EAAE,MAAM,0BAA0B,CAAA;AAEnD,OAAO,EAAE,YAAY,EAAE,aAAa,EAAE,MAAM,2BAA2B,CAAA;AAEvE,OAAO,EAAE,mBAAmB,EAAE,MAAM,kBAAkB,CAAA;AADtD,OAAO,EAAE,gBAAgB,EAAE,YAAY,EAAE,MAAM,wBAAwB,CAAA;AAFvE,OAAO,EAAE,SAAS,EAAE,MAAM,2BAA2B,CAAA;;;;;;AAK9C,MAAM,cAAc,GAAG,KAAK,EACjC,CAAQ,EACR,IAAe,EACf,OAAiB,EACE,EAAE;IACrB,IAAI,CAAC,+KAAY,WAAQ,EAAE,CAAC;QAC1B,CAAC,CAAC,IAAI,GAAG,CAAC,CAAC,IAAI,IAAI,IAAI,CAAA;QACvB,CAAC,CAAC,OAAO,GAAG,CAAC,CAAC,OAAO,IAAI,OAAO,CAAA;QAChC,OAAO,CAAC,CAAA;IACV,CAAC;IAED,MAAM,SAAS,GAAG,MAAM,oBAAoB,CAAC,CAAC,EAAE,IAAI,EAAE,OAAO,CAAC,CAAA;IAE9D,OAAO,uKAAI,WAAQ,CAAC,SAAS,EAAE,IAAI,EAAE,OAAO,CAAC,CAAA;AAC/C,CAAC,CAAA;AAED,MAAM,oBAAoB,GAAG,KAAK,EAChC,CAAM,EACN,IAAe,EACf,OAAiB,EACjB,EAAE;IACF,IAAI,CAAC,CAAC,KAAK,EAAE,IAAI,KAAK,0BAA0B,EAAE,CAAC;QACjD,OAAO,qKAAI,mBAAgB,qKAAC,gBAAa,CAAC,iBAAiB,EAAE,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC,CAAA;IAC5E,CAAC;IAED,IACE,IAAI,IACJ,OAAO,EAAE,MAAM,IACf,CAAC,CAAC,IAAI,yKAAK,gBAAa,CAAC,iBAAiB,IAC1C,CAAC,CAAC,OAAO,KAAK,mLAAY,CAAC,mBAAmB,EAC9C,CAAC;QACD,MAAM,QAAQ,GAAG,kKAAM,sBAAmB,AAAnB,EACrB,OAAO,CAAC,MAAM,EACd,IAAI,CAAC,MAAM,CAAC,WAAW,CACxB,CAAA;QAED,MAAM,YAAY,GAAG,QAAQ,EAAE,aAAa,CAAA;QAE5C,IAAI,YAAY,EAAE,WAAW,EAAE,CAAC,QAAQ,CAAC,YAAY,CAAC,EAAE,CAAC;YACvD,OAAO,qKAAI,mBAAgB,oKACzB,iBAAa,CAAC,aAAa,sKAC3B,eAAY,CAAC,WAAW,EACxB,CAAC,CACF,CAAA;QACH,CAAC;IACH,CAAC;IAED,IAAI,CAAC,gLAAY,YAAS,EAAE,CAAC;QAC3B,OAAO,CAAC,CAAA;IACV,CAAC;IAED,OAAO,qKAAI,eAAY,CAAC,CAAC,CAAC,OAAO,wKAAI,eAAY,CAAC,YAAY,EAAE,CAAC,CAAC,CAAA;AACpE,CAAC,CAAA","ignoreList":[0]}},
    {"offset": {"line": 1556, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1562, "column": 0}, "map": {"version":3,"file":"getAllowance.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/core/EVM/getAllowance.ts"],"sourcesContent":["import type { BaseToken, ChainId } from '@lifi/types'\nimport type { Address } from 'viem'\nimport { multicall, readContract } from 'viem/actions'\nimport { isNativeTokenAddress } from '../../utils/isZeroAddress.js'\nimport { allowanceAbi } from './abi.js'\nimport { getPublicClient } from './publicClient.js'\nimport type {\n  TokenAllowance,\n  TokenSpender,\n  TokenSpenderAllowance,\n} from './types.js'\nimport { getMulticallAddress } from './utils.js'\n\nexport const getAllowance = async (\n  chainId: ChainId,\n  tokenAddress: string,\n  ownerAddress: string,\n  spenderAddress: string\n): Promise<bigint> => {\n  const client = await getPublicClient(chainId)\n  try {\n    const approved = (await readContract(client, {\n      address: tokenAddress as Address,\n      abi: allowanceAbi,\n      functionName: 'allowance',\n      args: [ownerAddress, spenderAddress],\n    })) as bigint\n    return approved\n  } catch (_e) {\n    return 0n\n  }\n}\n\nexport const getAllowanceMulticall = async (\n  chainId: ChainId,\n  tokens: TokenSpender[],\n  ownerAddress: string\n): Promise<TokenSpenderAllowance[]> => {\n  if (!tokens.length) {\n    return []\n  }\n  const multicallAddress = await getMulticallAddress(chainId)\n  if (!multicallAddress) {\n    throw new Error(`No multicall address configured for chainId ${chainId}.`)\n  }\n\n  const client = await getPublicClient(chainId)\n\n  const contracts = tokens.map((token) => ({\n    address: token.token.address as Address,\n    abi: allowanceAbi,\n    functionName: 'allowance',\n    args: [ownerAddress, token.spenderAddress],\n  }))\n\n  const results = await multicall(client, {\n    contracts,\n    multicallAddress: multicallAddress as Address,\n  })\n\n  if (!results.length) {\n    throw new Error(\n      `Couldn't load allowance from chainId ${chainId} using multicall.`\n    )\n  }\n\n  return tokens.map(({ token, spenderAddress }, i: number) => ({\n    token,\n    spenderAddress,\n    allowance: results[i].result as bigint,\n  }))\n}\n\n/**\n * Get the current allowance for a certain token.\n * @param token - The token that should be checked\n * @param ownerAddress - The owner of the token\n * @param spenderAddress - The spender address that has to be approved\n * @returns Returns allowance\n */\nexport const getTokenAllowance = async (\n  token: BaseToken,\n  ownerAddress: string,\n  spenderAddress: string\n): Promise<bigint | undefined> => {\n  // native token don't need approval\n  if (isNativeTokenAddress(token.address)) {\n    return\n  }\n\n  const approved = await getAllowance(\n    token.chainId,\n    token.address,\n    ownerAddress,\n    spenderAddress\n  )\n  return approved\n}\n\n/**\n * Get the current allowance for a list of token/spender address pairs.\n * @param ownerAddress - The owner of the tokens\n * @param tokens - A list of token and spender address pairs\n * @returns Returns array of tokens and their allowance\n */\nexport const getTokenAllowanceMulticall = async (\n  ownerAddress: string,\n  tokens: TokenSpender[]\n): Promise<TokenAllowance[]> => {\n  // filter out native tokens\n  const filteredTokens = tokens.filter(\n    ({ token }) => !isNativeTokenAddress(token.address)\n  )\n\n  // group by chain\n  const tokenDataByChain: { [chainId: number]: TokenSpender[] } = {}\n  for (const data of filteredTokens) {\n    if (!tokenDataByChain[data.token.chainId]) {\n      tokenDataByChain[data.token.chainId] = []\n    }\n    tokenDataByChain[data.token.chainId].push(data)\n  }\n\n  const chainKeys = Object.keys(tokenDataByChain).map(Number.parseInt)\n\n  const allowances = (\n    await Promise.all(\n      chainKeys.map(async (chainId) => {\n        // get allowances for current chain and token list\n        return getAllowanceMulticall(\n          chainId,\n          tokenDataByChain[chainId],\n          ownerAddress\n        )\n      })\n    )\n  ).flat()\n\n  return allowances\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1653, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1659, "column": 0}, "map": {"version":3,"file":"setAllowance.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/core/EVM/setAllowance.ts"],"sourcesContent":["import type { Client, Hash, SendTransactionParameters } from 'viem'\nimport { encodeFunctionData } from 'viem'\nimport { sendTransaction } from 'viem/actions'\nimport { getAction } from 'viem/utils'\nimport { isNativeTokenAddress } from '../../utils/isZeroAddress.js'\nimport type { ExecutionOptions, TransactionParameters } from '../types.js'\nimport { approveAbi } from './abi.js'\nimport { getAllowance } from './getAllowance.js'\nimport type { ApproveTokenRequest, RevokeApprovalRequest } from './types.js'\nimport { getMaxPriorityFeePerGas } from './utils.js'\n\nexport const setAllowance = async (\n  client: Client,\n  tokenAddress: string,\n  contractAddress: string,\n  amount: bigint,\n  settings?: ExecutionOptions,\n  returnPopulatedTransaction?: boolean\n): Promise<Hash> => {\n  const data = encodeFunctionData({\n    abi: approveAbi,\n    functionName: 'approve',\n    args: [contractAddress, amount],\n  })\n\n  if (returnPopulatedTransaction) {\n    return data\n  }\n\n  let transactionRequest: TransactionParameters = {\n    to: tokenAddress,\n    data,\n    maxPriorityFeePerGas:\n      client.account?.type === 'local'\n        ? await getMaxPriorityFeePerGas(client)\n        : undefined,\n  }\n\n  if (settings?.updateTransactionRequestHook) {\n    const customizedTransactionRequest: TransactionParameters =\n      await settings.updateTransactionRequestHook({\n        requestType: 'approve',\n        ...transactionRequest,\n      })\n\n    transactionRequest = {\n      ...transactionRequest,\n      ...customizedTransactionRequest,\n    }\n  }\n\n  return getAction(\n    client,\n    sendTransaction,\n    'sendTransaction'\n  )({\n    to: transactionRequest.to,\n    account: client.account!,\n    data: transactionRequest.data,\n    gas: transactionRequest.gas,\n    gasPrice: transactionRequest.gasPrice,\n    maxFeePerGas: transactionRequest.maxFeePerGas,\n    maxPriorityFeePerGas: transactionRequest.maxPriorityFeePerGas,\n    chain: null,\n  } as SendTransactionParameters)\n}\n\n/**\n * Set approval for a certain token and amount.\n * @param request - The approval request\n * @param request.walletClient - The Viem wallet client used to send the transaction\n * @param request.token - The token for which to set the allowance\n * @param request.spenderAddress - The address of the spender\n * @param request.amount - The amount of tokens to approve\n * @returns Returns Hash or nothing\n */\nexport const setTokenAllowance = async ({\n  walletClient,\n  token,\n  spenderAddress,\n  amount,\n}: ApproveTokenRequest): Promise<Hash | void> => {\n  // native token don't need approval\n  if (isNativeTokenAddress(token.address)) {\n    return\n  }\n  const approvedAmount = await getAllowance(\n    token.chainId,\n    token.address,\n    walletClient.account!.address,\n    spenderAddress\n  )\n\n  if (amount > approvedAmount) {\n    const approveTx = await setAllowance(\n      walletClient,\n      token.address,\n      spenderAddress,\n      amount\n    )\n\n    return approveTx\n  }\n}\n\n/**\n * Revoke approval for a certain token.\n * @param request - The revoke request\n * @param request.walletClient - The Viem wallet client used to send the transaction\n * @param request.token - The token for which to revoke the allowance\n * @param request.spenderAddress - The address of the spender\n * @returns Returns Hash or nothing\n */\nexport const revokeTokenApproval = async ({\n  walletClient,\n  token,\n  spenderAddress,\n}: RevokeApprovalRequest): Promise<Hash | void> => {\n  // native token don't need approval\n  if (isNativeTokenAddress(token.address)) {\n    return\n  }\n  const approvedAmount = await getAllowance(\n    token.chainId,\n    token.address,\n    walletClient.account!.address,\n    spenderAddress\n  )\n  if (approvedAmount > 0) {\n    const approveTx = await setAllowance(\n      walletClient,\n      token.address,\n      spenderAddress,\n      0n\n    )\n\n    return approveTx\n  }\n}\n"],"names":[],"mappings":";;;;;AACA,OAAO,EAAE,kBAAkB,EAAE,MAAM,MAAM,CAAA;AAKzC,OAAO,EAAE,UAAU,EAAE,MAAM,UAAU,CAAA;AAGrC,OAAO,EAAE,uBAAuB,EAAE,MAAM,YAAY,CAAA;AANpD,OAAO,EAAE,SAAS,EAAE,MAAM,YAAY,CAAA;AADtC,OAAO,EAAE,eAAe,EAAE,MAAM,cAAc,CAAA;AAE9C,OAAO,EAAE,oBAAoB,EAAE,MAAM,8BAA8B,CAAA;AAGnE,OAAO,EAAE,YAAY,EAAE,MAAM,mBAAmB,CAAA;;;;;;;;AAIzC,MAAM,YAAY,GAAG,KAAK,EAC/B,MAAc,EACd,YAAoB,EACpB,eAAuB,EACvB,MAAc,EACd,QAA2B,EAC3B,0BAAoC,EACrB,EAAE;IACjB,MAAM,IAAI,0KAAG,qBAAA,AAAkB,EAAC;QAC9B,GAAG,EAAE,gLAAU;QACf,YAAY,EAAE,SAAS;QACvB,IAAI,EAAE;YAAC,eAAe;YAAE,MAAM;SAAC;KAChC,CAAC,CAAA;IAEF,IAAI,0BAA0B,EAAE,CAAC;QAC/B,OAAO,IAAI,CAAA;IACb,CAAC;IAED,IAAI,kBAAkB,GAA0B;QAC9C,EAAE,EAAE,YAAY;QAChB,IAAI;QACJ,oBAAoB,EAClB,MAAM,CAAC,OAAO,EAAE,IAAI,KAAK,OAAO,GAC5B,+KAAM,0BAAA,AAAuB,EAAC,MAAM,CAAC,GACrC,SAAS;KAChB,CAAA;IAED,IAAI,QAAQ,EAAE,4BAA4B,EAAE,CAAC;QAC3C,MAAM,4BAA4B,GAChC,MAAM,QAAQ,CAAC,4BAA4B,CAAC;YAC1C,WAAW,EAAE,SAAS;YACtB,GAAG,kBAAkB;SACtB,CAAC,CAAA;QAEJ,kBAAkB,GAAG;YACnB,GAAG,kBAAkB;YACrB,GAAG,4BAA4B;SAChC,CAAA;IACH,CAAC;IAED,8JAAO,YAAA,AAAS,EACd,MAAM,uKACN,kBAAe,EACf,iBAAiB,CAClB,CAAC;QACA,EAAE,EAAE,kBAAkB,CAAC,EAAE;QACzB,OAAO,EAAE,MAAM,CAAC,OAAQ;QACxB,IAAI,EAAE,kBAAkB,CAAC,IAAI;QAC7B,GAAG,EAAE,kBAAkB,CAAC,GAAG;QAC3B,QAAQ,EAAE,kBAAkB,CAAC,QAAQ;QACrC,YAAY,EAAE,kBAAkB,CAAC,YAAY;QAC7C,oBAAoB,EAAE,kBAAkB,CAAC,oBAAoB;QAC7D,KAAK,EAAE,IAAI;KACiB,CAAC,CAAA;AACjC,CAAC,CAAA;AAWM,MAAM,iBAAiB,GAAG,KAAK,EAAE,EACtC,YAAY,EACZ,KAAK,EACL,cAAc,EACd,MAAM,EACc,EAAwB,EAAE;IAC9C,mCAAmC;IACnC,IAAI,kMAAA,AAAoB,EAAC,KAAK,CAAC,OAAO,CAAC,EAAE,CAAC;QACxC,OAAM;IACR,CAAC;IACD,MAAM,cAAc,GAAG,UAAM,2LAAA,AAAY,EACvC,KAAK,CAAC,OAAO,EACb,KAAK,CAAC,OAAO,EACb,YAAY,CAAC,OAAQ,CAAC,OAAO,EAC7B,cAAc,CACf,CAAA;IAED,IAAI,MAAM,GAAG,cAAc,EAAE,CAAC;QAC5B,MAAM,SAAS,GAAG,MAAM,YAAY,CAClC,YAAY,EACZ,KAAK,CAAC,OAAO,EACb,cAAc,EACd,MAAM,CACP,CAAA;QAED,OAAO,SAAS,CAAA;IAClB,CAAC;AACH,CAAC,CAAA;AAUM,MAAM,mBAAmB,GAAG,KAAK,EAAE,EACxC,YAAY,EACZ,KAAK,EACL,cAAc,EACQ,EAAwB,EAAE;IAChD,mCAAmC;IACnC,+KAAI,uBAAA,AAAoB,EAAC,KAAK,CAAC,OAAO,CAAC,EAAE,CAAC;QACxC,OAAM;IACR,CAAC;IACD,MAAM,cAAc,GAAG,sLAAM,eAAA,AAAY,EACvC,KAAK,CAAC,OAAO,EACb,KAAK,CAAC,OAAO,EACb,YAAY,CAAC,OAAQ,CAAC,OAAO,EAC7B,cAAc,CACf,CAAA;IACD,IAAI,cAAc,GAAG,CAAC,EAAE,CAAC;QACvB,MAAM,SAAS,GAAG,MAAM,YAAY,CAClC,YAAY,EACZ,KAAK,CAAC,OAAO,EACb,cAAc,EACd,EAAE,CACH,CAAA;QAED,OAAO,SAAS,CAAA;IAClB,CAAC;AACH,CAAC,CAAA","ignoreList":[0]}},
    {"offset": {"line": 1738, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1744, "column": 0}, "map": {"version":3,"file":"waitForTransactionReceipt.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/core/EVM/waitForTransactionReceipt.ts"],"sourcesContent":["import type { ChainId } from '@lifi/types'\nimport type {\n  Chain,\n  Client,\n  Hash,\n  ReplacementReason,\n  ReplacementReturnType,\n  TransactionReceipt,\n} from 'viem'\nimport { waitForTransactionReceipt as waitForTransactionReceiptInternal } from 'viem/actions'\nimport { LiFiErrorCode } from '../../errors/constants.js'\nimport { TransactionError } from '../../errors/errors.js'\nimport { getPublicClient } from './publicClient.js'\nimport { retryCount, retryDelay } from './utils.js'\n\ninterface WaitForTransactionReceiptProps {\n  client: Client\n  chainId: ChainId\n  txHash: Hash\n  onReplaced?: (response: ReplacementReturnType<Chain | undefined>) => void\n}\n\nexport async function waitForTransactionReceipt({\n  client,\n  chainId,\n  txHash,\n  onReplaced,\n}: WaitForTransactionReceiptProps): Promise<TransactionReceipt | undefined> {\n  let { transactionReceipt, replacementReason } = await waitForReceipt(\n    client,\n    txHash,\n    onReplaced\n  )\n\n  if (!transactionReceipt?.status) {\n    const publicClient = await getPublicClient(chainId)\n    const result = await waitForReceipt(publicClient, txHash, onReplaced)\n    transactionReceipt = result.transactionReceipt\n    replacementReason = result.replacementReason\n  }\n\n  if (transactionReceipt?.status === 'reverted') {\n    throw new TransactionError(\n      LiFiErrorCode.TransactionFailed,\n      'Transaction was reverted.'\n    )\n  }\n  if (replacementReason === 'cancelled') {\n    throw new TransactionError(\n      LiFiErrorCode.TransactionCanceled,\n      'User canceled transaction.'\n    )\n  }\n\n  return transactionReceipt\n}\n\nasync function waitForReceipt(\n  client: Client,\n  txHash: Hash,\n  onReplaced?: (response: ReplacementReturnType<Chain | undefined>) => void\n): Promise<{\n  transactionReceipt?: TransactionReceipt\n  replacementReason?: ReplacementReason\n}> {\n  let replacementReason: ReplacementReason | undefined\n  let transactionReceipt: TransactionReceipt | undefined\n\n  try {\n    transactionReceipt = await waitForTransactionReceiptInternal(client, {\n      hash: txHash,\n      onReplaced: (response) => {\n        replacementReason = response.reason\n        onReplaced?.(response)\n      },\n      retryCount,\n      retryDelay,\n    })\n  } catch {\n    // We can ignore errors from waitForTransactionReceipt as we have a status check fallback\n  }\n\n  return { transactionReceipt, replacementReason }\n}\n"],"names":[],"mappings":";;;AAYA,OAAO,EAAE,eAAe,EAAE,MAAM,mBAAmB,CAAA;AADnD,OAAO,EAAE,gBAAgB,EAAE,MAAM,wBAAwB,CAAA;AADzD,OAAO,EAAE,aAAa,EAAE,MAAM,2BAA2B,CAAA;AADzD,OAAO,EAAE,yBAAyB,IAAI,iCAAiC,EAAE,MAAM,cAAc,CAAA;AAI7F,OAAO,EAAE,UAAU,EAAE,UAAU,EAAE,MAAM,YAAY,CAAA;;;;;;AAS5C,KAAK,UAAU,yBAAyB,CAAC,EAC9C,MAAM,EACN,OAAO,EACP,MAAM,EACN,UAAU,EACqB;IAC/B,IAAI,EAAE,kBAAkB,EAAE,iBAAiB,EAAE,GAAG,MAAM,cAAc,CAClE,MAAM,EACN,MAAM,EACN,UAAU,CACX,CAAA;IAED,IAAI,CAAC,kBAAkB,EAAE,MAAM,EAAE,CAAC;QAChC,MAAM,YAAY,GAAG,sLAAM,kBAAA,AAAe,EAAC,OAAO,CAAC,CAAA;QACnD,MAAM,MAAM,GAAG,MAAM,cAAc,CAAC,YAAY,EAAE,MAAM,EAAE,UAAU,CAAC,CAAA;QACrE,kBAAkB,GAAG,MAAM,CAAC,kBAAkB,CAAA;QAC9C,iBAAiB,GAAG,MAAM,CAAC,iBAAiB,CAAA;IAC9C,CAAC;IAED,IAAI,kBAAkB,EAAE,MAAM,KAAK,UAAU,EAAE,CAAC;QAC9C,MAAM,IAAI,oLAAgB,qKACxB,gBAAa,CAAC,iBAAiB,EAC/B,2BAA2B,CAC5B,CAAA;IACH,CAAC;IACD,IAAI,iBAAiB,KAAK,WAAW,EAAE,CAAC;QACtC,MAAM,oKAAI,oBAAgB,qKACxB,gBAAa,CAAC,mBAAmB,EACjC,4BAA4B,CAC7B,CAAA;IACH,CAAC;IAED,OAAO,kBAAkB,CAAA;AAC3B,CAAC;AAED,KAAK,UAAU,cAAc,CAC3B,MAAc,EACd,MAAY,EACZ,UAAyE;IAKzE,IAAI,iBAAgD,CAAA;IACpD,IAAI,kBAAkD,CAAA;IAEtD,IAAI,CAAC;QACH,kBAAkB,GAAG,yLAAM,4BAAA,AAAiC,EAAC,MAAM,EAAE;YACnE,IAAI,EAAE,MAAM;YACZ,UAAU,EAAE,CAAC,QAAQ,EAAE,EAAE;gBACvB,iBAAiB,GAAG,QAAQ,CAAC,MAAM,CAAA;gBACnC,UAAU,EAAE,CAAC,QAAQ,CAAC,CAAA;YACxB,CAAC;6LACD,aAAU;6LACV,aAAU;SACX,CAAC,CAAA;IACJ,CAAC,CAAC,OAAM,CAAC;IACP,yFAAyF;IAC3F,CAAC;IAED,OAAO;QAAE,kBAAkB;QAAE,iBAAiB;IAAA,CAAE,CAAA;AAClD,CAAC","ignoreList":[0]}},
    {"offset": {"line": 1794, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1800, "column": 0}, "map": {"version":3,"file":"checkAllowance.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/core/EVM/checkAllowance.ts"],"sourcesContent":["import type { Chain, LiFiStep, Process, ProcessType } from '@lifi/types'\nimport type { Address, Client, Hash } from 'viem'\nimport type { StatusManager } from '../StatusManager.js'\nimport type { ExecutionOptions } from '../types.js'\nimport { getAllowance } from './getAllowance.js'\nimport { parseEVMErrors } from './parseEVMErrors.js'\nimport { setAllowance } from './setAllowance.js'\nimport { waitForTransactionReceipt } from './waitForTransactionReceipt.js'\n\nexport const checkAllowance = async (\n  client: Client,\n  chain: Chain,\n  step: LiFiStep,\n  statusManager: StatusManager,\n  settings?: ExecutionOptions,\n  allowUserInteraction = false,\n  shouldBatchTransactions = false\n): Promise<Hash | void> => {\n  // Ask the user to set an allowance\n  let allowanceProcess: Process = statusManager.findOrCreateProcess({\n    step,\n    type: 'TOKEN_ALLOWANCE',\n    chainId: step.action.fromChainId,\n  })\n\n  // Check allowance\n  try {\n    if (allowanceProcess.txHash && allowanceProcess.status !== 'DONE') {\n      await waitForApprovalTransaction(\n        client,\n        allowanceProcess.txHash! as Address,\n        allowanceProcess.type,\n        step,\n        chain,\n        statusManager\n      )\n    } else {\n      allowanceProcess = statusManager.updateProcess(\n        step,\n        allowanceProcess.type,\n        'STARTED'\n      )\n\n      const approved = await getAllowance(\n        chain.id,\n        step.action.fromToken.address,\n        client.account!.address,\n        step.estimate.approvalAddress\n      )\n\n      const fromAmount = BigInt(step.action.fromAmount)\n\n      if (fromAmount > approved) {\n        if (!allowUserInteraction) {\n          return\n        }\n\n        if (shouldBatchTransactions) {\n          const approveTxHash = await setAllowance(\n            client,\n            step.action.fromToken.address,\n            step.estimate.approvalAddress,\n            fromAmount,\n            settings,\n            true\n          )\n\n          allowanceProcess = statusManager.updateProcess(\n            step,\n            allowanceProcess.type,\n            'DONE'\n          )\n\n          return approveTxHash\n        }\n\n        const approveTxHash = await setAllowance(\n          client,\n          step.action.fromToken.address,\n          step.estimate.approvalAddress,\n          fromAmount\n        )\n        await waitForApprovalTransaction(\n          client,\n          approveTxHash,\n          allowanceProcess.type,\n          step,\n          chain,\n          statusManager\n        )\n      } else {\n        allowanceProcess = statusManager.updateProcess(\n          step,\n          allowanceProcess.type,\n          'DONE'\n        )\n      }\n    }\n  } catch (e: any) {\n    const error = await parseEVMErrors(e, step, allowanceProcess)\n    allowanceProcess = statusManager.updateProcess(\n      step,\n      allowanceProcess.type,\n      'FAILED',\n      {\n        error: {\n          message: error.cause.message,\n          code: error.code,\n        },\n      }\n    )\n    statusManager.updateExecution(step, 'FAILED')\n    throw error\n  }\n}\n\nconst waitForApprovalTransaction = async (\n  client: Client,\n  txHash: Hash,\n  processType: ProcessType,\n  step: LiFiStep,\n  chain: Chain,\n  statusManager: StatusManager\n) => {\n  statusManager.updateProcess(step, processType, 'PENDING', {\n    txHash,\n    txLink: `${chain.metamask.blockExplorerUrls[0]}tx/${txHash}`,\n  })\n\n  const transactionReceipt = await waitForTransactionReceipt({\n    client: client,\n    chainId: chain.id,\n    txHash: txHash,\n    onReplaced(response) {\n      statusManager.updateProcess(step, processType, 'PENDING', {\n        txHash: response.transaction.hash,\n        txLink: `${chain.metamask.blockExplorerUrls[0]}tx/${response.transaction.hash}`,\n      })\n    },\n  })\n\n  const transactionHash = transactionReceipt?.transactionHash || txHash\n  statusManager.updateProcess(step, processType, 'DONE', {\n    txHash: transactionHash,\n    txLink: `${chain.metamask.blockExplorerUrls[0]}tx/${transactionHash}`,\n  })\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1875, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1881, "column": 0}, "map": {"version":3,"file":"multisig.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/core/EVM/multisig.ts"],"sourcesContent":["import type { ExtendedChain, LiFiStep, ProcessType } from '@lifi/types'\nimport type { Hash } from 'viem'\nimport { LiFiErrorCode } from '../../errors/constants.js'\nimport { TransactionError } from '../../errors/errors.js'\nimport type { StatusManager } from '../StatusManager.js'\nimport type { MultisigConfig, MultisigTxDetails } from './types.js'\n\nexport const updateMultisigRouteProcess = async (\n  internalTxHash: Hash,\n  step: LiFiStep,\n  processType: ProcessType,\n  fromChain: ExtendedChain,\n  statusManager: StatusManager,\n  multisig?: MultisigConfig\n) => {\n  if (!multisig?.getMultisigTransactionDetails) {\n    throw new Error(\n      'getMultisigTransactionDetails is missing in multisig config.'\n    )\n  }\n\n  const updateIntermediateMultisigStatus = () => {\n    statusManager.updateProcess(step, processType, 'PENDING')\n  }\n\n  const multisigStatusResponse: MultisigTxDetails =\n    await multisig?.getMultisigTransactionDetails(\n      internalTxHash,\n      fromChain.id,\n      updateIntermediateMultisigStatus\n    )\n\n  if (multisigStatusResponse.status === 'DONE') {\n    statusManager.updateProcess(step, processType, 'PENDING', {\n      txHash: multisigStatusResponse.txHash,\n      multisigTxHash: undefined,\n      txLink: `${fromChain.metamask.blockExplorerUrls[0]}tx/${multisigStatusResponse.txHash}`,\n    })\n  }\n\n  if (multisigStatusResponse.status === 'FAILED') {\n    throw new TransactionError(\n      LiFiErrorCode.TransactionFailed,\n      'Multisig transaction failed.'\n    )\n  }\n\n  if (multisigStatusResponse.status === 'CANCELLED') {\n    throw new TransactionError(\n      LiFiErrorCode.SignatureRejected,\n      'Transaction was rejected by user.'\n    )\n  }\n}\n"],"names":[],"mappings":";;;AAGA,OAAO,EAAE,gBAAgB,EAAE,MAAM,wBAAwB,CAAA;AADzD,OAAO,EAAE,aAAa,EAAE,MAAM,2BAA2B,CAAA;;;AAKlD,MAAM,0BAA0B,GAAG,KAAK,EAC7C,cAAoB,EACpB,IAAc,EACd,WAAwB,EACxB,SAAwB,EACxB,aAA4B,EAC5B,QAAyB,EACzB,EAAE;IACF,IAAI,CAAC,QAAQ,EAAE,6BAA6B,EAAE,CAAC;QAC7C,MAAM,IAAI,KAAK,CACb,8DAA8D,CAC/D,CAAA;IACH,CAAC;IAED,MAAM,gCAAgC,GAAG,GAAG,EAAE;QAC5C,aAAa,CAAC,aAAa,CAAC,IAAI,EAAE,WAAW,EAAE,SAAS,CAAC,CAAA;IAC3D,CAAC,CAAA;IAED,MAAM,sBAAsB,GAC1B,MAAM,QAAQ,EAAE,6BAA6B,CAC3C,cAAc,EACd,SAAS,CAAC,EAAE,EACZ,gCAAgC,CACjC,CAAA;IAEH,IAAI,sBAAsB,CAAC,MAAM,KAAK,MAAM,EAAE,CAAC;QAC7C,aAAa,CAAC,aAAa,CAAC,IAAI,EAAE,WAAW,EAAE,SAAS,EAAE;YACxD,MAAM,EAAE,sBAAsB,CAAC,MAAM;YACrC,cAAc,EAAE,SAAS;YACzB,MAAM,EAAE,GAAG,SAAS,CAAC,QAAQ,CAAC,iBAAiB,CAAC,CAAC,CAAC,CAAA,GAAA,EAAM,sBAAsB,CAAC,MAAM,EAAE;SACxF,CAAC,CAAA;IACJ,CAAC;IAED,IAAI,sBAAsB,CAAC,MAAM,KAAK,QAAQ,EAAE,CAAC;QAC/C,MAAM,qKAAI,mBAAgB,qKACxB,gBAAa,CAAC,iBAAiB,EAC/B,8BAA8B,CAC/B,CAAA;IACH,CAAC;IAED,IAAI,sBAAsB,CAAC,MAAM,KAAK,WAAW,EAAE,CAAC;QAClD,MAAM,qKAAI,mBAAgB,qKACxB,gBAAa,CAAC,iBAAiB,EAC/B,mCAAmC,CACpC,CAAA;IACH,CAAC;AACH,CAAC,CAAA","ignoreList":[0]}},
    {"offset": {"line": 1910, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1916, "column": 0}, "map": {"version":3,"file":"balance.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/services/balance.ts"],"sourcesContent":["import { ChainType, type Token, type TokenAmount } from '@lifi/types'\nimport { config } from '../config.js'\nimport { ValidationError } from '../errors/errors.js'\nimport { isToken } from '../typeguards.js'\n\n/**\n * Returns the balances of a specific token a wallet holds across all aggregated chains.\n * @param walletAddress - A wallet address.\n * @param token - A Token object.\n * @returns An object containing the token and the amounts on different chains.\n * @throws {BaseError} Throws a ValidationError if parameters are invalid.\n */\nexport const getTokenBalance = async (\n  walletAddress: string,\n  token: Token\n): Promise<TokenAmount | null> => {\n  const tokenAmounts = await getTokenBalances(walletAddress, [token])\n  return tokenAmounts.length ? tokenAmounts[0] : null\n}\n\n/**\n * Returns the balances for a list tokens a wallet holds  across all aggregated chains.\n * @param walletAddress - A wallet address.\n * @param tokens - A list of Token objects.\n * @returns A list of objects containing the tokens and the amounts on different chains.\n * @throws {BaseError} Throws a ValidationError if parameters are invalid.\n */\nexport const getTokenBalances = async (\n  walletAddress: string,\n  tokens: Token[]\n): Promise<TokenAmount[]> => {\n  // split by chain\n  const tokensByChain = tokens.reduce(\n    (tokens, token) => {\n      if (!tokens[token.chainId]) {\n        tokens[token.chainId] = []\n      }\n      tokens[token.chainId].push(token)\n      return tokens\n    },\n    {} as { [chainId: number]: Token[] }\n  )\n\n  const tokenAmountsByChain = await getTokenBalancesByChain(\n    walletAddress,\n    tokensByChain\n  )\n  return Object.values(tokenAmountsByChain).flat()\n}\n\n/**\n * This method queries the balances of tokens for a specific list of chains for a given wallet.\n * @param walletAddress - A wallet address.\n * @param tokensByChain - A list of token objects organized by chain ids.\n * @returns A list of objects containing the tokens and the amounts on different chains organized by the chosen chains.\n * @throws {BaseError} Throws a ValidationError if parameters are invalid.\n */\nexport const getTokenBalancesByChain = async (\n  walletAddress: string,\n  tokensByChain: { [chainId: number]: Token[] }\n): Promise<{ [chainId: number]: TokenAmount[] }> => {\n  if (!walletAddress) {\n    throw new ValidationError('Missing walletAddress.')\n  }\n\n  const tokenList = Object.values(tokensByChain).flat()\n  const invalidTokens = tokenList.filter((token) => !isToken(token))\n  if (invalidTokens.length) {\n    throw new ValidationError('Invalid tokens passed.')\n  }\n\n  const tokenAmountsByChain: { [chainId: number]: TokenAmount[] } = {}\n  const tokenAmountsSettled = await Promise.allSettled(\n    Object.keys(tokensByChain).map(async (chainIdStr) => {\n      const chainId = Number.parseInt(chainIdStr)\n      const chain = await config.getChainById(chainId)\n      const tokenAddress = tokensByChain[chainId][0].address\n      const provider = config\n        .get()\n        .providers.find((provider) =>\n          chain.chainType === ChainType.UTXO\n            ? provider.isAddress(walletAddress)\n            : provider.isAddress(tokenAddress)\n        )\n      if (!provider) {\n        throw new Error(\n          `SDK Token Provider for ${chain.chainType} is not found.`\n        )\n      }\n      const tokenAmounts = await provider.getBalance(\n        walletAddress,\n        tokensByChain[chainId]\n      )\n      tokenAmountsByChain[chainId] = tokenAmounts\n    })\n  )\n  if (config.get().debug) {\n    for (const result of tokenAmountsSettled) {\n      if (result.status === 'rejected') {\n        console.warn(\"Couldn't fetch token balance.\", result.reason)\n      }\n    }\n  }\n  return tokenAmountsByChain\n}\n"],"names":[],"mappings":";;;;;AAEA,OAAO,EAAE,eAAe,EAAE,MAAM,qBAAqB,CAAA;AACrD,OAAO,EAAE,OAAO,EAAE,MAAM,kBAAkB,CAAA;AAF1C,OAAO,EAAE,MAAM,EAAE,MAAM,cAAc,CAAA;AADrC,OAAO,EAAE,SAAS,EAAgC,MAAM,aAAa,CAAA;;;;;AAY9D,MAAM,eAAe,GAAG,KAAK,EAClC,aAAqB,EACrB,KAAY,EACiB,EAAE;IAC/B,MAAM,YAAY,GAAG,MAAM,gBAAgB,CAAC,aAAa,EAAE;QAAC,KAAK;KAAC,CAAC,CAAA;IACnE,OAAO,YAAY,CAAC,MAAM,CAAC,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAA;AACrD,CAAC,CAAA;AASM,MAAM,gBAAgB,GAAG,KAAK,EACnC,aAAqB,EACrB,MAAe,EACS,EAAE;IAC1B,iBAAiB;IACjB,MAAM,aAAa,GAAG,MAAM,CAAC,MAAM,CACjC,CAAC,MAAM,EAAE,KAAK,EAAE,EAAE;QAChB,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,EAAE,CAAC;YAC3B,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,EAAE,CAAA;QAC5B,CAAC;QACD,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA;QACjC,OAAO,MAAM,CAAA;IACf,CAAC,EACD,CAAA,CAAoC,CACrC,CAAA;IAED,MAAM,mBAAmB,GAAG,MAAM,uBAAuB,CACvD,aAAa,EACb,aAAa,CACd,CAAA;IACD,OAAO,MAAM,CAAC,MAAM,CAAC,mBAAmB,CAAC,CAAC,IAAI,EAAE,CAAA;AAClD,CAAC,CAAA;AASM,MAAM,uBAAuB,GAAG,KAAK,EAC1C,aAAqB,EACrB,aAA6C,EACE,EAAE;IACjD,IAAI,CAAC,aAAa,EAAE,CAAC;QACnB,MAAM,qKAAI,kBAAe,CAAC,wBAAwB,CAAC,CAAA;IACrD,CAAC;IAED,MAAM,SAAS,GAAG,MAAM,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC,IAAI,EAAE,CAAA;IACrD,MAAM,aAAa,GAAG,SAAS,CAAC,MAAM,CAAC,CAAC,KAAK,EAAE,CAAG,CAAD,CAAE,wKAAA,AAAO,EAAC,KAAK,CAAC,CAAC,CAAA;IAClE,IAAI,aAAa,CAAC,MAAM,EAAE,CAAC;QACzB,MAAM,qKAAI,kBAAe,CAAC,wBAAwB,CAAC,CAAA;IACrD,CAAC;IAED,MAAM,mBAAmB,GAAyC,CAAA,CAAE,CAAA;IACpE,MAAM,mBAAmB,GAAG,MAAM,OAAO,CAAC,UAAU,CAClD,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,GAAG,CAAC,KAAK,EAAE,UAAU,EAAE,EAAE;QAClD,MAAM,OAAO,GAAG,MAAM,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAA;QAC3C,MAAM,KAAK,GAAG,6JAAM,SAAM,CAAC,YAAY,CAAC,OAAO,CAAC,CAAA;QAChD,MAAM,YAAY,GAAG,aAAa,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,OAAO,CAAA;QACtD,MAAM,QAAQ,0JAAG,SAAM,CACpB,GAAG,EAAE,CACL,SAAS,CAAC,IAAI,CAAC,CAAC,QAAQ,EAAE,CACzB,CAD2B,IACtB,CAAC,SAAS,uKAAK,YAAS,CAAC,IAAI,GAC9B,QAAQ,CAAC,SAAS,CAAC,aAAa,CAAC,GACjC,QAAQ,CAAC,SAAS,CAAC,YAAY,CAAC,CACrC,CAAA;QACH,IAAI,CAAC,QAAQ,EAAE,CAAC;YACd,MAAM,IAAI,KAAK,CACb,CAAA,uBAAA,EAA0B,KAAK,CAAC,SAAS,CAAA,cAAA,CAAgB,CAC1D,CAAA;QACH,CAAC;QACD,MAAM,YAAY,GAAG,MAAM,QAAQ,CAAC,UAAU,CAC5C,aAAa,EACb,aAAa,CAAC,OAAO,CAAC,CACvB,CAAA;QACD,mBAAmB,CAAC,OAAO,CAAC,GAAG,YAAY,CAAA;IAC7C,CAAC,CAAC,CACH,CAAA;IACD,2JAAI,SAAM,CAAC,GAAG,EAAE,CAAC,KAAK,EAAE,CAAC;QACvB,KAAK,MAAM,MAAM,IAAI,mBAAmB,CAAE,CAAC;YACzC,IAAI,MAAM,CAAC,MAAM,KAAK,UAAU,EAAE,CAAC;gBACjC,OAAO,CAAC,IAAI,CAAC,+BAA+B,EAAE,MAAM,CAAC,MAAM,CAAC,CAAA;YAC9D,CAAC;QACH,CAAC;IACH,CAAC;IACD,OAAO,mBAAmB,CAAA;AAC5B,CAAC,CAAA","ignoreList":[0]}},
    {"offset": {"line": 1977, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1983, "column": 0}, "map": {"version":3,"file":"checkBalance.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/core/checkBalance.ts"],"sourcesContent":["import type { LiFiStep } from '@lifi/types'\nimport { formatUnits } from 'viem'\nimport { BalanceError } from '../errors/errors.js'\nimport { getTokenBalance } from '../services/balance.js'\nimport { sleep } from '../utils/sleep.js'\n\nexport const checkBalance = async (\n  walletAddress: string,\n  step: LiFiStep,\n  depth = 0\n): Promise<void> => {\n  const token = await getTokenBalance(walletAddress, step.action.fromToken)\n  if (token) {\n    const currentBalance = token.amount ?? 0n\n    const neededBalance = BigInt(step.action.fromAmount)\n\n    if (currentBalance < neededBalance) {\n      if (depth <= 3) {\n        await sleep(200)\n        await checkBalance(walletAddress, step, depth + 1)\n      } else if (\n        (neededBalance * BigInt((1 - step.action.slippage) * 1_000_000_000)) /\n          1_000_000_000n <=\n        currentBalance\n      ) {\n        // adjust amount in slippage limits\n        step.action.fromAmount = currentBalance.toString()\n      } else {\n        const neeeded = formatUnits(neededBalance, token.decimals)\n        const current = formatUnits(currentBalance, token.decimals)\n        let _errorMessage = `Your ${token.symbol} balance is too low, you try to transfer ${neeeded} ${token.symbol}, but your wallet only holds ${current} ${token.symbol}. No funds have been sent.`\n\n        if (currentBalance !== 0n) {\n          _errorMessage += `If the problem consists, please delete this transfer and start a new one with a maximum of ${current} ${token.symbol}.`\n        }\n\n        throw new BalanceError('The balance is too low.')\n      }\n    }\n  }\n}\n"],"names":[],"mappings":";;;AAGA,OAAO,EAAE,eAAe,EAAE,MAAM,wBAAwB,CAAA;AACxD,OAAO,EAAE,KAAK,EAAE,MAAM,mBAAmB,CAAA;AAHzC,OAAO,EAAE,WAAW,EAAE,MAAM,MAAM,CAAA;AAClC,OAAO,EAAE,YAAY,EAAE,MAAM,qBAAqB,CAAA;;;;;AAI3C,MAAM,YAAY,GAAG,KAAK,EAC/B,aAAqB,EACrB,IAAc,EACd,KAAK,GAAG,CAAC,EACM,EAAE;IACjB,MAAM,KAAK,GAAG,8KAAM,kBAAA,AAAe,EAAC,aAAa,EAAE,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,CAAA;IACzE,IAAI,KAAK,EAAE,CAAC;QACV,MAAM,cAAc,GAAG,KAAK,CAAC,MAAM,IAAI,EAAE,CAAA;QACzC,MAAM,aAAa,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,CAAA;QAEpD,IAAI,cAAc,GAAG,aAAa,EAAE,CAAC;YACnC,IAAI,KAAK,IAAI,CAAC,EAAE,CAAC;gBACf,MAAM,2KAAA,AAAK,EAAC,GAAG,CAAC,CAAA;gBAChB,MAAM,YAAY,CAAC,aAAa,EAAE,IAAI,EAAE,KAAK,GAAG,CAAC,CAAC,CAAA;YACpD,CAAC,MAAM,IACL,AAAC,aAAa,GAAG,MAAM,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,GAAG,aAAa,CAAC,CAAC,EAClE,WAAc,IAChB,cAAc,EACd,CAAC;gBACD,mCAAmC;gBACnC,IAAI,CAAC,MAAM,CAAC,UAAU,GAAG,cAAc,CAAC,QAAQ,EAAE,CAAA;YACpD,CAAC,MAAM,CAAC;gBACN,MAAM,OAAO,oKAAG,cAAA,AAAW,EAAC,aAAa,EAAE,KAAK,CAAC,QAAQ,CAAC,CAAA;gBAC1D,MAAM,OAAO,oKAAG,cAAW,AAAX,EAAY,cAAc,EAAE,KAAK,CAAC,QAAQ,CAAC,CAAA;gBAC3D,IAAI,aAAa,GAAG,CAAA,KAAA,EAAQ,KAAK,CAAC,MAAM,CAAA,yCAAA,EAA4C,OAAO,CAAA,CAAA,EAAI,KAAK,CAAC,MAAM,CAAA,6BAAA,EAAgC,OAAO,CAAA,CAAA,EAAI,KAAK,CAAC,MAAM,CAAA,0BAAA,CAA4B,CAAA;gBAE9L,IAAI,cAAc,KAAK,EAAE,EAAE,CAAC;oBAC1B,aAAa,IAAI,CAAA,2FAAA,EAA8F,OAAO,CAAA,CAAA,EAAI,KAAK,CAAC,MAAM,CAAA,CAAA,CAAG,CAAA;gBAC3I,CAAC;gBAED,MAAM,qKAAI,eAAY,CAAC,yBAAyB,CAAC,CAAA;YACnD,CAAC;QACH,CAAC;IACH,CAAC;AACH,CAAC,CAAA","ignoreList":[0]}},
    {"offset": {"line": 2018, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2024, "column": 0}, "map": {"version":3,"file":"utils.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/core/utils.ts"],"sourcesContent":["import type { LiFiStep } from '@lifi/types'\n\n/**\n * Used to check if changed exchange rate is in the range of slippage threshold.\n * We use a slippage value as a threshold to trigger the rate change hook.\n * This can result in almost doubled slippage for the user and need to be revisited.\n * @param oldStep - old step\n * @param newStep - new step\n * @returns Boolean\n */\nexport function checkStepSlippageThreshold(\n  oldStep: LiFiStep,\n  newStep: LiFiStep\n): boolean {\n  const setSlippage = oldStep.action.slippage\n  const oldEstimatedToAmount = BigInt(oldStep.estimate.toAmountMin)\n  const newEstimatedToAmount = BigInt(newStep.estimate.toAmountMin)\n  const amountDifference = oldEstimatedToAmount - newEstimatedToAmount\n  // oldEstimatedToAmount can be 0 when we use contract calls\n  let actualSlippage = 0\n  if (oldEstimatedToAmount > 0) {\n    actualSlippage =\n      Number((amountDifference * 1_000_000_000n) / oldEstimatedToAmount) /\n      1_000_000_000\n  }\n  return actualSlippage <= setSlippage\n}\n"],"names":[],"mappings":"AAEA;;;;;;;GAOG;;;AACG,SAAU,0BAA0B,CACxC,OAAiB,EACjB,OAAiB;IAEjB,MAAM,WAAW,GAAG,OAAO,CAAC,MAAM,CAAC,QAAQ,CAAA;IAC3C,MAAM,oBAAoB,GAAG,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAA;IACjE,MAAM,oBAAoB,GAAG,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAA;IACjE,MAAM,gBAAgB,GAAG,oBAAoB,GAAG,oBAAoB,CAAA;IACpE,2DAA2D;IAC3D,IAAI,cAAc,GAAG,CAAC,CAAA;IACtB,IAAI,oBAAoB,GAAG,CAAC,EAAE,CAAC;QAC7B,cAAc,GACZ,MAAM,CAAC,AAAC,gBAAgB,GAAG,WAAc,CAAC,EAAG,oBAAoB,CAAC,GAClE,aAAa,CAAA;IACjB,CAAC;IACD,OAAO,cAAc,IAAI,WAAW,CAAA;AACtC,CAAC","ignoreList":[0]}},
    {"offset": {"line": 2046, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2052, "column": 0}, "map": {"version":3,"file":"stepComparison.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/core/stepComparison.ts"],"sourcesContent":["import type { LiFiStep } from '@lifi/types'\nimport { LiFiErrorCode } from '../errors/constants.js'\nimport { TransactionError } from '../errors/errors.js'\nimport type { StatusManager } from './StatusManager.js'\nimport type { ExecutionOptions } from './types.js'\nimport { checkStepSlippageThreshold } from './utils.js'\n\n/**\n * This method checks whether the new and updated Step meets the required exchange rate conditions.\n * If yes it returns the updated Step.\n * If no and if user interaction is allowed it triggers the acceptExchangeRateUpdateHook. If no user interaction is allowed it aborts.\n * @param statusManager\n * @param oldStep\n * @param newStep\n * @param settings\n * @param allowUserInteraction\n * @param executionOptions\n * @returns Return LiFiStep\n */\nexport const stepComparison = async (\n  statusManager: StatusManager,\n  oldStep: LiFiStep,\n  newStep: LiFiStep,\n  allowUserInteraction: boolean,\n  executionOptions?: ExecutionOptions\n): Promise<LiFiStep> => {\n  // Check if changed exchange rate is in the range of slippage threshold\n  if (checkStepSlippageThreshold(oldStep, newStep)) {\n    return statusManager.updateStepInRoute(newStep)\n  }\n\n  let allowStepUpdate: boolean | undefined\n  if (allowUserInteraction) {\n    allowStepUpdate = await executionOptions?.acceptExchangeRateUpdateHook?.({\n      oldToAmount: oldStep.estimate.toAmount,\n      newToAmount: newStep.estimate.toAmount,\n      toToken: newStep.action.toToken,\n    })\n  }\n\n  if (!allowStepUpdate) {\n    // The user declined the new exchange rate, so we are not going to proceed\n    throw new TransactionError(\n      LiFiErrorCode.ExchangeRateUpdateCanceled,\n      'Exchange rate has changed!\\nTransaction was not sent, your funds are still in your wallet.\\nThe exchange rate has changed and the previous estimation can not be fulfilled due to value loss.'\n    )\n  }\n\n  return statusManager.updateStepInRoute(newStep)\n}\n"],"names":[],"mappings":";;;AAKA,OAAO,EAAE,0BAA0B,EAAE,MAAM,YAAY,CAAA;AAHvD,OAAO,EAAE,gBAAgB,EAAE,MAAM,qBAAqB,CAAA;AADtD,OAAO,EAAE,aAAa,EAAE,MAAM,wBAAwB,CAAA;;;;AAkB/C,MAAM,cAAc,GAAG,KAAK,EACjC,aAA4B,EAC5B,OAAiB,EACjB,OAAiB,EACjB,oBAA6B,EAC7B,gBAAmC,EAChB,EAAE;IACrB,uEAAuE;IACvE,sKAAI,6BAAA,AAA0B,EAAC,OAAO,EAAE,OAAO,CAAC,EAAE,CAAC;QACjD,OAAO,aAAa,CAAC,iBAAiB,CAAC,OAAO,CAAC,CAAA;IACjD,CAAC;IAED,IAAI,eAAoC,CAAA;IACxC,IAAI,oBAAoB,EAAE,CAAC;QACzB,eAAe,GAAG,MAAM,gBAAgB,EAAE,4BAA4B,EAAE,CAAC;YACvE,WAAW,EAAE,OAAO,CAAC,QAAQ,CAAC,QAAQ;YACtC,WAAW,EAAE,OAAO,CAAC,QAAQ,CAAC,QAAQ;YACtC,OAAO,EAAE,OAAO,CAAC,MAAM,CAAC,OAAO;SAChC,CAAC,CAAA;IACJ,CAAC;IAED,IAAI,CAAC,eAAe,EAAE,CAAC;QACrB,0EAA0E;QAC1E,MAAM,qKAAI,mBAAgB,qKACxB,gBAAa,CAAC,0BAA0B,EACxC,+LAA+L,CAChM,CAAA;IACH,CAAC;IAED,OAAO,aAAa,CAAC,iBAAiB,CAAC,OAAO,CAAC,CAAA;AACjD,CAAC,CAAA","ignoreList":[0]}},
    {"offset": {"line": 2080, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2086, "column": 0}, "map": {"version":3,"file":"processMessages.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/core/processMessages.ts"],"sourcesContent":["import type {\n  ProcessStatus,\n  ProcessType,\n  StatusMessage,\n  Substatus,\n} from '@lifi/types'\n\nconst processMessages: Record<\n  ProcessType,\n  Partial<Record<ProcessStatus, string>>\n> = {\n  TOKEN_ALLOWANCE: {\n    STARTED: 'Setting token allowance.',\n    PENDING: 'Waiting for token allowance.',\n    DONE: 'Token allowance set.',\n  },\n  SWITCH_CHAIN: {\n    PENDING: 'Chain switch required.',\n    DONE: 'Chain switched successfully.',\n  },\n  SWAP: {\n    STARTED: 'Preparing swap transaction.',\n    ACTION_REQUIRED: 'Please sign the transaction.',\n    PENDING: 'Waiting for swap transaction.',\n    DONE: 'Swap completed.',\n  },\n  CROSS_CHAIN: {\n    STARTED: 'Preparing bridge transaction.',\n    ACTION_REQUIRED: 'Please sign the transaction.',\n    PENDING: 'Waiting for bridge transaction.',\n    DONE: 'Bridge transaction confirmed.',\n  },\n  RECEIVING_CHAIN: {\n    PENDING: 'Waiting for destination chain.',\n    DONE: 'Bridge completed.',\n  },\n  TRANSACTION: {},\n}\nconst substatusMessages: Record<\n  StatusMessage,\n  Partial<Record<Substatus, string>>\n> = {\n  PENDING: {\n    BRIDGE_NOT_AVAILABLE: 'Bridge communication is temporarily unavailable.',\n    CHAIN_NOT_AVAILABLE: 'RPC communication is temporarily unavailable.',\n    UNKNOWN_ERROR:\n      'An unexpected error occurred. Please seek assistance in the LI.FI discord server.',\n    WAIT_SOURCE_CONFIRMATIONS:\n      'The bridge deposit has been received. The bridge is waiting for more confirmations to start the off-chain logic.',\n    WAIT_DESTINATION_TRANSACTION:\n      'The bridge off-chain logic is being executed. Wait for the transaction to appear on the destination chain.',\n  },\n  DONE: {\n    PARTIAL:\n      'Some of the received tokens are not the requested destination tokens.',\n    REFUNDED: 'The tokens were refunded to the sender address.',\n    COMPLETED: 'The transfer is complete.',\n  },\n  FAILED: {},\n  INVALID: {},\n  NOT_FOUND: {},\n}\n\nexport function getProcessMessage(\n  type: ProcessType,\n  status: ProcessStatus\n): string | undefined {\n  const processMessage = processMessages[type][status]\n  return processMessage\n}\n\nexport function getSubstatusMessage(\n  status: StatusMessage,\n  substatus?: Substatus\n): string | undefined {\n  if (!substatus) {\n    return\n  }\n  const message = substatusMessages[status][substatus]\n  return message\n}\n"],"names":[],"mappings":";;;;AAOA,MAAM,eAAe,GAGjB;IACF,eAAe,EAAE;QACf,OAAO,EAAE,0BAA0B;QACnC,OAAO,EAAE,8BAA8B;QACvC,IAAI,EAAE,sBAAsB;KAC7B;IACD,YAAY,EAAE;QACZ,OAAO,EAAE,wBAAwB;QACjC,IAAI,EAAE,8BAA8B;KACrC;IACD,IAAI,EAAE;QACJ,OAAO,EAAE,6BAA6B;QACtC,eAAe,EAAE,8BAA8B;QAC/C,OAAO,EAAE,+BAA+B;QACxC,IAAI,EAAE,iBAAiB;KACxB;IACD,WAAW,EAAE;QACX,OAAO,EAAE,+BAA+B;QACxC,eAAe,EAAE,8BAA8B;QAC/C,OAAO,EAAE,iCAAiC;QAC1C,IAAI,EAAE,+BAA+B;KACtC;IACD,eAAe,EAAE;QACf,OAAO,EAAE,gCAAgC;QACzC,IAAI,EAAE,mBAAmB;KAC1B;IACD,WAAW,EAAE,CAAA,CAAE;CAChB,CAAA;AACD,MAAM,iBAAiB,GAGnB;IACF,OAAO,EAAE;QACP,oBAAoB,EAAE,kDAAkD;QACxE,mBAAmB,EAAE,+CAA+C;QACpE,aAAa,EACX,mFAAmF;QACrF,yBAAyB,EACvB,kHAAkH;QACpH,4BAA4B,EAC1B,4GAA4G;KAC/G;IACD,IAAI,EAAE;QACJ,OAAO,EACL,uEAAuE;QACzE,QAAQ,EAAE,iDAAiD;QAC3D,SAAS,EAAE,2BAA2B;KACvC;IACD,MAAM,EAAE,CAAA,CAAE;IACV,OAAO,EAAE,CAAA,CAAE;IACX,SAAS,EAAE,CAAA,CAAE;CACd,CAAA;AAEK,SAAU,iBAAiB,CAC/B,IAAiB,EACjB,MAAqB;IAErB,MAAM,cAAc,GAAG,eAAe,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,CAAA;IACpD,OAAO,cAAc,CAAA;AACvB,CAAC;AAEK,SAAU,mBAAmB,CACjC,MAAqB,EACrB,SAAqB;IAErB,IAAI,CAAC,SAAS,EAAE,CAAC;QACf,OAAM;IACR,CAAC;IACD,MAAM,OAAO,GAAG,iBAAiB,CAAC,MAAM,CAAC,CAAC,SAAS,CAAC,CAAA;IACpD,OAAO,OAAO,CAAA;AAChB,CAAC","ignoreList":[0]}},
    {"offset": {"line": 2146, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2152, "column": 0}, "map": {"version":3,"file":"waitForResult.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/utils/waitForResult.ts"],"sourcesContent":["import { sleep } from './sleep.js'\n\n/**\n * Repeatedly calls a given asynchronous function until it resolves with a value\n * @param fn The function that should be repeated\n * @param interval The timeout in milliseconds between retries, defaults to 5000\n * @returns The result of the fn function\n */\nexport const waitForResult = async <T>(\n  fn: () => Promise<T | undefined>,\n  interval = 5000\n): Promise<T> => {\n  let result: T | undefined\n  while (!result) {\n    result = await fn()\n    if (!result) {\n      await sleep(interval)\n    }\n  }\n  return result\n}\n"],"names":[],"mappings":";;;AAAA,OAAO,EAAE,KAAK,EAAE,MAAM,YAAY,CAAA;;AAQ3B,MAAM,aAAa,GAAG,KAAK,EAChC,EAAgC,EAChC,QAAQ,GAAG,IAAI,EACH,EAAE;IACd,IAAI,MAAqB,CAAA;IACzB,MAAO,CAAC,MAAM,CAAE,CAAC;QACf,MAAM,GAAG,MAAM,EAAE,EAAE,CAAA;QACnB,IAAI,CAAC,MAAM,EAAE,CAAC;YACZ,yKAAM,QAAA,AAAK,EAAC,QAAQ,CAAC,CAAA;QACvB,CAAC;IACH,CAAC;IACD,OAAO,MAAM,CAAA;AACf,CAAC,CAAA","ignoreList":[0]}},
    {"offset": {"line": 2167, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2173, "column": 0}, "map": {"version":3,"file":"waitForReceivingTransaction.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/core/waitForReceivingTransaction.ts"],"sourcesContent":["import type {\n  FullStatusData,\n  LiFiStep,\n  ProcessType,\n  StatusResponse,\n} from '@lifi/types'\nimport { ServerError } from '../errors/errors.js'\nimport { getStatus } from '../services/api.js'\nimport { waitForResult } from '../utils/waitForResult.js'\nimport type { StatusManager } from './StatusManager.js'\nimport { getSubstatusMessage } from './processMessages.js'\n\nconst TRANSACTION_HASH_OBSERVERS: Record<string, Promise<StatusResponse>> = {}\n\nexport async function waitForReceivingTransaction(\n  txHash: string,\n  statusManager: StatusManager,\n  processType: ProcessType,\n  step: LiFiStep,\n  interval = 5_000\n): Promise<StatusResponse> {\n  const _getStatus = (): Promise<StatusResponse | undefined> => {\n    return getStatus({\n      fromChain: step.action.fromChainId,\n      toChain: step.action.toChainId,\n      txHash,\n      ...(step.tool !== 'custom' && { bridge: step.tool }),\n    })\n      .then((statusResponse) => {\n        switch (statusResponse.status) {\n          case 'DONE':\n            return statusResponse\n          case 'PENDING':\n            statusManager?.updateProcess(step, processType, 'PENDING', {\n              substatus: statusResponse.substatus,\n              substatusMessage:\n                statusResponse.substatusMessage ||\n                getSubstatusMessage(\n                  statusResponse.status,\n                  statusResponse.substatus\n                ),\n              txLink: (statusResponse as FullStatusData).bridgeExplorerLink,\n            })\n            return undefined\n          case 'NOT_FOUND':\n            return undefined\n          default:\n            return Promise.reject()\n        }\n      })\n      .catch((e) => {\n        console.debug('Fetching status from backend failed.', e)\n        return undefined\n      })\n  }\n\n  let status = TRANSACTION_HASH_OBSERVERS[txHash]\n\n  if (!status) {\n    status = waitForResult(_getStatus, interval)\n    TRANSACTION_HASH_OBSERVERS[txHash] = status\n  }\n\n  const resolvedStatus = await status\n\n  if (!('receiving' in resolvedStatus)) {\n    throw new ServerError(\"Status doesn't contain receiving information.\")\n  }\n\n  return resolvedStatus\n}\n"],"names":[],"mappings":";;;AAOA,OAAO,EAAE,SAAS,EAAE,MAAM,oBAAoB,CAAA;AAG9C,OAAO,EAAE,mBAAmB,EAAE,MAAM,sBAAsB,CAAA;AAF1D,OAAO,EAAE,aAAa,EAAE,MAAM,2BAA2B,CAAA;AAFzD,OAAO,EAAE,WAAW,EAAE,MAAM,qBAAqB,CAAA;;;;;AAMjD,MAAM,0BAA0B,GAA4C,CAAA,CAAE,CAAA;AAEvE,KAAK,UAAU,2BAA2B,CAC/C,MAAc,EACd,aAA4B,EAC5B,WAAwB,EACxB,IAAc,EACd,QAAQ,GAAG,KAAK;IAEhB,MAAM,UAAU,GAAG,GAAwC,EAAE;QAC3D,WAAO,4KAAA,AAAS,EAAC;YACf,SAAS,EAAE,IAAI,CAAC,MAAM,CAAC,WAAW;YAClC,OAAO,EAAE,IAAI,CAAC,MAAM,CAAC,SAAS;YAC9B,MAAM;YACN,GAAG,AAAC,IAAI,CAAC,IAAI,KAAK,QAAQ,IAAI;gBAAE,MAAM,EAAE,IAAI,CAAC,IAAI;YAAA,CAAE,CAAC;SACrD,CAAC,CACC,IAAI,CAAC,CAAC,cAAc,EAAE,EAAE;YACvB,OAAQ,cAAc,CAAC,MAAM,EAAE,CAAC;gBAC9B,KAAK,MAAM;oBACT,OAAO,cAAc,CAAA;gBACvB,KAAK,SAAS;oBACZ,aAAa,EAAE,aAAa,CAAC,IAAI,EAAE,WAAW,EAAE,SAAS,EAAE;wBACzD,SAAS,EAAE,cAAc,CAAC,SAAS;wBACnC,gBAAgB,EACd,cAAc,CAAC,gBAAgB,gLAC/B,sBAAA,AAAmB,EACjB,cAAc,CAAC,MAAM,EACrB,cAAc,CAAC,SAAS,CACzB;wBACH,MAAM,EAAG,cAAiC,CAAC,kBAAkB;qBAC9D,CAAC,CAAA;oBACF,OAAO,SAAS,CAAA;gBAClB,KAAK,WAAW;oBACd,OAAO,SAAS,CAAA;gBAClB;oBACE,OAAO,OAAO,CAAC,MAAM,EAAE,CAAA;YAC3B,CAAC;QACH,CAAC,CAAC,CACD,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE;YACX,OAAO,CAAC,KAAK,CAAC,sCAAsC,EAAE,CAAC,CAAC,CAAA;YACxD,OAAO,SAAS,CAAA;QAClB,CAAC,CAAC,CAAA;IACN,CAAC,CAAA;IAED,IAAI,MAAM,GAAG,0BAA0B,CAAC,MAAM,CAAC,CAAA;IAE/C,IAAI,CAAC,MAAM,EAAE,CAAC;QACZ,MAAM,GAAG,2LAAA,AAAa,EAAC,UAAU,EAAE,QAAQ,CAAC,CAAA;QAC5C,0BAA0B,CAAC,MAAM,CAAC,GAAG,MAAM,CAAA;IAC7C,CAAC;IAED,MAAM,cAAc,GAAG,MAAM,MAAM,CAAA;IAEnC,IAAI,CAAC,CAAC,WAAW,IAAI,cAAc,CAAC,EAAE,CAAC;QACrC,MAAM,qKAAI,cAAW,CAAC,+CAA+C,CAAC,CAAA;IACxE,CAAC;IAED,OAAO,cAAc,CAAA;AACvB,CAAC","ignoreList":[0]}},
    {"offset": {"line": 2226, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2232, "column": 0}, "map": {"version":3,"file":"getTransactionMessage.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/utils/getTransactionMessage.ts"],"sourcesContent":["import type { LiFiStep, Process } from '@lifi/types'\nimport { formatUnits } from 'viem'\nimport { config } from '../config.js'\n\nexport const getTransactionNotSentMessage = async (\n  step?: LiFiStep,\n  process?: Process\n): Promise<string> => {\n  let transactionNotSend =\n    'Transaction was not sent, your funds are still in your wallet'\n\n  // add information about funds if available\n  if (step) {\n    const chain = await config.getChainById(step.action.fromChainId)\n\n    transactionNotSend += ` (${formatUnits(\n      BigInt(step.action.fromAmount),\n      step.action.fromToken.decimals\n    )} ${step.action.fromToken.symbol} on ${chain.name})`\n  }\n\n  transactionNotSend +=\n    \", please retry.<br/>If it still doesn't work, it is safe to delete this transfer and start a new one.\"\n\n  // add transaction explorer link if available\n  transactionNotSend += process?.txLink\n    ? `<br>You can check the failed transaction&nbsp;<a href=\"${process.txLink}\" target=\"_blank\" rel=\"nofollow noreferrer\">here</a>.`\n    : ''\n\n  return transactionNotSend\n}\n\nexport const getTransactionFailedMessage = async (\n  step: LiFiStep,\n  txLink?: string\n): Promise<string> => {\n  const chain = await config.getChainById(step.action.toChainId)\n\n  const baseString = `It appears that your transaction may not have been successful.\n  However, to confirm this, please check your ${chain.name} wallet for ${step.action.toToken.symbol}.`\n  return txLink\n    ? `${baseString}\n    You can also check the&nbsp;<a href=\"${txLink}\" target=\"_blank\" rel=\"nofollow noreferrer\">block explorer</a> for more information.`\n    : baseString\n}\n"],"names":[],"mappings":";;;;AAEA,OAAO,EAAE,MAAM,EAAE,MAAM,cAAc,CAAA;AADrC,OAAO,EAAE,WAAW,EAAE,MAAM,MAAM,CAAA;;;AAG3B,MAAM,4BAA4B,GAAG,KAAK,EAC/C,IAAe,EACf,OAAiB,EACA,EAAE;IACnB,IAAI,kBAAkB,GACpB,+DAA+D,CAAA;IAEjE,2CAA2C;IAC3C,IAAI,IAAI,EAAE,CAAC;QACT,MAAM,KAAK,GAAG,6JAAM,SAAM,CAAC,YAAY,CAAC,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC,CAAA;QAEhE,kBAAkB,IAAI,CAAA,EAAA,mKAAK,cAAW,AAAX,EACzB,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,EAC9B,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,QAAQ,CAC/B,CAAA,CAAA,EAAI,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,MAAM,CAAA,IAAA,EAAO,KAAK,CAAC,IAAI,CAAA,CAAA,CAAG,CAAA;IACvD,CAAC;IAED,kBAAkB,IAChB,uGAAuG,CAAA;IAEzG,6CAA6C;IAC7C,kBAAkB,IAAI,OAAO,EAAE,MAAM,GACjC,CAAA,uDAAA,EAA0D,OAAO,CAAC,MAAM,CAAA,qDAAA,CAAuD,GAC/H,EAAE,CAAA;IAEN,OAAO,kBAAkB,CAAA;AAC3B,CAAC,CAAA;AAEM,MAAM,2BAA2B,GAAG,KAAK,EAC9C,IAAc,EACd,MAAe,EACE,EAAE;IACnB,MAAM,KAAK,GAAG,6JAAM,SAAM,CAAC,YAAY,CAAC,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,CAAA;IAE9D,MAAM,UAAU,GAAG,CAAA;gDAC2B,KAAK,CAAC,IAAI,CAAA,YAAA,EAAe,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,MAAM,CAAA,CAAA,CAAG,CAAA;IACpG,OAAO,MAAM,GACT,GAAG,UAAU,CAAA;2CACwB,MAAM,CAAA,oFAAA,CAAsF,GACjI,UAAU,CAAA;AAChB,CAAC,CAAA","ignoreList":[0]}},
    {"offset": {"line": 2259, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2265, "column": 0}, "map": {"version":3,"file":"executionState.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/core/executionState.ts"],"sourcesContent":["import type { ExecutionOptions, RouteExtended, StepExecutor } from './types.js'\n\nexport interface ExecutionData {\n  route: RouteExtended\n  executors: StepExecutor[]\n  executionOptions?: ExecutionOptions\n  promise?: Promise<RouteExtended>\n}\n\nexport type ExecutionStateParams = Omit<ExecutionData, 'executors'>\n\nexport interface ExecutionState {\n  state: Partial<Record<string, ExecutionData>>\n  get(routeId: string): ExecutionData | undefined\n  create(params: ExecutionStateParams): ExecutionData\n  update(params: ExecutionStateParams): void\n  delete(routeId: string): void\n}\n\nexport const executionState: ExecutionState = {\n  state: {},\n  get(routeId: string) {\n    return this.state[routeId]\n  },\n  create(params) {\n    this.state[params.route.id] = {\n      ...this.state[params.route.id],\n      ...params,\n      executors: this.state[params.route.id]?.executors ?? [],\n    }\n    return this.state[params.route.id]!\n  },\n  update(state) {\n    if (this.state[state.route.id]) {\n      this.state[state.route.id] = {\n        ...this.state[state.route.id]!,\n        ...state,\n      }\n    }\n  },\n  delete(routeId) {\n    delete this.state[routeId]\n  },\n}\n"],"names":[],"mappings":";;;AAmBO,MAAM,cAAc,GAAmB;IAC5C,KAAK,EAAE,CAAA,CAAE;IACT,GAAG,EAAC,OAAe;QACjB,OAAO,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAA;IAC5B,CAAC;IACD,MAAM,EAAC,MAAM;QACX,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,CAAC,GAAG;YAC5B,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,CAAC;YAC9B,GAAG,MAAM;YACT,SAAS,EAAE,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE,SAAS,IAAI,EAAE;SACxD,CAAA;QACD,OAAO,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,CAAE,CAAA;IACrC,CAAC;IACD,MAAM,EAAC,KAAK;QACV,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE,CAAC;YAC/B,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE,CAAC,GAAG;gBAC3B,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE,CAAE;gBAC9B,GAAG,KAAK;aACT,CAAA;QACH,CAAC;IACH,CAAC;IACD,MAAM,EAAC,OAAO;QACZ,OAAO,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAA;IAC5B,CAAC;CACF,CAAA","ignoreList":[0]}},
    {"offset": {"line": 2293, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2299, "column": 0}, "map": {"version":3,"file":"StatusManager.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/core/StatusManager.ts"],"sourcesContent":["import type {\n  ChainId,\n  Execution,\n  ExecutionStatus,\n  LiFiStep,\n  Process,\n  ProcessStatus,\n  ProcessType,\n} from '@lifi/types'\nimport { executionState } from './executionState.js'\nimport { getProcessMessage } from './processMessages.js'\nimport type { LiFiStepExtended } from './types.js'\n\nexport type FindOrCreateProcessProps = {\n  step: LiFiStepExtended\n  type: ProcessType\n  chainId?: ChainId\n  status?: ProcessStatus\n}\n\n/**\n * Manages status updates of a route and provides various functions for tracking processes\n * @param {string} routeId The route dd this StatusManger belongs to.\n * @returns {StatusManager} An instance of StatusManager.\n */\nexport class StatusManager {\n  private readonly routeId: string\n  private shouldUpdate = true\n\n  constructor(routeId: string) {\n    this.routeId = routeId\n  }\n\n  /**\n   * Initializes the execution object of a Step.\n   * @param step  The current step in execution\n   * @returns The initialized execution object for this step and a function to update this step\n   */\n  initExecutionObject = (step: LiFiStepExtended): Execution => {\n    if (!step.execution) {\n      step.execution = {\n        status: 'PENDING',\n        process: [],\n      }\n      this.updateStepInRoute(step)\n    }\n\n    // Change status to PENDING after resuming from FAILED\n    if (step.execution.status === 'FAILED') {\n      step.execution.status = 'PENDING'\n      this.updateStepInRoute(step)\n    }\n\n    return step.execution\n  }\n\n  /**\n   * Updates the execution object of a Step.\n   * @param step  The current step in execution\n   * @param status  The status for the execution\n   * @param execution Optional. Information about received tokens\n   * @returns The step with the updated execution object\n   */\n  updateExecution(\n    step: LiFiStepExtended,\n    status: ExecutionStatus,\n    execution?: Partial<Execution>\n  ): LiFiStep {\n    if (!step.execution) {\n      throw Error(\"Can't update empty execution.\")\n    }\n    step.execution.status = status\n    if (execution) {\n      step.execution = {\n        ...step.execution,\n        ...execution,\n      }\n    }\n    this.updateStepInRoute(step)\n    return step\n  }\n\n  /**\n   * Create and push a new process into the execution.\n   * @param step.step The step that should contain the new process.\n   * @param step.type Type of the process. Used to identify already existing processes.\n   * @param step.chainId Chain Id of the process.\n   * @param step.status By default created procces is set to the STARTED status. We can override new process with the needed status.\n   * @param root0\n   * @param root0.step\n   * @param root0.type\n   * @param root0.chainId\n   * @param root0.status\n   * @returns Returns process.\n   */\n  findOrCreateProcess = ({\n    step,\n    type,\n    chainId,\n    status,\n  }: FindOrCreateProcessProps): Process => {\n    if (!step.execution?.process) {\n      throw new Error(\"Execution hasn't been initialized.\")\n    }\n\n    const process = step.execution.process.find((p) => p.type === type)\n\n    if (process) {\n      if (status && process.status !== status) {\n        process.status = status\n        this.updateStepInRoute(step)\n      }\n      return process\n    }\n\n    const newProcess: Process = {\n      type: type,\n      startedAt: Date.now(),\n      message: getProcessMessage(type, status ?? 'STARTED'),\n      status: status ?? 'STARTED',\n      chainId: chainId,\n    }\n\n    step.execution.process.push(newProcess)\n    this.updateStepInRoute(step)\n    return newProcess\n  }\n\n  /**\n   * Update a process object.\n   * @param step The step where the process should be updated\n   * @param type  The process type to update\n   * @param status The status the process gets.\n   * @param [params] Additional parameters to append to the process.\n   * @returns The update process\n   */\n  updateProcess = (\n    step: LiFiStepExtended,\n    type: ProcessType,\n    status: ProcessStatus,\n    params?: Partial<Process>\n  ): Process => {\n    if (!step.execution) {\n      throw new Error(\"Can't update an empty step execution.\")\n    }\n    const currentProcess = step?.execution?.process.find((p) => p.type === type)\n\n    if (!currentProcess) {\n      throw new Error(\"Can't find a process for the given type.\")\n    }\n\n    switch (status) {\n      case 'CANCELLED':\n        currentProcess.doneAt = Date.now()\n        break\n      case 'FAILED':\n        currentProcess.doneAt = Date.now()\n        step.execution.status = 'FAILED'\n        break\n      case 'DONE':\n        currentProcess.doneAt = Date.now()\n        break\n      case 'PENDING':\n        step.execution.status = 'PENDING'\n        break\n      case 'ACTION_REQUIRED':\n        step.execution.status = 'ACTION_REQUIRED'\n        break\n      default:\n        break\n    }\n\n    currentProcess.status = status\n    currentProcess.message = getProcessMessage(type, status)\n    // set extra parameters or overwritte the standard params set in the switch statement\n    if (params) {\n      for (const [key, value] of Object.entries(params)) {\n        currentProcess[key] = value\n      }\n    }\n    // Sort processes, the ones with DONE status go first\n    step.execution.process = [\n      ...step.execution.process.filter((process) => process.status === 'DONE'),\n      ...step.execution.process.filter((process) => process.status !== 'DONE'),\n    ]\n    this.updateStepInRoute(step) // updates the step in the route\n    return currentProcess\n  }\n\n  /**\n   * Remove a process from the execution\n   * @param step The step where the process should be removed from\n   * @param type  The process type to remove\n   */\n  removeProcess = (step: LiFiStepExtended, type: ProcessType): void => {\n    if (!step.execution) {\n      throw new Error(\"Execution hasn't been initialized.\")\n    }\n    const index = step.execution.process.findIndex((p) => p.type === type)\n    step.execution.process.splice(index, 1)\n    this.updateStepInRoute(step)\n  }\n\n  updateStepInRoute = (step: LiFiStep): LiFiStep => {\n    if (!this.shouldUpdate) {\n      return step\n    }\n    const data = executionState.get(this.routeId)\n\n    if (!data) {\n      throw new Error('Execution data not found.')\n    }\n\n    const stepIndex = data.route.steps.findIndex(\n      (routeStep) => routeStep.id === step.id\n    )\n\n    if (stepIndex === -1) {\n      throw new Error(\"Couldn't find a step to update.\")\n    }\n\n    data.route.steps[stepIndex] = { ...data.route.steps[stepIndex], ...step }\n\n    data.executionOptions?.updateRouteHook?.(data.route)\n    return data.route.steps[stepIndex]\n  }\n\n  allowUpdates(value: boolean): void {\n    this.shouldUpdate = value\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2507, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2513, "column": 0}, "map": {"version":3,"file":"BaseStepExecutor.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/core/BaseStepExecutor.ts"],"sourcesContent":["import type { LiFiStep } from '@lifi/types'\nimport { StatusManager } from './StatusManager.js'\nimport type {\n  ExecutionOptions,\n  InteractionSettings,\n  StepExecutor,\n  StepExecutorOptions,\n} from './types.js'\n\n// Please be careful when changing the defaults as it may break the behavior (e.g., background execution)\nconst defaultInteractionSettings = {\n  allowInteraction: true,\n  allowUpdates: true,\n  allowExecution: true,\n}\n\nexport abstract class BaseStepExecutor implements StepExecutor {\n  protected executionOptions?: ExecutionOptions\n  protected statusManager: StatusManager\n\n  public allowUserInteraction = true\n  public allowExecution = true\n\n  constructor(options: StepExecutorOptions) {\n    this.statusManager = new StatusManager(options.routeId)\n    this.executionOptions = options.executionOptions\n  }\n\n  setInteraction = (settings?: InteractionSettings): void => {\n    const interactionSettings = {\n      ...defaultInteractionSettings,\n      ...settings,\n    }\n    this.allowUserInteraction = interactionSettings.allowInteraction\n    this.statusManager.allowUpdates(interactionSettings.allowUpdates)\n    this.allowExecution = interactionSettings.allowExecution\n  }\n\n  abstract executeStep(step: LiFiStep): Promise<LiFiStep>\n}\n"],"names":[],"mappings":";;;AACA,OAAO,EAAE,aAAa,EAAE,MAAM,oBAAoB,CAAA;;AAQlD,yGAAyG;AACzG,MAAM,0BAA0B,GAAG;IACjC,gBAAgB,EAAE,IAAI;IACtB,YAAY,EAAE,IAAI;IAClB,cAAc,EAAE,IAAI;CACrB,CAAA;AAEK,MAAgB,gBAAgB;IAOpC,YAAY,OAA4B,CAAA;QAN9B,OAAA,cAAA,CAAA,IAAA,EAAA,oBAAA;;;;;WAAmC;QACnC,OAAA,cAAA,CAAA,IAAA,EAAA,iBAAA;;;;;WAA4B;QAE/B,OAAA,cAAA,CAAA,IAAA,EAAA,wBAAA;;;;mBAAuB,IAAI;WAAA;QAC3B,OAAA,cAAA,CAAA,IAAA,EAAA,kBAAA;;;;mBAAiB,IAAI;WAAA;QAO5B,OAAA,cAAA,CAAA,IAAA,EAAA,kBAAA;;;;mBAAiB,CAAC,QAA8B,EAAQ,EAAE;gBACxD,MAAM,mBAAmB,GAAG;oBAC1B,GAAG,0BAA0B;oBAC7B,GAAG,QAAQ;iBACZ,CAAA;gBACD,IAAI,CAAC,oBAAoB,GAAG,mBAAmB,CAAC,gBAAgB,CAAA;gBAChE,IAAI,CAAC,aAAa,CAAC,YAAY,CAAC,mBAAmB,CAAC,YAAY,CAAC,CAAA;gBACjE,IAAI,CAAC,cAAc,GAAG,mBAAmB,CAAC,cAAc,CAAA;YAC1D,CAAC;WAAA;QAZC,IAAI,CAAC,aAAa,GAAG,0KAAI,gBAAa,CAAC,OAAO,CAAC,OAAO,CAAC,CAAA;QACvD,IAAI,CAAC,gBAAgB,GAAG,OAAO,CAAC,gBAAgB,CAAA;IAClD,CAAC;CAaF","ignoreList":[0]}},
    {"offset": {"line": 2568, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2574, "column": 0}, "map": {"version":3,"file":"EVMStepExecutor.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/core/EVM/EVMStepExecutor.ts"],"sourcesContent":["import type {\n  ExtendedTransactionInfo,\n  FullStatusData,\n  Process,\n} from '@lifi/types'\nimport type {\n  Client,\n  GetAddressesReturnType,\n  Hash,\n  SendTransactionParameters,\n} from 'viem'\nimport { getAddresses, sendTransaction } from 'viem/actions'\nimport { getAction } from 'viem/utils'\nimport { config } from '../../config.js'\nimport { LiFiErrorCode } from '../../errors/constants.js'\nimport { TransactionError, ValidationError } from '../../errors/errors.js'\nimport { getStepTransaction } from '../../services/api.js'\nimport { getTransactionFailedMessage } from '../../utils/getTransactionMessage.js'\nimport { isZeroAddress } from '../../utils/isZeroAddress.js'\nimport { BaseStepExecutor } from '../BaseStepExecutor.js'\nimport { checkBalance } from '../checkBalance.js'\nimport { getSubstatusMessage } from '../processMessages.js'\nimport { stepComparison } from '../stepComparison.js'\nimport type {\n  LiFiStepExtended,\n  StepExecutorOptions,\n  TransactionParameters,\n} from '../types.js'\nimport { waitForReceivingTransaction } from '../waitForReceivingTransaction.js'\nimport { checkAllowance } from './checkAllowance.js'\nimport { updateMultisigRouteProcess } from './multisig.js'\nimport { parseEVMErrors } from './parseEVMErrors.js'\nimport { switchChain } from './switchChain.js'\nimport type { MultisigConfig, MultisigTransaction } from './types.js'\nimport { getMaxPriorityFeePerGas } from './utils.js'\nimport { waitForTransactionReceipt } from './waitForTransactionReceipt.js'\n\nexport interface EVMStepExecutorOptions extends StepExecutorOptions {\n  client: Client\n  multisig?: MultisigConfig\n}\n\nexport class EVMStepExecutor extends BaseStepExecutor {\n  private client: Client\n  private multisig?: MultisigConfig\n\n  constructor(options: EVMStepExecutorOptions) {\n    super(options)\n    this.client = options.client\n    this.multisig = options.multisig\n  }\n\n  // Ensure that we are using the right chain and wallet when executing transactions.\n  checkClient = async (\n    step: LiFiStepExtended,\n    process?: Process\n  ): Promise<Client | undefined> => {\n    const updatedClient = await switchChain(\n      this.client,\n      this.statusManager,\n      step,\n      this.allowUserInteraction,\n      this.executionOptions?.switchChainHook\n    )\n    if (updatedClient) {\n      this.client = updatedClient\n    }\n\n    // Prevent execution of the quote by wallet different from the one which requested the quote\n    let accountAddress = this.client.account?.address\n    if (!accountAddress) {\n      const accountAddresses = (await getAction(\n        this.client,\n        getAddresses,\n        'getAddresses'\n      )(undefined)) as GetAddressesReturnType\n      accountAddress = accountAddresses?.[0]\n    }\n    if (accountAddress !== step.action.fromAddress) {\n      let processToUpdate = process\n      if (!processToUpdate) {\n        // We need to create some process if we don't have one so we can show the error\n        processToUpdate = this.statusManager.findOrCreateProcess({\n          step,\n          type: 'TRANSACTION',\n        })\n      }\n      const errorMessage =\n        'The wallet address that requested the quote does not match the wallet address attempting to sign the transaction.'\n      this.statusManager.updateProcess(step, processToUpdate.type, 'FAILED', {\n        error: {\n          code: LiFiErrorCode.WalletChangedDuringExecution,\n          message: errorMessage,\n        },\n      })\n      this.statusManager.updateExecution(step, 'FAILED')\n      throw await parseEVMErrors(\n        new TransactionError(\n          LiFiErrorCode.WalletChangedDuringExecution,\n          errorMessage\n        ),\n        step,\n        process\n      )\n    }\n    return updatedClient\n  }\n\n  executeStep = async (step: LiFiStepExtended): Promise<LiFiStepExtended> => {\n    step.execution = this.statusManager.initExecutionObject(step)\n\n    // Find if it's bridging and the step is waiting for a transaction on the receiving chain\n    const recievingChainProcess = step.execution?.process.find(\n      (process) => process.type === 'RECEIVING_CHAIN'\n    )\n\n    // Make sure that the chain is still correct\n    // If the step is waiting for a transaction on the receiving chain, we do not switch the chain\n    // All changes are already done from the source chain\n    // Return the step\n    if (recievingChainProcess?.substatus !== 'WAIT_DESTINATION_TRANSACTION') {\n      const updatedClient = await this.checkClient(step)\n      if (!updatedClient) {\n        return step\n      }\n    }\n\n    const isMultisigClient = !!this.multisig?.isMultisigWalletClient\n    const multisigBatchTransactions: MultisigTransaction[] = []\n\n    const shouldBatchTransactions =\n      this.multisig?.shouldBatchTransactions &&\n      !!this.multisig.sendBatchTransaction\n\n    const fromChain = await config.getChainById(step.action.fromChainId)\n    const toChain = await config.getChainById(step.action.toChainId)\n\n    const isBridgeExecution = fromChain.id !== toChain.id\n    const currentProcessType = isBridgeExecution ? 'CROSS_CHAIN' : 'SWAP'\n\n    // STEP 1: Check allowance\n    const existingProcess = step.execution.process.find(\n      (p) => p.type === currentProcessType\n    )\n\n    // Check token approval only if fromToken is not the native token => no approval needed in that case\n    const checkForAllowance =\n      !existingProcess?.txHash &&\n      !isZeroAddress(step.action.fromToken.address) &&\n      (shouldBatchTransactions || !isMultisigClient)\n\n    if (checkForAllowance) {\n      const data = await checkAllowance(\n        this.client,\n        fromChain,\n        step,\n        this.statusManager,\n        this.executionOptions,\n        this.allowUserInteraction,\n        shouldBatchTransactions\n      )\n\n      if (data) {\n        // allowance doesn't need value\n        const baseTransaction: MultisigTransaction = {\n          to: step.action.fromToken.address,\n          data,\n        }\n\n        multisigBatchTransactions.push(baseTransaction)\n      }\n    }\n\n    // STEP 2: Get transaction\n    let process = this.statusManager.findOrCreateProcess({\n      step,\n      type: currentProcessType,\n      chainId: fromChain.id,\n    })\n\n    if (process.status !== 'DONE') {\n      const multisigProcess = step.execution.process.find(\n        (p) => !!p.multisigTxHash\n      )\n\n      try {\n        if (isMultisigClient && multisigProcess) {\n          const multisigTxHash = multisigProcess.multisigTxHash as Hash\n          if (!multisigTxHash) {\n            throw new ValidationError(\n              'Multisig internal transaction hash is undefined.'\n            )\n          }\n          await updateMultisigRouteProcess(\n            multisigTxHash,\n            step,\n            process.type,\n            fromChain,\n            this.statusManager,\n            this.multisig\n          )\n        }\n\n        let txHash: Hash\n        if (process.txHash) {\n          // Make sure that the chain is still correct\n          const updatedClient = await this.checkClient(step, process)\n          if (!updatedClient) {\n            return step\n          }\n\n          // Wait for exiting transaction\n          txHash = process.txHash as Hash\n        } else {\n          process = this.statusManager.updateProcess(\n            step,\n            process.type,\n            'STARTED'\n          )\n\n          // Check balance\n          await checkBalance(this.client.account!.address, step)\n\n          // Create new transaction\n          if (!step.transactionRequest) {\n            const { execution, ...stepBase } = step\n            const updatedStep = await getStepTransaction(stepBase)\n            const comparedStep = await stepComparison(\n              this.statusManager,\n              step,\n              updatedStep,\n              this.allowUserInteraction,\n              this.executionOptions\n            )\n            Object.assign(step, {\n              ...comparedStep,\n              execution: step.execution,\n            })\n          }\n\n          if (!step.transactionRequest) {\n            throw new TransactionError(\n              LiFiErrorCode.TransactionUnprepared,\n              'Unable to prepare transaction.'\n            )\n          }\n\n          // STEP 3: Send the transaction\n          // Make sure that the chain is still correct\n          const updatedClient = await this.checkClient(step, process)\n          if (!updatedClient) {\n            return step\n          }\n\n          process = this.statusManager.updateProcess(\n            step,\n            process.type,\n            'ACTION_REQUIRED'\n          )\n\n          if (!this.allowUserInteraction) {\n            return step\n          }\n\n          let transactionRequest: TransactionParameters = {\n            to: step.transactionRequest.to,\n            from: step.transactionRequest.from,\n            data: step.transactionRequest.data,\n            value: step.transactionRequest.value\n              ? BigInt(step.transactionRequest.value)\n              : undefined,\n            gas: step.transactionRequest.gasLimit\n              ? BigInt(step.transactionRequest.gasLimit)\n              : undefined,\n            // gasPrice: step.transactionRequest.gasPrice\n            //   ? BigInt(step.transactionRequest.gasPrice as string)\n            //   : undefined,\n            // maxFeePerGas: step.transactionRequest.maxFeePerGas\n            //   ? BigInt(step.transactionRequest.maxFeePerGas as string)\n            //   : undefined,\n            maxPriorityFeePerGas:\n              this.client.account?.type === 'local'\n                ? await getMaxPriorityFeePerGas(this.client)\n                : step.transactionRequest.maxPriorityFeePerGas\n                  ? BigInt(step.transactionRequest.maxPriorityFeePerGas)\n                  : undefined,\n          }\n\n          if (this.executionOptions?.updateTransactionRequestHook) {\n            const customizedTransactionRequest: TransactionParameters =\n              await this.executionOptions.updateTransactionRequestHook({\n                requestType: 'transaction',\n                ...transactionRequest,\n              })\n\n            transactionRequest = {\n              ...transactionRequest,\n              ...customizedTransactionRequest,\n            }\n          }\n\n          if (shouldBatchTransactions && this.multisig?.sendBatchTransaction) {\n            if (transactionRequest.to && transactionRequest.data) {\n              const populatedTransaction: MultisigTransaction = {\n                value: transactionRequest.value,\n                to: transactionRequest.to,\n                data: transactionRequest.data,\n              }\n              multisigBatchTransactions.push(populatedTransaction)\n\n              txHash = await this.multisig?.sendBatchTransaction(\n                multisigBatchTransactions\n              )\n            } else {\n              throw new TransactionError(\n                LiFiErrorCode.TransactionUnprepared,\n                'Unable to prepare transaction.'\n              )\n            }\n          } else {\n            txHash = await getAction(\n              this.client,\n              sendTransaction,\n              'sendTransaction'\n            )({\n              to: transactionRequest.to,\n              account: this.client.account!,\n              data: transactionRequest.data,\n              value: transactionRequest.value,\n              gas: transactionRequest.gas,\n              gasPrice: transactionRequest.gasPrice,\n              maxFeePerGas: transactionRequest.maxFeePerGas,\n              maxPriorityFeePerGas: transactionRequest.maxPriorityFeePerGas,\n              chain: null,\n            } as SendTransactionParameters)\n          }\n\n          // STEP 4: Wait for the transaction\n          if (isMultisigClient) {\n            process = this.statusManager.updateProcess(\n              step,\n              process.type,\n              'ACTION_REQUIRED',\n              {\n                multisigTxHash: txHash,\n              }\n            )\n          } else {\n            process = this.statusManager.updateProcess(\n              step,\n              process.type,\n              'PENDING',\n              {\n                txHash: txHash,\n                txLink: `${fromChain.metamask.blockExplorerUrls[0]}tx/${txHash}`,\n              }\n            )\n          }\n        }\n\n        const transactionReceipt = await waitForTransactionReceipt({\n          client: this.client,\n          chainId: fromChain.id,\n          txHash,\n          onReplaced: (response) => {\n            this.statusManager.updateProcess(step, process.type, 'PENDING', {\n              txHash: response.transaction.hash,\n              txLink: `${fromChain.metamask.blockExplorerUrls[0]}tx/${response.transaction.hash}`,\n            })\n          },\n        })\n\n        // if it's multisig wallet client and the process is in ACTION_REQUIRED\n        // then signatures are still needed\n        if (isMultisigClient && process.status === 'ACTION_REQUIRED') {\n          await updateMultisigRouteProcess(\n            transactionReceipt?.transactionHash || txHash,\n            step,\n            process.type,\n            fromChain,\n            this.statusManager,\n            this.multisig\n          )\n        }\n\n        // Update pending process if the transaction hash from the receipt is different.\n        // This might happen if the transaction was replaced.\n        if (\n          !isMultisigClient &&\n          transactionReceipt?.transactionHash &&\n          transactionReceipt.transactionHash !== txHash\n        ) {\n          process = this.statusManager.updateProcess(\n            step,\n            process.type,\n            'PENDING',\n            {\n              txHash: transactionReceipt.transactionHash,\n              txLink: `${fromChain.metamask.blockExplorerUrls[0]}tx/${transactionReceipt.transactionHash}`,\n            }\n          )\n        }\n\n        if (isBridgeExecution) {\n          process = this.statusManager.updateProcess(step, process.type, 'DONE')\n        }\n      } catch (e: any) {\n        const error = await parseEVMErrors(e, step, process)\n        process = this.statusManager.updateProcess(\n          step,\n          process.type,\n          'FAILED',\n          {\n            error: {\n              message: error.cause.message,\n              code: error.code,\n            },\n          }\n        )\n        this.statusManager.updateExecution(step, 'FAILED')\n\n        throw error\n      }\n    }\n\n    // STEP 5: Wait for the receiving chain\n    const processTxHash = process.txHash\n    if (isBridgeExecution) {\n      process = this.statusManager.findOrCreateProcess({\n        step,\n        type: 'RECEIVING_CHAIN',\n        status: 'PENDING',\n        chainId: toChain.id,\n      })\n    }\n    let statusResponse: FullStatusData\n\n    try {\n      if (!processTxHash) {\n        throw new Error('Transaction hash is undefined.')\n      }\n      statusResponse = (await waitForReceivingTransaction(\n        processTxHash,\n        this.statusManager,\n        process.type,\n        step\n      )) as FullStatusData\n\n      const statusReceiving =\n        statusResponse.receiving as ExtendedTransactionInfo\n\n      process = this.statusManager.updateProcess(step, process.type, 'DONE', {\n        substatus: statusResponse.substatus,\n        substatusMessage:\n          statusResponse.substatusMessage ||\n          getSubstatusMessage(statusResponse.status, statusResponse.substatus),\n        txHash: statusReceiving?.txHash,\n        txLink: `${toChain.metamask.blockExplorerUrls[0]}tx/${statusReceiving?.txHash}`,\n      })\n\n      this.statusManager.updateExecution(step, 'DONE', {\n        fromAmount: statusResponse.sending.amount,\n        toAmount: statusReceiving?.amount,\n        toToken: statusReceiving?.token,\n        gasCosts: [\n          {\n            amount: statusResponse.sending.gasAmount,\n            amountUSD: statusResponse.sending.gasAmountUSD,\n            token: statusResponse.sending.gasToken,\n            estimate: statusResponse.sending.gasUsed,\n            limit: statusResponse.sending.gasUsed,\n            price: statusResponse.sending.gasPrice,\n            type: 'SEND',\n          },\n        ],\n      })\n    } catch (e: unknown) {\n      const htmlMessage = await getTransactionFailedMessage(\n        step,\n        process.txLink\n      )\n\n      process = this.statusManager.updateProcess(step, process.type, 'FAILED', {\n        error: {\n          code: LiFiErrorCode.TransactionFailed,\n          message: 'Failed while waiting for receiving chain.',\n          htmlMessage,\n        },\n      })\n      this.statusManager.updateExecution(step, 'FAILED')\n      throw await parseEVMErrors(e as Error, step, process)\n    }\n\n    // DONE\n    return step\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2920, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2926, "column": 0}, "map": {"version":3,"file":"EVM.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/core/EVM/EVM.ts"],"sourcesContent":["import { ChainType } from '@lifi/types'\nimport { isAddress } from 'viem'\nimport type { StepExecutorOptions } from '../types.js'\nimport { EVMStepExecutor } from './EVMStepExecutor.js'\nimport { getENSAddress } from './getENSAddress.js'\nimport { getEVMBalance } from './getEVMBalance.js'\nimport type { EVMProvider, EVMProviderOptions } from './types.js'\n\nexport function EVM(options?: EVMProviderOptions): EVMProvider {\n  const _options: EVMProviderOptions = options ?? {}\n  return {\n    get type() {\n      return ChainType.EVM\n    },\n    get multisig() {\n      return _options.multisig\n    },\n    isAddress,\n    resolveAddress: getENSAddress,\n    getBalance: getEVMBalance,\n    async getStepExecutor(\n      options: StepExecutorOptions\n    ): Promise<EVMStepExecutor> {\n      if (!_options.getWalletClient) {\n        throw new Error('Client is not provided.')\n      }\n\n      const walletClient = await _options.getWalletClient()\n\n      const executor = new EVMStepExecutor({\n        client: walletClient,\n        multisig: _options.multisig,\n        routeId: options.routeId,\n        executionOptions: {\n          ...options.executionOptions,\n          switchChainHook:\n            _options.switchChain ?? options.executionOptions?.switchChainHook,\n        },\n      })\n\n      return executor\n    },\n    setOptions(options: EVMProviderOptions) {\n      Object.assign(_options, options)\n    },\n  }\n}\n"],"names":[],"mappings":";;;AAAA,OAAO,EAAE,SAAS,EAAE,MAAM,aAAa,CAAA;AACvC,OAAO,EAAE,SAAS,EAAE,MAAM,MAAM,CAAA;AAGhC,OAAO,EAAE,aAAa,EAAE,MAAM,oBAAoB,CAAA;AAClD,OAAO,EAAE,aAAa,EAAE,MAAM,oBAAoB,CAAA;AAFlD,OAAO,EAAE,eAAe,EAAE,MAAM,sBAAsB,CAAA;;;;;;AAKhD,SAAU,GAAG,CAAC,OAA4B;IAC9C,MAAM,QAAQ,GAAuB,OAAO,IAAI,CAAA,CAAE,CAAA;IAClD,OAAO;QACL,IAAI,IAAI,IAAA;YACN,OAAO,8KAAS,CAAC,GAAG,CAAA;QACtB,CAAC;QACD,IAAI,QAAQ,IAAA;YACV,OAAO,QAAQ,CAAC,QAAQ,CAAA;QAC1B,CAAC;mBACD,0KAAS;QACT,cAAc,+KAAE,gBAAa;QAC7B,UAAU,+KAAE,gBAAa;QACzB,KAAK,CAAC,eAAe,EACnB,OAA4B;YAE5B,IAAI,CAAC,QAAQ,CAAC,eAAe,EAAE,CAAC;gBAC9B,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAA;YAC5C,CAAC;YAED,MAAM,YAAY,GAAG,MAAM,QAAQ,CAAC,eAAe,EAAE,CAAA;YAErD,MAAM,QAAQ,GAAG,mLAAI,kBAAe,CAAC;gBACnC,MAAM,EAAE,YAAY;gBACpB,QAAQ,EAAE,QAAQ,CAAC,QAAQ;gBAC3B,OAAO,EAAE,OAAO,CAAC,OAAO;gBACxB,gBAAgB,EAAE;oBAChB,GAAG,OAAO,CAAC,gBAAgB;oBAC3B,eAAe,EACb,QAAQ,CAAC,WAAW,IAAI,OAAO,CAAC,gBAAgB,EAAE,eAAe;iBACpE;aACF,CAAC,CAAA;YAEF,OAAO,QAAQ,CAAA;QACjB,CAAC;QACD,UAAU,EAAC,OAA2B;YACpC,MAAM,CAAC,MAAM,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAA;QAClC,CAAC;KACF,CAAA;AACH,CAAC","ignoreList":[0]}},
    {"offset": {"line": 2972, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2978, "column": 0}, "map": {"version":3,"file":"isSVMAddress.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/core/Solana/isSVMAddress.ts"],"sourcesContent":["import { PublicKey } from '@solana/web3.js'\n\nexport function isSVMAddress(address: string): boolean {\n  try {\n    new PublicKey(address)\n    return true\n  } catch (_error) {\n    return false\n  }\n}\n"],"names":[],"mappings":";;;AAAA,OAAO,EAAE,SAAS,EAAE,MAAM,iBAAiB,CAAA;;AAErC,SAAU,YAAY,CAAC,OAAe;IAC1C,IAAI,CAAC;QACH,kKAAI,YAAS,CAAC,OAAO,CAAC,CAAA;QACtB,OAAO,IAAI,CAAA;IACb,CAAC,CAAC,OAAO,MAAM,EAAE,CAAC;QAChB,OAAO,KAAK,CAAA;IACd,CAAC;AACH,CAAC","ignoreList":[0]}},
    {"offset": {"line": 2991, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2997, "column": 0}, "map": {"version":3,"file":"getSNSAddress.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/core/Solana/getSNSAddress.ts"],"sourcesContent":["import { isSVMAddress } from './isSVMAddress.js'\n\ninterface SNSResult {\n  s: 'ok' | 'error'\n  result: string\n}\n\n// Subject to change\n// https://github.com/Bonfida/sns-sdk?tab=readme-ov-file#sdk-proxy\nexport const getSNSAddress = async (name: string) => {\n  try {\n    if (!name.endsWith('.sol')) {\n      return\n    }\n    // const rpcUrl = await getRpcUrl(ChainId.SOL)\n    const snsWorkerUrl = `https://sns-sdk-proxy.bonfida.workers.dev/resolve/${name}`\n    const response: Response = await fetch(snsWorkerUrl)\n    if (!response.ok) {\n      return\n    }\n\n    const data: SNSResult = await response.json()\n\n    if (!isSVMAddress(data.result)) {\n      return\n    }\n\n    return data.result\n  } catch (_) {\n    // ignore\n    return\n  }\n}\n"],"names":[],"mappings":";;;AAAA,OAAO,EAAE,YAAY,EAAE,MAAM,mBAAmB,CAAA;;AASzC,MAAM,aAAa,GAAG,KAAK,EAAE,IAAY,EAAE,EAAE;IAClD,IAAI,CAAC;QACH,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,EAAE,CAAC;YAC3B,OAAM;QACR,CAAC;QACD,8CAA8C;QAC9C,MAAM,YAAY,GAAG,CAAA,kDAAA,EAAqD,IAAI,EAAE,CAAA;QAChF,MAAM,QAAQ,GAAa,MAAM,KAAK,CAAC,YAAY,CAAC,CAAA;QACpD,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE,CAAC;YACjB,OAAM;QACR,CAAC;QAED,MAAM,IAAI,GAAc,MAAM,QAAQ,CAAC,IAAI,EAAE,CAAA;QAE7C,IAAI,oLAAC,eAAA,AAAY,EAAC,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC;YAC/B,OAAM;QACR,CAAC;QAED,OAAO,IAAI,CAAC,MAAM,CAAA;IACpB,CAAC,CAAC,OAAO,CAAC,EAAE,CAAC;QACX,SAAS;QACT,OAAM;IACR,CAAC;AACH,CAAC,CAAA","ignoreList":[0]}},
    {"offset": {"line": 3023, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3029, "column": 0}, "map": {"version":3,"file":"types.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/core/Solana/types.ts"],"sourcesContent":["import { ChainType } from '@lifi/types'\nimport type { SignerWalletAdapter } from '@solana/wallet-adapter-base'\nimport type { SDKProvider } from '../types.js'\n\nexport interface SolanaProviderOptions {\n  getWalletAdapter?: () => Promise<SignerWalletAdapter>\n}\n\nexport interface SolanaProvider extends SDKProvider {\n  setOptions(options: SolanaProviderOptions): void\n}\n\nexport function isSolana(provider: SDKProvider): provider is SolanaProvider {\n  return provider.type === ChainType.SVM\n}\n\nexport const TokenProgramAddress = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'\n"],"names":[],"mappings":";;;;AAAA,OAAO,EAAE,SAAS,EAAE,MAAM,aAAa,CAAA;;AAYjC,SAAU,QAAQ,CAAC,QAAqB;IAC5C,OAAO,QAAQ,CAAC,IAAI,uKAAK,YAAS,CAAC,GAAG,CAAA;AACxC,CAAC;AAEM,MAAM,mBAAmB,GAAG,6CAA6C,CAAA","ignoreList":[0]}},
    {"offset": {"line": 3039, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3045, "column": 0}, "map": {"version":3,"file":"connection.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/core/Solana/connection.ts"],"sourcesContent":["import { ChainId } from '@lifi/types'\nimport { Connection } from '@solana/web3.js'\nimport { getRpcUrls } from '../rpc.js'\n\nconst connections = new Map<string, Connection>()\n\n/**\n * Initializes the Solana connections if they haven't been initialized yet.\n * @returns - Promise that resolves when connections are initialized.\n */\nexport const ensureConnections = async (): Promise<void> => {\n  const rpcUrls = await getRpcUrls(ChainId.SOL)\n  for (const rpcUrl of rpcUrls) {\n    if (!connections.get(rpcUrl)) {\n      const connection = new Connection(rpcUrl)\n      connections.set(rpcUrl, connection)\n    }\n  }\n}\n\n/**\n * Wrapper around getting the connection (RPC provider) for Solana\n * @returns - Solana RPC connections\n */\nexport const getSolanaConnections = async (): Promise<Connection[]> => {\n  await ensureConnections()\n  return Array.from(connections.values())\n}\n\n/**\n * Calls a function on the Connection instances with retry logic.\n * @param fn - The function to call, which receives a Connection instance.\n * @returns - The result of the function call.\n */\nexport async function callSolanaWithRetry<R>(\n  fn: (connection: Connection) => Promise<R>\n): Promise<R> {\n  // Ensure connections are initialized\n  await ensureConnections()\n  let lastError: any = null\n  for (const connection of connections.values()) {\n    try {\n      const result = await fn(connection)\n      return result\n    } catch (error) {\n      lastError = error\n    }\n  }\n  // Throw the last encountered error\n  throw lastError\n}\n"],"names":[],"mappings":";;;;;AACA,OAAO,EAAE,UAAU,EAAE,MAAM,iBAAiB,CAAA;AAC5C,OAAO,EAAE,UAAU,EAAE,MAAM,WAAW,CAAA;AAFtC,OAAO,EAAE,OAAO,EAAE,MAAM,aAAa,CAAA;;;;AAIrC,MAAM,WAAW,GAAG,IAAI,GAAG,EAAsB,CAAA;AAM1C,MAAM,iBAAiB,GAAG,KAAK,IAAmB,EAAE;IACzD,MAAM,OAAO,GAAG,sKAAM,aAAA,AAAU,mKAAC,UAAO,CAAC,GAAG,CAAC,CAAA;IAC7C,KAAK,MAAM,MAAM,IAAI,OAAO,CAAE,CAAC;QAC7B,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,CAAC;YAC7B,MAAM,UAAU,GAAG,kKAAI,aAAU,CAAC,MAAM,CAAC,CAAA;YACzC,WAAW,CAAC,GAAG,CAAC,MAAM,EAAE,UAAU,CAAC,CAAA;QACrC,CAAC;IACH,CAAC;AACH,CAAC,CAAA;AAMM,MAAM,oBAAoB,GAAG,KAAK,IAA2B,EAAE;IACpE,MAAM,iBAAiB,EAAE,CAAA;IACzB,OAAO,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,MAAM,EAAE,CAAC,CAAA;AACzC,CAAC,CAAA;AAOM,KAAK,UAAU,mBAAmB,CACvC,EAA0C;IAE1C,qCAAqC;IACrC,MAAM,iBAAiB,EAAE,CAAA;IACzB,IAAI,SAAS,GAAQ,IAAI,CAAA;IACzB,KAAK,MAAM,UAAU,IAAI,WAAW,CAAC,MAAM,EAAE,CAAE,CAAC;QAC9C,IAAI,CAAC;YACH,MAAM,MAAM,GAAG,MAAM,EAAE,CAAC,UAAU,CAAC,CAAA;YACnC,OAAO,MAAM,CAAA;QACf,CAAC,CAAC,OAAO,KAAK,EAAE,CAAC;YACf,SAAS,GAAG,KAAK,CAAA;QACnB,CAAC;IACH,CAAC;IACD,mCAAmC;IACnC,MAAM,SAAS,CAAA;AACjB,CAAC","ignoreList":[0]}},
    {"offset": {"line": 3085, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3091, "column": 0}, "map": {"version":3,"file":"getSolanaBalance.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/core/Solana/getSolanaBalance.ts"],"sourcesContent":["import type { ChainId, Token, TokenAmount } from '@lifi/types'\nimport { PublicKey } from '@solana/web3.js'\nimport { SolSystemProgram } from '../../constants.js'\nimport { withDedupe } from '../../utils/withDedupe.js'\nimport { callSolanaWithRetry } from './connection.js'\nimport { TokenProgramAddress } from './types.js'\n\nexport const getSolanaBalance = async (\n  walletAddress: string,\n  tokens: Token[]\n): Promise<TokenAmount[]> => {\n  if (tokens.length === 0) {\n    return []\n  }\n  const { chainId } = tokens[0]\n  for (const token of tokens) {\n    if (token.chainId !== chainId) {\n      console.warn('Requested tokens have to be on the same chain.')\n    }\n  }\n\n  return getSolanaBalanceDefault(chainId, tokens, walletAddress)\n}\n\nconst getSolanaBalanceDefault = async (\n  _chainId: ChainId,\n  tokens: Token[],\n  walletAddress: string\n): Promise<TokenAmount[]> => {\n  const accountPublicKey = new PublicKey(walletAddress)\n  const tokenProgramPublicKey = new PublicKey(TokenProgramAddress)\n  const [slot, balance, tokenAccountsByOwner] = await Promise.allSettled([\n    withDedupe(\n      () =>\n        callSolanaWithRetry((connection) => connection.getSlot('confirmed')),\n      { id: `${getSolanaBalanceDefault.name}.getSlot` }\n    ),\n    withDedupe(\n      () =>\n        callSolanaWithRetry((connection) =>\n          connection.getBalance(accountPublicKey, 'confirmed')\n        ),\n      { id: `${getSolanaBalanceDefault.name}.getBalance` }\n    ),\n    withDedupe(\n      () =>\n        callSolanaWithRetry((connection) =>\n          connection.getParsedTokenAccountsByOwner(\n            accountPublicKey,\n            {\n              programId: tokenProgramPublicKey,\n            },\n            'confirmed'\n          )\n        ),\n      { id: `${getSolanaBalanceDefault.name}.getParsedTokenAccountsByOwner` }\n    ),\n  ])\n  const blockNumber = slot.status === 'fulfilled' ? BigInt(slot.value) : 0n\n  const solBalance = balance.status === 'fulfilled' ? BigInt(balance.value) : 0n\n  const walletTokenAmounts =\n    tokenAccountsByOwner.status === 'fulfilled'\n      ? tokenAccountsByOwner.value.value.reduce(\n          (tokenAmounts, value) => {\n            const amount = BigInt(\n              value.account.data.parsed.info.tokenAmount.amount\n            )\n            if (amount > 0n) {\n              tokenAmounts[value.account.data.parsed.info.mint] = amount\n            }\n            return tokenAmounts\n          },\n          {} as Record<string, bigint>\n        )\n      : {}\n  walletTokenAmounts[SolSystemProgram] = solBalance\n  const tokenAmounts: TokenAmount[] = tokens.map((token) => {\n    if (walletTokenAmounts[token.address]) {\n      return {\n        ...token,\n        amount: walletTokenAmounts[token.address],\n        blockNumber,\n      }\n    }\n    return {\n      ...token,\n      blockNumber,\n    }\n  })\n  return tokenAmounts\n}\n"],"names":[],"mappings":";;;AACA,OAAO,EAAE,SAAS,EAAE,MAAM,iBAAiB,CAAA;AAI3C,OAAO,EAAE,mBAAmB,EAAE,MAAM,YAAY,CAAA;AAFhD,OAAO,EAAE,UAAU,EAAE,MAAM,2BAA2B,CAAA;AACtD,OAAO,EAAE,mBAAmB,EAAE,MAAM,iBAAiB,CAAA;AAFrD,OAAO,EAAE,gBAAgB,EAAE,MAAM,oBAAoB,CAAA;;;;;;AAK9C,MAAM,gBAAgB,GAAG,KAAK,EACnC,aAAqB,EACrB,MAAe,EACS,EAAE;IAC1B,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;QACxB,OAAO,EAAE,CAAA;IACX,CAAC;IACD,MAAM,EAAE,OAAO,EAAE,GAAG,MAAM,CAAC,CAAC,CAAC,CAAA;IAC7B,KAAK,MAAM,KAAK,IAAI,MAAM,CAAE,CAAC;QAC3B,IAAI,KAAK,CAAC,OAAO,KAAK,OAAO,EAAE,CAAC;YAC9B,OAAO,CAAC,IAAI,CAAC,gDAAgD,CAAC,CAAA;QAChE,CAAC;IACH,CAAC;IAED,OAAO,uBAAuB,CAAC,OAAO,EAAE,MAAM,EAAE,aAAa,CAAC,CAAA;AAChE,CAAC,CAAA;AAED,MAAM,uBAAuB,GAAG,KAAK,EACnC,QAAiB,EACjB,MAAe,EACf,aAAqB,EACG,EAAE;IAC1B,MAAM,gBAAgB,GAAG,kKAAI,YAAS,CAAC,aAAa,CAAC,CAAA;IACrD,MAAM,qBAAqB,GAAG,kKAAI,YAAS,yKAAC,sBAAmB,CAAC,CAAA;IAChE,MAAM,CAAC,IAAI,EAAE,OAAO,EAAE,oBAAoB,CAAC,GAAG,MAAM,OAAO,CAAC,UAAU,CAAC;gLACrE,aAAA,AAAU,EACR,GAAG,CACD,CADG,sMACH,AAAmB,EAAC,CAAC,UAAU,EAAE,CAAG,CAAD,SAAW,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC,EACtE;YAAE,EAAE,EAAE,GAAG,uBAAuB,CAAC,IAAI,CAAA,QAAA,CAAU;QAAA,CAAE,CAClD;YACD,iLAAA,AAAU,EACR,GAAG,EAAE,gLACH,sBAAA,AAAmB,EAAC,CAAC,UAAU,EAAE,CAC/B,CADiC,SACvB,CAAC,UAAU,CAAC,gBAAgB,EAAE,WAAW,CAAC,CACrD,EACH;YAAE,EAAE,EAAE,GAAG,uBAAuB,CAAC,IAAI,CAAA,WAAA,CAAa;QAAA,CAAE,CACrD;gLACD,aAAA,AAAU,EACR,GAAG,CACD,CADG,sMACH,AAAmB,EAAC,CAAC,UAAU,EAAE,CAC/B,CADiC,SACvB,CAAC,6BAA6B,CACtC,gBAAgB,EAChB;oBACE,SAAS,EAAE,qBAAqB;iBACjC,EACD,WAAW,CACZ,CACF,EACH;YAAE,EAAE,EAAE,GAAG,uBAAuB,CAAC,IAAI,CAAA,8BAAA,CAAgC;QAAA,CAAE,CACxE;KACF,CAAC,CAAA;IACF,MAAM,WAAW,GAAG,IAAI,CAAC,MAAM,KAAK,WAAW,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE,CAAA;IACzE,MAAM,UAAU,GAAG,OAAO,CAAC,MAAM,KAAK,WAAW,CAAC,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,EAAE,CAAA;IAC9E,MAAM,kBAAkB,GACtB,oBAAoB,CAAC,MAAM,KAAK,WAAW,GACvC,oBAAoB,CAAC,KAAK,CAAC,KAAK,CAAC,MAAM,CACrC,CAAC,YAAY,EAAE,KAAK,EAAE,EAAE;QACtB,MAAM,MAAM,GAAG,MAAM,CACnB,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,MAAM,CAClD,CAAA;QACD,IAAI,MAAM,GAAG,EAAE,EAAE,CAAC;YAChB,YAAY,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,MAAM,CAAA;QAC5D,CAAC;QACD,OAAO,YAAY,CAAA;IACrB,CAAC,EACD,CAAA,CAA4B,CAC7B,GACD,CAAA,CAAE,CAAA;IACR,kBAAkB,CAAC,6KAAgB,CAAC,GAAG,UAAU,CAAA;IACjD,MAAM,YAAY,GAAkB,MAAM,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE;QACvD,IAAI,kBAAkB,CAAC,KAAK,CAAC,OAAO,CAAC,EAAE,CAAC;YACtC,OAAO;gBACL,GAAG,KAAK;gBACR,MAAM,EAAE,kBAAkB,CAAC,KAAK,CAAC,OAAO,CAAC;gBACzC,WAAW;aACZ,CAAA;QACH,CAAC;QACD,OAAO;YACL,GAAG,KAAK;YACR,WAAW;SACZ,CAAA;IACH,CAAC,CAAC,CAAA;IACF,OAAO,YAAY,CAAA;AACrB,CAAC,CAAA","ignoreList":[0]}},
    {"offset": {"line": 3157, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3163, "column": 0}, "map": {"version":3,"file":"base64ToUint8Array.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/utils/base64ToUint8Array.ts"],"sourcesContent":["export function base64ToUint8Array(base64String: string) {\n  const binaryString = atob(base64String)\n  const len = binaryString.length\n  const bytes = new Uint8Array(len)\n  for (let i = 0; i < len; i++) {\n    bytes[i] = binaryString.charCodeAt(i)\n  }\n  return bytes\n}\n"],"names":[],"mappings":";;;AAAM,SAAU,kBAAkB,CAAC,YAAoB;IACrD,MAAM,YAAY,GAAG,IAAI,CAAC,YAAY,CAAC,CAAA;IACvC,MAAM,GAAG,GAAG,YAAY,CAAC,MAAM,CAAA;IAC/B,MAAM,KAAK,GAAG,IAAI,UAAU,CAAC,GAAG,CAAC,CAAA;IACjC,IAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,CAAE,CAAC;QAC7B,KAAK,CAAC,CAAC,CAAC,GAAG,YAAY,CAAC,UAAU,CAAC,CAAC,CAAC,CAAA;IACvC,CAAC;IACD,OAAO,KAAK,CAAA;AACd,CAAC","ignoreList":[0]}},
    {"offset": {"line": 3175, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3181, "column": 0}, "map": {"version":3,"file":"sendAndConfirmTransaction.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/core/Solana/sendAndConfirmTransaction.ts"],"sourcesContent":["import type {\n  SendOptions,\n  SignatureResult,\n  VersionedTransaction,\n} from '@solana/web3.js'\nimport bs58 from 'bs58'\nimport { sleep } from '../../utils/sleep.js'\nimport { getSolanaConnections } from './connection.js'\n\nexport type ConfirmedTransactionResult = {\n  signatureResult: SignatureResult | null\n  txSignature: string\n}\n\n/**\n * Sends a Solana transaction to multiple RPC endpoints and returns the confirmation\n * as soon as any of them confirm the transaction.\n * @param signedTx - The signed transaction to send.\n * @returns - The confirmation result of the transaction.\n */\nexport async function sendAndConfirmTransaction(\n  signedTx: VersionedTransaction\n): Promise<ConfirmedTransactionResult> {\n  const connections = await getSolanaConnections()\n\n  const signedTxSerialized = signedTx.serialize()\n  // Create transaction hash (signature)\n  const txSignature = bs58.encode(signedTx.signatures[0])\n\n  if (!txSignature) {\n    throw new Error('Transaction signature is missing.')\n  }\n\n  const rawTransactionOptions: SendOptions = {\n    // We can skip preflight check after the first transaction has been sent\n    // https://solana.com/docs/advanced/retry#the-cost-of-skipping-preflight\n    skipPreflight: true,\n    // Setting max retries to 0 as we are handling retries manually\n    maxRetries: 0,\n    // https://solana.com/docs/advanced/confirmation#use-an-appropriate-preflight-commitment-level\n    preflightCommitment: 'confirmed',\n  }\n\n  for (const connection of connections) {\n    connection\n      .sendRawTransaction(signedTxSerialized, rawTransactionOptions)\n      .catch()\n  }\n\n  const abortControllers: AbortController[] = []\n\n  const confirmPromises = connections.map(async (connection) => {\n    const abortController = new AbortController()\n    abortControllers.push(abortController)\n    try {\n      const blockhashResult = await connection.getLatestBlockhash('confirmed')\n\n      const confirmTransactionPromise = connection\n        .confirmTransaction(\n          {\n            signature: txSignature,\n            blockhash: blockhashResult.blockhash,\n            lastValidBlockHeight: blockhashResult.lastValidBlockHeight,\n            abortSignal: abortController.signal,\n          },\n          'confirmed'\n        )\n        .then((result) => result.value)\n\n      let signatureResult: SignatureResult | null = null\n      let blockHeight = await connection.getBlockHeight('confirmed')\n\n      while (\n        !signatureResult &&\n        blockHeight < blockhashResult.lastValidBlockHeight\n      ) {\n        await connection.sendRawTransaction(\n          signedTxSerialized,\n          rawTransactionOptions\n        )\n        signatureResult = await Promise.race([\n          confirmTransactionPromise,\n          sleep(1000),\n        ])\n\n        if (signatureResult || abortController.signal.aborted) {\n          break\n        }\n\n        blockHeight = await connection.getBlockHeight('confirmed')\n      }\n\n      abortController.abort()\n\n      return signatureResult\n    } catch (error) {\n      if (abortController.signal.aborted) {\n        return Promise.reject(new Error('Confirmation aborted.'))\n      }\n      throw error\n    }\n  })\n\n  const signatureResult = await Promise.any(confirmPromises).catch(() => null)\n\n  for (const abortController of abortControllers) {\n    abortController.abort()\n  }\n\n  return { signatureResult, txSignature }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3253, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3259, "column": 0}, "map": {"version":3,"file":"parseSolanaErrors.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/core/Solana/parseSolanaErrors.ts"],"sourcesContent":["import type { LiFiStep, Process } from '@lifi/types'\nimport { SDKError } from '../../errors/SDKError.js'\nimport { BaseError } from '../../errors/baseError.js'\nimport { ErrorMessage, LiFiErrorCode } from '../../errors/constants.js'\nimport { TransactionError, UnknownError } from '../../errors/errors.js'\n\nexport const parseSolanaErrors = async (\n  e: Error,\n  step?: LiFiStep,\n  process?: Process\n): Promise<SDKError> => {\n  if (e instanceof SDKError) {\n    e.step = e.step ?? step\n    e.process = e.process ?? process\n    return e\n  }\n\n  const baseError = handleSpecificErrors(e)\n\n  return new SDKError(baseError, step, process)\n}\n\nconst handleSpecificErrors = (e: any) => {\n  if (e.name === 'WalletSignTransactionError') {\n    return new TransactionError(LiFiErrorCode.SignatureRejected, e.message, e)\n  }\n\n  if (e.name === 'SendTransactionError') {\n    return new TransactionError(LiFiErrorCode.TransactionFailed, e.message, e)\n  }\n\n  if (e.name === 'TransactionExpiredBlockheightExceededError') {\n    return new TransactionError(LiFiErrorCode.TransactionExpired, e.message, e)\n  }\n\n  if (e.message?.includes('simulate')) {\n    return new TransactionError(\n      LiFiErrorCode.TransactionSimulationFailed,\n      e.message,\n      e\n    )\n  }\n\n  if (e instanceof BaseError) {\n    return e\n  }\n\n  return new UnknownError(e.message || ErrorMessage.UnknownError, e)\n}\n"],"names":[],"mappings":";;;AACA,OAAO,EAAE,QAAQ,EAAE,MAAM,0BAA0B,CAAA;AAGnD,OAAO,EAAE,gBAAgB,EAAE,YAAY,EAAE,MAAM,wBAAwB,CAAA;AADvE,OAAO,EAAE,YAAY,EAAE,aAAa,EAAE,MAAM,2BAA2B,CAAA;AADvE,OAAO,EAAE,SAAS,EAAE,MAAM,2BAA2B,CAAA;;;;;AAI9C,MAAM,iBAAiB,GAAG,KAAK,EACpC,CAAQ,EACR,IAAe,EACf,OAAiB,EACE,EAAE;IACrB,IAAI,CAAC,+KAAY,WAAQ,EAAE,CAAC;QAC1B,CAAC,CAAC,IAAI,GAAG,CAAC,CAAC,IAAI,IAAI,IAAI,CAAA;QACvB,CAAC,CAAC,OAAO,GAAG,CAAC,CAAC,OAAO,IAAI,OAAO,CAAA;QAChC,OAAO,CAAC,CAAA;IACV,CAAC;IAED,MAAM,SAAS,GAAG,oBAAoB,CAAC,CAAC,CAAC,CAAA;IAEzC,OAAO,uKAAI,WAAQ,CAAC,SAAS,EAAE,IAAI,EAAE,OAAO,CAAC,CAAA;AAC/C,CAAC,CAAA;AAED,MAAM,oBAAoB,GAAG,CAAC,CAAM,EAAE,EAAE;IACtC,IAAI,CAAC,CAAC,IAAI,KAAK,4BAA4B,EAAE,CAAC;QAC5C,OAAO,qKAAI,mBAAgB,qKAAC,gBAAa,CAAC,iBAAiB,EAAE,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC,CAAA;IAC5E,CAAC;IAED,IAAI,CAAC,CAAC,IAAI,KAAK,sBAAsB,EAAE,CAAC;QACtC,OAAO,qKAAI,mBAAgB,qKAAC,gBAAa,CAAC,iBAAiB,EAAE,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC,CAAA;IAC5E,CAAC;IAED,IAAI,CAAC,CAAC,IAAI,KAAK,4CAA4C,EAAE,CAAC;QAC5D,OAAO,qKAAI,mBAAgB,qKAAC,gBAAa,CAAC,kBAAkB,EAAE,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC,CAAA;IAC7E,CAAC;IAED,IAAI,CAAC,CAAC,OAAO,EAAE,QAAQ,CAAC,UAAU,CAAC,EAAE,CAAC;QACpC,OAAO,qKAAI,mBAAgB,qKACzB,gBAAa,CAAC,2BAA2B,EACzC,CAAC,CAAC,OAAO,EACT,CAAC,CACF,CAAA;IACH,CAAC;IAED,IAAI,CAAC,gLAAY,YAAS,EAAE,CAAC;QAC3B,OAAO,CAAC,CAAA;IACV,CAAC;IAED,OAAO,qKAAI,eAAY,CAAC,CAAC,CAAC,OAAO,wKAAI,eAAY,CAAC,YAAY,EAAE,CAAC,CAAC,CAAA;AACpE,CAAC,CAAA","ignoreList":[0]}},
    {"offset": {"line": 3297, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3303, "column": 0}, "map": {"version":3,"file":"SolanaStepExecutor.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/core/Solana/SolanaStepExecutor.ts"],"sourcesContent":["import type { ExtendedTransactionInfo, FullStatusData } from '@lifi/types'\nimport type { SignerWalletAdapter } from '@solana/wallet-adapter-base'\nimport { VersionedTransaction } from '@solana/web3.js'\nimport { withTimeout } from 'viem'\nimport { config } from '../../config.js'\nimport { LiFiErrorCode } from '../../errors/constants.js'\nimport { TransactionError } from '../../errors/errors.js'\nimport { getStepTransaction } from '../../services/api.js'\nimport { base64ToUint8Array } from '../../utils/base64ToUint8Array.js'\nimport { getTransactionFailedMessage } from '../../utils/getTransactionMessage.js'\nimport { BaseStepExecutor } from '../BaseStepExecutor.js'\nimport { checkBalance } from '../checkBalance.js'\nimport { getSubstatusMessage } from '../processMessages.js'\nimport { stepComparison } from '../stepComparison.js'\nimport type {\n  LiFiStepExtended,\n  StepExecutorOptions,\n  TransactionParameters,\n} from '../types.js'\nimport { waitForReceivingTransaction } from '../waitForReceivingTransaction.js'\nimport { callSolanaWithRetry } from './connection.js'\nimport { parseSolanaErrors } from './parseSolanaErrors.js'\nimport { sendAndConfirmTransaction } from './sendAndConfirmTransaction.js'\n\nexport interface SolanaStepExecutorOptions extends StepExecutorOptions {\n  walletAdapter: SignerWalletAdapter\n}\n\nexport class SolanaStepExecutor extends BaseStepExecutor {\n  private walletAdapter: SignerWalletAdapter\n\n  constructor(options: SolanaStepExecutorOptions) {\n    super(options)\n    this.walletAdapter = options.walletAdapter\n  }\n\n  checkWalletAdapter = (step: LiFiStepExtended) => {\n    // Prevent execution of the quote by wallet different from the one which requested the quote\n    if (this.walletAdapter.publicKey!.toString() !== step.action.fromAddress) {\n      throw new TransactionError(\n        LiFiErrorCode.WalletChangedDuringExecution,\n        'The wallet address that requested the quote does not match the wallet address attempting to sign the transaction.'\n      )\n    }\n  }\n\n  executeStep = async (step: LiFiStepExtended): Promise<LiFiStepExtended> => {\n    step.execution = this.statusManager.initExecutionObject(step)\n\n    const fromChain = await config.getChainById(step.action.fromChainId)\n    const toChain = await config.getChainById(step.action.toChainId)\n\n    const isBridgeExecution = fromChain.id !== toChain.id\n    const currentProcessType = isBridgeExecution ? 'CROSS_CHAIN' : 'SWAP'\n\n    // STEP 2: Get transaction\n    let process = this.statusManager.findOrCreateProcess({\n      step,\n      type: currentProcessType,\n    })\n\n    if (process.status !== 'DONE') {\n      try {\n        process = this.statusManager.updateProcess(\n          step,\n          process.type,\n          'STARTED'\n        )\n\n        // Check balance\n        await checkBalance(this.walletAdapter.publicKey!.toString(), step)\n\n        // Create new transaction\n        if (!step.transactionRequest) {\n          const { execution, ...stepBase } = step\n          const updatedStep = await getStepTransaction(stepBase)\n          const comparedStep = await stepComparison(\n            this.statusManager,\n            step,\n            updatedStep,\n            this.allowUserInteraction,\n            this.executionOptions\n          )\n          Object.assign(step, {\n            ...comparedStep,\n            execution: step.execution,\n          })\n        }\n\n        if (!step.transactionRequest?.data) {\n          throw new TransactionError(\n            LiFiErrorCode.TransactionUnprepared,\n            'Unable to prepare transaction.'\n          )\n        }\n\n        process = this.statusManager.updateProcess(\n          step,\n          process.type,\n          'ACTION_REQUIRED'\n        )\n\n        if (!this.allowUserInteraction) {\n          return step\n        }\n\n        let transactionRequest: TransactionParameters = {\n          data: step.transactionRequest.data,\n        }\n\n        if (this.executionOptions?.updateTransactionRequestHook) {\n          const customizedTransactionRequest: TransactionParameters =\n            await this.executionOptions.updateTransactionRequestHook({\n              requestType: 'transaction',\n              ...transactionRequest,\n            })\n\n          transactionRequest = {\n            ...transactionRequest,\n            ...customizedTransactionRequest,\n          }\n        }\n\n        if (!transactionRequest.data) {\n          throw new TransactionError(\n            LiFiErrorCode.TransactionUnprepared,\n            'Unable to prepare transaction.'\n          )\n        }\n\n        const versionedTransaction = VersionedTransaction.deserialize(\n          base64ToUint8Array(transactionRequest.data)\n        )\n\n        this.checkWalletAdapter(step)\n\n        // We give users 2 minutes to sign the transaction or it should be considered expired\n        const signedTx = await withTimeout<VersionedTransaction>(\n          () => this.walletAdapter.signTransaction(versionedTransaction),\n          {\n            // https://solana.com/docs/advanced/confirmation#transaction-expiration\n            // Use 2 minutes to account for fluctuations\n            timeout: 120_000,\n            errorInstance: new TransactionError(\n              LiFiErrorCode.TransactionExpired,\n              'Transaction has expired: blockhash is no longer recent enough.'\n            ),\n          }\n        )\n\n        process = this.statusManager.updateProcess(\n          step,\n          process.type,\n          'PENDING'\n        )\n\n        const simulationResult = await callSolanaWithRetry((connection) =>\n          connection.simulateTransaction(signedTx, {\n            commitment: 'confirmed',\n            replaceRecentBlockhash: true,\n          })\n        )\n\n        if (simulationResult.value.err) {\n          throw new TransactionError(\n            LiFiErrorCode.TransactionSimulationFailed,\n            'Transaction simulation failed'\n          )\n        }\n\n        const confirmedTx = await sendAndConfirmTransaction(signedTx)\n\n        if (!confirmedTx.signatureResult) {\n          throw new TransactionError(\n            LiFiErrorCode.TransactionExpired,\n            'Transaction has expired: The block height has exceeded the maximum allowed limit.'\n          )\n        }\n\n        if (confirmedTx.signatureResult.err) {\n          const reason =\n            typeof confirmedTx.signatureResult.err === 'object'\n              ? JSON.stringify(confirmedTx.signatureResult.err)\n              : confirmedTx.signatureResult.err\n          throw new TransactionError(\n            LiFiErrorCode.TransactionFailed,\n            `Transaction failed: ${reason}`\n          )\n        }\n\n        // Transaction has been confirmed and we can update the process\n        process = this.statusManager.updateProcess(\n          step,\n          process.type,\n          'PENDING',\n          {\n            txHash: confirmedTx.txSignature,\n            txLink: `${fromChain.metamask.blockExplorerUrls[0]}tx/${confirmedTx.txSignature}`,\n          }\n        )\n\n        if (isBridgeExecution) {\n          process = this.statusManager.updateProcess(step, process.type, 'DONE')\n        }\n      } catch (e: any) {\n        const error = await parseSolanaErrors(e, step, process)\n        process = this.statusManager.updateProcess(\n          step,\n          process.type,\n          'FAILED',\n          {\n            error: {\n              message: error.cause.message,\n              code: error.code,\n            },\n          }\n        )\n        this.statusManager.updateExecution(step, 'FAILED')\n        throw error\n      }\n    }\n\n    // STEP 5: Wait for the receiving chain\n    const processTxHash = process.txHash\n    if (isBridgeExecution) {\n      process = this.statusManager.findOrCreateProcess({\n        step,\n        type: 'RECEIVING_CHAIN',\n        status: 'PENDING',\n        chainId: toChain.id,\n      })\n    }\n    let statusResponse: FullStatusData\n    try {\n      if (!processTxHash) {\n        throw new Error('Transaction hash is undefined.')\n      }\n      statusResponse = (await waitForReceivingTransaction(\n        processTxHash,\n        this.statusManager,\n        process.type,\n        step\n      )) as FullStatusData\n\n      const statusReceiving =\n        statusResponse.receiving as ExtendedTransactionInfo\n\n      process = this.statusManager.updateProcess(step, process.type, 'DONE', {\n        substatus: statusResponse.substatus,\n        substatusMessage:\n          statusResponse.substatusMessage ||\n          getSubstatusMessage(statusResponse.status, statusResponse.substatus),\n        txHash: statusReceiving?.txHash,\n        txLink: `${toChain.metamask.blockExplorerUrls[0]}tx/${statusReceiving?.txHash}`,\n      })\n\n      this.statusManager.updateExecution(step, 'DONE', {\n        fromAmount: statusResponse.sending.amount,\n        toAmount: statusReceiving?.amount,\n        toToken: statusReceiving?.token,\n        gasCosts: [\n          {\n            amount: statusResponse.sending.gasAmount,\n            amountUSD: statusResponse.sending.gasAmountUSD,\n            token: statusResponse.sending.gasToken,\n            estimate: statusResponse.sending.gasUsed,\n            limit: statusResponse.sending.gasUsed,\n            price: statusResponse.sending.gasPrice,\n            type: 'SEND',\n          },\n        ],\n      })\n    } catch (e: unknown) {\n      const htmlMessage = await getTransactionFailedMessage(\n        step,\n        process.txLink\n      )\n\n      process = this.statusManager.updateProcess(step, process.type, 'FAILED', {\n        error: {\n          code: LiFiErrorCode.TransactionFailed,\n          message: 'Failed while waiting for receiving chain.',\n          htmlMessage,\n        },\n      })\n      this.statusManager.updateExecution(step, 'FAILED')\n      console.warn(e)\n      throw e\n    }\n\n    // DONE\n    return step\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3515, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3521, "column": 0}, "map": {"version":3,"file":"Solana.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/core/Solana/Solana.ts"],"sourcesContent":["import { ChainType } from '@lifi/types'\nimport type { StepExecutorOptions } from '../types.js'\nimport { SolanaStepExecutor } from './SolanaStepExecutor.js'\nimport { getSNSAddress } from './getSNSAddress.js'\nimport { getSolanaBalance } from './getSolanaBalance.js'\nimport { isSVMAddress } from './isSVMAddress.js'\nimport type { SolanaProvider, SolanaProviderOptions } from './types.js'\n\nexport function Solana(options?: SolanaProviderOptions): SolanaProvider {\n  const _options: SolanaProviderOptions = options ?? {}\n  return {\n    get type() {\n      return ChainType.SVM\n    },\n    isAddress: isSVMAddress,\n    resolveAddress: getSNSAddress,\n    getBalance: getSolanaBalance,\n    async getStepExecutor(\n      options: StepExecutorOptions\n    ): Promise<SolanaStepExecutor> {\n      if (!_options.getWalletAdapter) {\n        throw new Error('getWalletAdapter is not provided.')\n      }\n\n      const walletAdapter = await _options.getWalletAdapter()\n\n      const executor = new SolanaStepExecutor({\n        walletAdapter,\n        routeId: options.routeId,\n        executionOptions: {\n          ...options.executionOptions,\n        },\n      })\n\n      return executor\n    },\n    setOptions(options: SolanaProviderOptions) {\n      Object.assign(_options, options)\n    },\n  }\n}\n"],"names":[],"mappings":";;;AAAA,OAAO,EAAE,SAAS,EAAE,MAAM,aAAa,CAAA;AAKvC,OAAO,EAAE,YAAY,EAAE,MAAM,mBAAmB,CAAA;AAFhD,OAAO,EAAE,aAAa,EAAE,MAAM,oBAAoB,CAAA;AAClD,OAAO,EAAE,gBAAgB,EAAE,MAAM,uBAAuB,CAAA;AAFxD,OAAO,EAAE,kBAAkB,EAAE,MAAM,yBAAyB,CAAA;;;;;;AAMtD,SAAU,MAAM,CAAC,OAA+B;IACpD,MAAM,QAAQ,GAA0B,OAAO,IAAI,CAAA,CAAE,CAAA;IACrD,OAAO;QACL,IAAI,IAAI,IAAA;YACN,yKAAO,YAAS,CAAC,GAAG,CAAA;QACtB,CAAC;QACD,SAAS,iLAAE,eAAY;QACvB,cAAc,kLAAE,gBAAa;QAC7B,UAAU,qLAAE,mBAAgB;QAC5B,KAAK,CAAC,eAAe,EACnB,OAA4B;YAE5B,IAAI,CAAC,QAAQ,CAAC,gBAAgB,EAAE,CAAC;gBAC/B,MAAM,IAAI,KAAK,CAAC,mCAAmC,CAAC,CAAA;YACtD,CAAC;YAED,MAAM,aAAa,GAAG,MAAM,QAAQ,CAAC,gBAAgB,EAAE,CAAA;YAEvD,MAAM,QAAQ,GAAG,yLAAI,qBAAkB,CAAC;gBACtC,aAAa;gBACb,OAAO,EAAE,OAAO,CAAC,OAAO;gBACxB,gBAAgB,EAAE;oBAChB,GAAG,OAAO,CAAC,gBAAgB;iBAC5B;aACF,CAAC,CAAA;YAEF,OAAO,QAAQ,CAAA;QACjB,CAAC;QACD,UAAU,EAAC,OAA8B;YACvC,MAAM,CAAC,MAAM,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAA;QAClC,CAAC;KACF,CAAA;AACH,CAAC","ignoreList":[0]}},
    {"offset": {"line": 3562, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3568, "column": 0}, "map": {"version":3,"file":"getUTXOAPIPublicClient.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/core/UTXO/getUTXOAPIPublicClient.ts"],"sourcesContent":["import { UTXOAPIActions } from '@bigmi/core'\nimport type { UTXOAPISchema } from '@bigmi/core'\nimport { utxo } from '@bigmi/core'\nimport {\n  type Chain,\n  type Client,\n  type FallbackTransport,\n  type HttpTransport,\n  createClient,\n  fallback,\n  rpcSchema,\n} from 'viem'\nimport { config } from '../../config.js'\n\n// cached providers\nconst publicAPIClients: Record<\n  number,\n  Client<\n    FallbackTransport<readonly HttpTransport[]>,\n    Chain,\n    undefined,\n    UTXOAPISchema,\n    UTXOAPIActions\n  >\n> = {}\n\n/**\n * Get an instance of a provider for a specific chain\n * @param chainId - Id of the chain the provider is for\n * @returns The public client for the given chain\n */\nexport const getUTXOAPIPublicClient = async (chainId: number) => {\n  if (!publicAPIClients[chainId]) {\n    const _chain = await config.getChainById(chainId)\n    const chain: Chain = {\n      ..._chain,\n      ..._chain.metamask,\n      name: _chain.metamask.chainName,\n      rpcUrls: {\n        default: { http: _chain.metamask.rpcUrls },\n        public: { http: _chain.metamask.rpcUrls },\n      },\n    }\n    const client = createClient({\n      chain,\n      rpcSchema: rpcSchema<UTXOAPISchema>(),\n      transport: fallback([\n        utxo('https://api.blockchair.com', {\n          key: 'blockchair',\n          includeChainToURL: true,\n        }),\n        utxo('https://rpc.ankr.com/http/btc_blockbook/api/v2', {\n          key: 'ankr',\n        }),\n        utxo('https://api.blockcypher.com/v1/btc/main', {\n          key: 'blockcypher',\n        }),\n        utxo('https://mempool.space/api', {\n          key: 'mempool',\n        }),\n      ]),\n    }).extend(UTXOAPIActions)\n    publicAPIClients[chainId] = client\n  }\n\n  if (!publicAPIClients[chainId]) {\n    throw new Error(`Unable to configure provider for chain ${chainId}`)\n  }\n\n  return publicAPIClients[chainId]\n}\n"],"names":[],"mappings":";;;AAYA,OAAO,EAAE,MAAM,EAAE,MAAM,iBAAiB,CAAA;AATxC,OAAO,EAKL,YAAY,EACZ,QAAQ,EACR,SAAS,GACV,MAAM,MAAM,CAAA;;AATb,OAAO,EAAE,IAAI,EAAE,MAAM,aAAa,CAAA;AAFlC,OAAO,EAAE,cAAc,EAAE,MAAM,aAAa,CAAA;;;;;AAc5C,mBAAmB;AACnB,MAAM,gBAAgB,GASlB,CAAA,CAAE,CAAA;AAOC,MAAM,sBAAsB,GAAG,KAAK,EAAE,OAAe,EAAE,EAAE;IAC9D,IAAI,CAAC,gBAAgB,CAAC,OAAO,CAAC,EAAE,CAAC;QAC/B,MAAM,MAAM,GAAG,6JAAM,SAAM,CAAC,YAAY,CAAC,OAAO,CAAC,CAAA;QACjD,MAAM,KAAK,GAAU;YACnB,GAAG,MAAM;YACT,GAAG,MAAM,CAAC,QAAQ;YAClB,IAAI,EAAE,MAAM,CAAC,QAAQ,CAAC,SAAS;YAC/B,OAAO,EAAE;gBACP,OAAO,EAAE;oBAAE,IAAI,EAAE,MAAM,CAAC,QAAQ,CAAC,OAAO;gBAAA,CAAE;gBAC1C,MAAM,EAAE;oBAAE,IAAI,EAAE,MAAM,CAAC,QAAQ,CAAC,OAAO;gBAAA,CAAE;aAC1C;SACF,CAAA;QACD,MAAM,MAAM,IAAG,0KAAA,AAAY,EAAC;YAC1B,KAAK;YACL,SAAS,8JAAE,YAAA,AAAS,EAAiB;YACrC,SAAS,wKAAE,WAAA,AAAQ,EAAC;iBAClB,+KAAA,AAAI,EAAC,4BAA4B,EAAE;oBACjC,GAAG,EAAE,YAAY;oBACjB,iBAAiB,EAAE,IAAI;iBACxB,CAAC;yLACF,OAAI,AAAJ,EAAK,gDAAgD,EAAE;oBACrD,GAAG,EAAE,MAAM;iBACZ,CAAC;yLACF,OAAA,AAAI,EAAC,yCAAyC,EAAE;oBAC9C,GAAG,EAAE,aAAa;iBACnB,CAAC;yLACF,OAAA,AAAI,EAAC,2BAA2B,EAAE;oBAChC,GAAG,EAAE,SAAS;iBACf,CAAC;aACH,CAAC;SACH,CAAC,CAAC,MAAM,gLAAC,iBAAc,CAAC,CAAA;QACzB,gBAAgB,CAAC,OAAO,CAAC,GAAG,MAAM,CAAA;IACpC,CAAC;IAED,IAAI,CAAC,gBAAgB,CAAC,OAAO,CAAC,EAAE,CAAC;QAC/B,MAAM,IAAI,KAAK,CAAC,CAAA,uCAAA,EAA0C,OAAO,EAAE,CAAC,CAAA;IACtE,CAAC;IAED,OAAO,gBAAgB,CAAC,OAAO,CAAC,CAAA;AAClC,CAAC,CAAA","ignoreList":[0]}},
    {"offset": {"line": 3624, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3630, "column": 0}, "map": {"version":3,"file":"getUTXOPublicClient.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/core/UTXO/getUTXOPublicClient.ts"],"sourcesContent":["import { UTXOActions } from '@bigmi/core'\nimport type { UTXOSchema } from '@bigmi/core'\nimport {\n  http,\n  type Chain,\n  type Client,\n  type FallbackTransport,\n  type HttpTransport,\n  createClient,\n  fallback,\n  rpcSchema,\n} from 'viem'\nimport { config } from '../../config.js'\nimport { getRpcUrls } from '../rpc.js'\n\n// cached providers\nconst publicClients: Record<\n  number,\n  Client<\n    FallbackTransport<readonly HttpTransport[]>,\n    Chain,\n    undefined,\n    UTXOSchema,\n    UTXOActions\n  >\n> = {}\n\n/**\n * Get an instance of a provider for a specific chain\n * @param chainId - Id of the chain the provider is for\n * @returns The public client for the given chain\n */\nexport const getUTXOPublicClient = async (chainId: number) => {\n  if (!publicClients[chainId]) {\n    const urls = await getRpcUrls(chainId)\n    const fallbackTransports = urls.map((url) => http(url))\n    const _chain = await config.getChainById(chainId)\n    const chain: Chain = {\n      ..._chain,\n      ..._chain.metamask,\n      name: _chain.metamask.chainName,\n      rpcUrls: {\n        default: { http: _chain.metamask.rpcUrls },\n        public: { http: _chain.metamask.rpcUrls },\n      },\n    }\n    const client = createClient({\n      chain,\n      rpcSchema: rpcSchema<UTXOSchema>(),\n      transport: fallback(fallbackTransports),\n      pollingInterval: 10_000,\n    }).extend(UTXOActions)\n    publicClients[chainId] = client\n  }\n\n  if (!publicClients[chainId]) {\n    throw new Error(`Unable to configure provider for chain ${chainId}`)\n  }\n\n  return publicClients[chainId]\n}\n"],"names":[],"mappings":";;;AAaA,OAAO,EAAE,UAAU,EAAE,MAAM,WAAW,CAAA;AAXtC,OAAO,EACL,IAAI,EAKJ,YAAY,EACZ,QAAQ,EACR,SAAS,GACV,MAAM,MAAM,CAAA;AACb,OAAO,EAAE,MAAM,EAAE,MAAM,iBAAiB,CAAA;;;AAZxC,OAAO,EAAE,WAAW,EAAE,MAAM,aAAa,CAAA;;;;;AAezC,mBAAmB;AACnB,MAAM,aAAa,GASf,CAAA,CAAE,CAAA;AAOC,MAAM,mBAAmB,GAAG,KAAK,EAAE,OAAe,EAAE,EAAE;IAC3D,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,EAAE,CAAC;QAC5B,MAAM,IAAI,GAAG,UAAM,yKAAA,AAAU,EAAC,OAAO,CAAC,CAAA;QACtC,MAAM,kBAAkB,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,EAAE,iKAAC,OAAA,AAAI,EAAC,GAAG,CAAC,CAAC,CAAA;QACvD,MAAM,MAAM,GAAG,6JAAM,SAAM,CAAC,YAAY,CAAC,OAAO,CAAC,CAAA;QACjD,MAAM,KAAK,GAAU;YACnB,GAAG,MAAM;YACT,GAAG,MAAM,CAAC,QAAQ;YAClB,IAAI,EAAE,MAAM,CAAC,QAAQ,CAAC,SAAS;YAC/B,OAAO,EAAE;gBACP,OAAO,EAAE;oBAAE,IAAI,EAAE,MAAM,CAAC,QAAQ,CAAC,OAAO;gBAAA,CAAE;gBAC1C,MAAM,EAAE;oBAAE,IAAI,EAAE,MAAM,CAAC,QAAQ,CAAC,OAAO;gBAAA,CAAE;aAC1C;SACF,CAAA;QACD,MAAM,MAAM,+JAAG,eAAA,AAAY,EAAC;YAC1B,KAAK;YACL,SAAS,EAAE,wKAAA,AAAS,EAAc;YAClC,SAAS,wKAAE,WAAA,AAAQ,EAAC,kBAAkB,CAAC;YACvC,eAAe,EAAE,MAAM;SACxB,CAAC,CAAC,MAAM,CAAC,0LAAW,CAAC,CAAA;QACtB,aAAa,CAAC,OAAO,CAAC,GAAG,MAAM,CAAA;IACjC,CAAC;IAED,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,EAAE,CAAC;QAC5B,MAAM,IAAI,KAAK,CAAC,CAAA,uCAAA,EAA0C,OAAO,EAAE,CAAC,CAAA;IACtE,CAAC;IAED,OAAO,aAAa,CAAC,OAAO,CAAC,CAAA;AAC/B,CAAC,CAAA","ignoreList":[0]}},
    {"offset": {"line": 3676, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3682, "column": 0}, "map": {"version":3,"file":"getUTXOBalance.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/core/UTXO/getUTXOBalance.ts"],"sourcesContent":["import { ChainId, type Token, type TokenAmount } from '@lifi/types'\nimport { getUTXOAPIPublicClient } from './getUTXOAPIPublicClient.js'\nimport { getUTXOPublicClient } from './getUTXOPublicClient.js'\n\nexport const getUTXOBalance = async (\n  walletAddress: string,\n  tokens: Token[]\n): Promise<TokenAmount[]> => {\n  if (tokens.length === 0) {\n    return []\n  }\n  const { chainId } = tokens[0]\n  for (const token of tokens) {\n    if (token.chainId !== chainId) {\n      console.warn('Requested tokens have to be on the same chain.')\n    }\n  }\n  const apiClient = await getUTXOAPIPublicClient(ChainId.BTC)\n  const client = await getUTXOPublicClient(ChainId.BTC)\n  const [balance, blockCount] = await Promise.all([\n    apiClient.getBalance({ address: walletAddress }),\n    client.getBlockCount(),\n  ])\n\n  return tokens.map((token) => ({\n    ...token,\n    amount: balance,\n    blockNumber: BigInt(blockCount),\n  }))\n}\n"],"names":[],"mappings":";;;AACA,OAAO,EAAE,sBAAsB,EAAE,MAAM,6BAA6B,CAAA;AADpE,OAAO,EAAE,OAAO,EAAgC,MAAM,aAAa,CAAA;AAEnE,OAAO,EAAE,mBAAmB,EAAE,MAAM,0BAA0B,CAAA;;;;AAEvD,MAAM,cAAc,GAAG,KAAK,EACjC,aAAqB,EACrB,MAAe,EACS,EAAE;IAC1B,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;QACxB,OAAO,EAAE,CAAA;IACX,CAAC;IACD,MAAM,EAAE,OAAO,EAAE,GAAG,MAAM,CAAC,CAAC,CAAC,CAAA;IAC7B,KAAK,MAAM,KAAK,IAAI,MAAM,CAAE,CAAC;QAC3B,IAAI,KAAK,CAAC,OAAO,KAAK,OAAO,EAAE,CAAC;YAC9B,OAAO,CAAC,IAAI,CAAC,gDAAgD,CAAC,CAAA;QAChE,CAAC;IACH,CAAC;IACD,MAAM,SAAS,GAAG,iMAAM,yBAAsB,AAAtB,mKAAuB,UAAO,CAAC,GAAG,CAAC,CAAA;IAC3D,MAAM,MAAM,GAAG,8LAAM,sBAAA,AAAmB,mKAAC,UAAO,CAAC,GAAG,CAAC,CAAA;IACrD,MAAM,CAAC,OAAO,EAAE,UAAU,CAAC,GAAG,MAAM,OAAO,CAAC,GAAG,CAAC;QAC9C,SAAS,CAAC,UAAU,CAAC;YAAE,OAAO,EAAE,aAAa;QAAA,CAAE,CAAC;QAChD,MAAM,CAAC,aAAa,EAAE;KACvB,CAAC,CAAA;IAEF,OAAO,MAAM,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE,CAAG,CAAD,AAAE;YAC5B,GAAG,KAAK;YACR,MAAM,EAAE,OAAO;YACf,WAAW,EAAE,MAAM,CAAC,UAAU,CAAC;SAChC,CAAC,CAAC,CAAA;AACL,CAAC,CAAA","ignoreList":[0]}},
    {"offset": {"line": 3715, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3721, "column": 0}, "map": {"version":3,"file":"parseUTXOErrors.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/core/UTXO/parseUTXOErrors.ts"],"sourcesContent":["import type { LiFiStep, Process } from '@lifi/types'\nimport { SDKError } from '../../errors/SDKError.js'\nimport { BaseError } from '../../errors/baseError.js'\nimport { ErrorMessage, LiFiErrorCode } from '../../errors/constants.js'\nimport { TransactionError, UnknownError } from '../../errors/errors.js'\n\nexport const parseUTXOErrors = async (\n  e: Error,\n  step?: LiFiStep,\n  process?: Process\n): Promise<SDKError> => {\n  if (e instanceof SDKError) {\n    e.step = e.step ?? step\n    e.process = e.process ?? process\n    return e\n  }\n\n  const baseError = handleSpecificErrors(e)\n\n  return new SDKError(baseError, step, process)\n}\n\nconst handleSpecificErrors = (e: any) => {\n  // txn-mempool-conflict\n  if (\n    e.details?.includes?.('conflict') ||\n    e.cause?.message?.includes?.('conflict')\n  ) {\n    return new TransactionError(\n      LiFiErrorCode.TransactionConflict,\n      'Your transaction conflicts with another transaction already in the mempool. One or more inputs have been spent by another transaction.',\n      e\n    )\n  }\n  if (e.code === 4001 || e.code === -32000 || e.cause?.includes?.('rejected')) {\n    return new TransactionError(LiFiErrorCode.SignatureRejected, e.message, e)\n  }\n  if (e.code === -5 || e.code === -32700 || e.code === -32064) {\n    return new TransactionError(LiFiErrorCode.NotFound, e.message, e)\n  }\n\n  if (e instanceof BaseError) {\n    return e\n  }\n\n  return new UnknownError(e.message || ErrorMessage.UnknownError, e)\n}\n"],"names":[],"mappings":";;;AACA,OAAO,EAAE,QAAQ,EAAE,MAAM,0BAA0B,CAAA;AACnD,OAAO,EAAE,SAAS,EAAE,MAAM,2BAA2B,CAAA;AAErD,OAAO,EAAE,gBAAgB,EAAE,YAAY,EAAE,MAAM,wBAAwB,CAAA;AADvE,OAAO,EAAE,YAAY,EAAE,aAAa,EAAE,MAAM,2BAA2B,CAAA;;;;;AAGhE,MAAM,eAAe,GAAG,KAAK,EAClC,CAAQ,EACR,IAAe,EACf,OAAiB,EACE,EAAE;IACrB,IAAI,CAAC,+KAAY,WAAQ,EAAE,CAAC;QAC1B,CAAC,CAAC,IAAI,GAAG,CAAC,CAAC,IAAI,IAAI,IAAI,CAAA;QACvB,CAAC,CAAC,OAAO,GAAG,CAAC,CAAC,OAAO,IAAI,OAAO,CAAA;QAChC,OAAO,CAAC,CAAA;IACV,CAAC;IAED,MAAM,SAAS,GAAG,oBAAoB,CAAC,CAAC,CAAC,CAAA;IAEzC,OAAO,uKAAI,WAAQ,CAAC,SAAS,EAAE,IAAI,EAAE,OAAO,CAAC,CAAA;AAC/C,CAAC,CAAA;AAED,MAAM,oBAAoB,GAAG,CAAC,CAAM,EAAE,EAAE;IACtC,uBAAuB;IACvB,IACE,CAAC,CAAC,OAAO,EAAE,QAAQ,EAAE,CAAC,UAAU,CAAC,IACjC,CAAC,CAAC,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,CAAC,UAAU,CAAC,EACxC,CAAC;QACD,OAAO,qKAAI,mBAAgB,oKACzB,iBAAa,CAAC,mBAAmB,EACjC,wIAAwI,EACxI,CAAC,CACF,CAAA;IACH,CAAC;IACD,IAAI,CAAC,CAAC,IAAI,KAAK,IAAI,IAAI,CAAC,CAAC,IAAI,KAAK,CAAC,KAAK,IAAI,CAAC,CAAC,KAAK,EAAE,QAAQ,EAAE,CAAC,UAAU,CAAC,EAAE,CAAC;QAC5E,OAAO,qKAAI,mBAAgB,qKAAC,gBAAa,CAAC,iBAAiB,EAAE,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC,CAAA;IAC5E,CAAC;IACD,IAAI,CAAC,CAAC,IAAI,KAAK,CAAC,CAAC,IAAI,CAAC,CAAC,IAAI,KAAK,CAAC,KAAK,IAAI,CAAC,CAAC,IAAI,KAAK,CAAC,KAAK,EAAE,CAAC;QAC5D,OAAO,qKAAI,mBAAgB,qKAAC,gBAAa,CAAC,QAAQ,EAAE,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC,CAAA;IACnE,CAAC;IAED,IAAI,CAAC,gLAAY,YAAS,EAAE,CAAC;QAC3B,OAAO,CAAC,CAAA;IACV,CAAC;IAED,OAAO,qKAAI,eAAY,CAAC,CAAC,CAAC,OAAO,wKAAI,eAAY,CAAC,YAAY,EAAE,CAAC,CAAC,CAAA;AACpE,CAAC,CAAA","ignoreList":[0]}},
    {"offset": {"line": 3757, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3763, "column": 0}, "map": {"version":3,"file":"UTXOStepExecutor.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/core/UTXO/UTXOStepExecutor.ts"],"sourcesContent":["import { signPsbt, waitForTransaction } from '@bigmi/core'\nimport type { ReplacementReason } from '@bigmi/core'\nimport {\n  ChainId,\n  type ExtendedTransactionInfo,\n  type FullStatusData,\n} from '@lifi/types'\nimport { Psbt, address, networks } from 'bitcoinjs-lib'\nimport { type Client, withTimeout } from 'viem'\nimport { config } from '../../config.js'\nimport { LiFiErrorCode } from '../../errors/constants.js'\nimport { TransactionError } from '../../errors/errors.js'\nimport { getStepTransaction } from '../../services/api.js'\nimport { getTransactionFailedMessage } from '../../utils/getTransactionMessage.js'\nimport { BaseStepExecutor } from '../BaseStepExecutor.js'\nimport { checkBalance } from '../checkBalance.js'\nimport { getSubstatusMessage } from '../processMessages.js'\nimport { stepComparison } from '../stepComparison.js'\nimport type {\n  LiFiStepExtended,\n  StepExecutorOptions,\n  TransactionParameters,\n} from '../types.js'\nimport { waitForReceivingTransaction } from '../waitForReceivingTransaction.js'\nimport { getUTXOPublicClient } from './getUTXOPublicClient.js'\nimport { parseUTXOErrors } from './parseUTXOErrors.js'\n\nexport interface UTXOStepExecutorOptions extends StepExecutorOptions {\n  client: Client\n}\n\nexport class UTXOStepExecutor extends BaseStepExecutor {\n  private client: Client\n\n  constructor(options: UTXOStepExecutorOptions) {\n    super(options)\n    this.client = options.client\n  }\n\n  checkClient = (step: LiFiStepExtended) => {\n    // TODO: check chain and possibly implement chain switch?\n    // Prevent execution of the quote by wallet different from the one which requested the quote\n    if (this.client.account?.address !== step.action.fromAddress) {\n      throw new TransactionError(\n        LiFiErrorCode.WalletChangedDuringExecution,\n        'The wallet address that requested the quote does not match the wallet address attempting to sign the transaction.'\n      )\n    }\n  }\n\n  executeStep = async (step: LiFiStepExtended): Promise<LiFiStepExtended> => {\n    step.execution = this.statusManager.initExecutionObject(step)\n\n    const fromChain = await config.getChainById(step.action.fromChainId)\n    const toChain = await config.getChainById(step.action.toChainId)\n\n    const isBridgeExecution = fromChain.id !== toChain.id\n    const currentProcessType = isBridgeExecution ? 'CROSS_CHAIN' : 'SWAP'\n\n    // STEP 2: Get transaction\n    let process = this.statusManager.findOrCreateProcess({\n      step,\n      type: currentProcessType,\n      chainId: fromChain.id,\n    })\n\n    const publicClient = await getUTXOPublicClient(ChainId.BTC)\n\n    if (process.status !== 'DONE') {\n      try {\n        let txHash: string\n        let txHex: string\n        if (process.txHash) {\n          // Make sure that the chain is still correct\n          this.checkClient(step)\n\n          // Wait for exiting transaction\n          txHash = process.txHash\n          txHex = process.txHex\n        } else {\n          process = this.statusManager.updateProcess(\n            step,\n            process.type,\n            'STARTED'\n          )\n\n          // Check balance\n          await checkBalance(this.client.account!.address, step)\n\n          // Create new transaction\n          if (!step.transactionRequest) {\n            const { execution, ...stepBase } = step\n            const updatedStep = await getStepTransaction(stepBase)\n            const comparedStep = await stepComparison(\n              this.statusManager,\n              step,\n              updatedStep,\n              this.allowUserInteraction,\n              this.executionOptions\n            )\n            Object.assign(step, {\n              ...comparedStep,\n              execution: step.execution,\n            })\n          }\n\n          if (!step.transactionRequest?.data) {\n            throw new TransactionError(\n              LiFiErrorCode.TransactionUnprepared,\n              'Unable to prepare transaction.'\n            )\n          }\n\n          process = this.statusManager.updateProcess(\n            step,\n            process.type,\n            'ACTION_REQUIRED'\n          )\n\n          if (!this.allowUserInteraction) {\n            return step\n          }\n\n          let transactionRequest: TransactionParameters = {\n            data: step.transactionRequest.data,\n          }\n\n          if (this.executionOptions?.updateTransactionRequestHook) {\n            const customizedTransactionRequest: TransactionParameters =\n              await this.executionOptions.updateTransactionRequestHook({\n                requestType: 'transaction',\n                ...transactionRequest,\n              })\n\n            transactionRequest = {\n              ...transactionRequest,\n              ...customizedTransactionRequest,\n            }\n          }\n\n          if (!transactionRequest.data) {\n            throw new TransactionError(\n              LiFiErrorCode.TransactionUnprepared,\n              'Unable to prepare transaction.'\n            )\n          }\n\n          this.checkClient(step)\n\n          const psbtHex = transactionRequest.data\n\n          const psbt = Psbt.fromHex(psbtHex, { network: networks.bitcoin })\n\n          const inputsToSign = Array.from(\n            psbt.data.inputs\n              .reduce((map, input, index) => {\n                const accountAddress = input.witnessUtxo\n                  ? address.fromOutputScript(\n                      input.witnessUtxo.script,\n                      networks.bitcoin\n                    )\n                  : (this.client.account?.address as string)\n                if (map.has(accountAddress)) {\n                  map.get(accountAddress).signingIndexes.push(index)\n                } else {\n                  map.set(accountAddress, {\n                    address: accountAddress,\n                    sigHash: 1, // Default to Transaction.SIGHASH_ALL - 1\n                    signingIndexes: [index],\n                  })\n                }\n                return map\n              }, new Map())\n              .values()\n          )\n\n          // We give users 10 minutes to sign the transaction or it should be considered expired\n          const signedPsbtHex = await withTimeout(\n            () =>\n              signPsbt(this.client, {\n                psbt: psbtHex,\n                inputsToSign: inputsToSign,\n                finalize: false,\n              }),\n            {\n              timeout: 600_000,\n              errorInstance: new TransactionError(\n                LiFiErrorCode.TransactionExpired,\n                'Transaction has expired.'\n              ),\n            }\n          )\n\n          const signedPsbt = Psbt.fromHex(signedPsbtHex).finalizeAllInputs()\n\n          txHex = signedPsbt.extractTransaction().toHex()\n\n          txHash = await publicClient.sendUTXOTransaction({\n            hex: txHex,\n          })\n\n          process = this.statusManager.updateProcess(\n            step,\n            process.type,\n            'PENDING',\n            {\n              txHash: txHash,\n              txLink: `${fromChain.metamask.blockExplorerUrls[0]}tx/${txHash}`,\n              txHex,\n            }\n          )\n        }\n\n        let replacementReason: ReplacementReason | undefined\n        const transaction = await waitForTransaction(publicClient, {\n          txId: txHash,\n          txHex,\n          senderAddress: this.client.account?.address,\n          onReplaced: (response) => {\n            replacementReason = response.reason\n            process = this.statusManager.updateProcess(\n              step,\n              process.type,\n              'PENDING',\n              {\n                txHash: response.transaction.txid,\n                txLink: `${fromChain.metamask.blockExplorerUrls[0]}tx/${response.transaction.txid}`,\n              }\n            )\n          },\n        })\n\n        if (replacementReason === 'cancelled') {\n          throw new TransactionError(\n            LiFiErrorCode.TransactionCanceled,\n            'User canceled transaction.'\n          )\n        }\n\n        if (transaction.txid !== txHash) {\n          process = this.statusManager.updateProcess(\n            step,\n            process.type,\n            'PENDING',\n            {\n              txHash: transaction.txid,\n              txLink: `${fromChain.metamask.blockExplorerUrls[0]}tx/${transaction.txid}`,\n            }\n          )\n        }\n\n        if (isBridgeExecution) {\n          process = this.statusManager.updateProcess(step, process.type, 'DONE')\n        }\n      } catch (e: any) {\n        const error = await parseUTXOErrors(e, step, process)\n        process = this.statusManager.updateProcess(\n          step,\n          process.type,\n          'FAILED',\n          {\n            error: {\n              message: error.cause.message,\n              code: error.code,\n            },\n          }\n        )\n        this.statusManager.updateExecution(step, 'FAILED')\n        throw error\n      }\n    }\n\n    // STEP 5: Wait for the receiving chain\n    const processTxHash = process.txHash\n    if (isBridgeExecution) {\n      process = this.statusManager.findOrCreateProcess({\n        step,\n        type: 'RECEIVING_CHAIN',\n        status: 'PENDING',\n        chainId: toChain.id,\n      })\n    }\n    let statusResponse: FullStatusData\n    try {\n      if (!processTxHash) {\n        throw new Error('Transaction hash is undefined.')\n      }\n      statusResponse = (await waitForReceivingTransaction(\n        processTxHash,\n        this.statusManager,\n        process.type,\n        step,\n        10_000\n      )) as FullStatusData\n\n      const statusReceiving =\n        statusResponse.receiving as ExtendedTransactionInfo\n\n      process = this.statusManager.updateProcess(step, process.type, 'DONE', {\n        substatus: statusResponse.substatus,\n        substatusMessage:\n          statusResponse.substatusMessage ||\n          getSubstatusMessage(statusResponse.status, statusResponse.substatus),\n        txHash: statusReceiving?.txHash,\n        txLink: `${toChain.metamask.blockExplorerUrls[0]}tx/${statusReceiving?.txHash}`,\n      })\n\n      this.statusManager.updateExecution(step, 'DONE', {\n        fromAmount: statusResponse.sending.amount,\n        toAmount: statusReceiving?.amount,\n        toToken: statusReceiving?.token,\n        gasCosts: [\n          {\n            amount: statusResponse.sending.gasAmount,\n            amountUSD: statusResponse.sending.gasAmountUSD,\n            token: statusResponse.sending.gasToken,\n            estimate: statusResponse.sending.gasUsed,\n            limit: statusResponse.sending.gasUsed,\n            price: statusResponse.sending.gasPrice,\n            type: 'SEND',\n          },\n        ],\n      })\n    } catch (e: unknown) {\n      const htmlMessage = await getTransactionFailedMessage(\n        step,\n        process.txLink\n      )\n\n      process = this.statusManager.updateProcess(step, process.type, 'FAILED', {\n        error: {\n          code: LiFiErrorCode.TransactionFailed,\n          message: 'Failed while waiting for receiving chain.',\n          htmlMessage,\n        },\n      })\n      this.statusManager.updateExecution(step, 'FAILED')\n      console.warn(e)\n      throw e\n    }\n\n    // DONE\n    return step\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4023, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4029, "column": 0}, "map": {"version":3,"file":"UTXO.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/core/UTXO/UTXO.ts"],"sourcesContent":["import { isUTXOAddress } from '@bigmi/core'\nimport { ChainType } from '@lifi/types'\nimport type { StepExecutorOptions } from '../types.js'\nimport { UTXOStepExecutor } from './UTXOStepExecutor.js'\nimport { getUTXOBalance } from './getUTXOBalance.js'\nimport type { UTXOProvider, UTXOProviderOptions } from './types.js'\n\nexport function UTXO(options?: UTXOProviderOptions): UTXOProvider {\n  const _options: UTXOProviderOptions = options ?? {}\n  return {\n    get type() {\n      return ChainType.UTXO\n    },\n    isAddress: isUTXOAddress,\n    async resolveAddress(name) {\n      // Not supported on UTXO yet\n      return name\n    },\n    getBalance: getUTXOBalance,\n    async getStepExecutor(\n      options: StepExecutorOptions\n    ): Promise<UTXOStepExecutor> {\n      if (!_options.getWalletClient) {\n        throw new Error('Client is not provided.')\n      }\n\n      const walletClient = await _options.getWalletClient()\n\n      const executor = new UTXOStepExecutor({\n        client: walletClient,\n        routeId: options.routeId,\n        executionOptions: {\n          ...options.executionOptions,\n        },\n      })\n\n      return executor\n    },\n    setOptions(options: UTXOProviderOptions) {\n      Object.assign(_options, options)\n    },\n  }\n}\n"],"names":[],"mappings":";;;AACA,OAAO,EAAE,SAAS,EAAE,MAAM,aAAa,CAAA;AADvC,OAAO,EAAE,aAAa,EAAE,MAAM,aAAa,CAAA;AAI3C,OAAO,EAAE,cAAc,EAAE,MAAM,qBAAqB,CAAA;AADpD,OAAO,EAAE,gBAAgB,EAAE,MAAM,uBAAuB,CAAA;;;;;AAIlD,SAAU,IAAI,CAAC,OAA6B;IAChD,MAAM,QAAQ,GAAwB,OAAO,IAAI,CAAA,CAAE,CAAA;IACnD,OAAO;QACL,IAAI,IAAI,IAAA;YACN,yKAAO,YAAS,CAAC,IAAI,CAAA;QACvB,CAAC;QACD,SAAS,0KAAE,iBAAa;QACxB,KAAK,CAAC,cAAc,EAAC,IAAI;YACvB,4BAA4B;YAC5B,OAAO,IAAI,CAAA;QACb,CAAC;QACD,UAAU,iLAAE,iBAAc;QAC1B,KAAK,CAAC,eAAe,EACnB,OAA4B;YAE5B,IAAI,CAAC,QAAQ,CAAC,eAAe,EAAE,CAAC;gBAC9B,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAA;YAC5C,CAAC;YAED,MAAM,YAAY,GAAG,MAAM,QAAQ,CAAC,eAAe,EAAE,CAAA;YAErD,MAAM,QAAQ,GAAG,qLAAI,mBAAgB,CAAC;gBACpC,MAAM,EAAE,YAAY;gBACpB,OAAO,EAAE,OAAO,CAAC,OAAO;gBACxB,gBAAgB,EAAE;oBAChB,GAAG,OAAO,CAAC,gBAAgB;iBAC5B;aACF,CAAC,CAAA;YAEF,OAAO,QAAQ,CAAA;QACjB,CAAC;QACD,UAAU,EAAC,OAA4B;YACrC,MAAM,CAAC,MAAM,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAA;QAClC,CAAC;KACF,CAAA;AACH,CAAC","ignoreList":[0]}},
    {"offset": {"line": 4071, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4077, "column": 0}, "map": {"version":3,"file":"prepareRestart.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/core/prepareRestart.ts"],"sourcesContent":["import type { LiFiStep } from '@lifi/types'\nimport type { LiFiStepExtended, RouteExtended } from './types.js'\n\nexport const prepareRestart = async (route: RouteExtended) => {\n  for (let index = 0; index < route.steps.length; index++) {\n    const step = route.steps[index]\n    const stepHasFailed = step.execution?.status === 'FAILED'\n\n    if (stepHasFailed) {\n      deleteFailedProcesses(step)\n      deleteTransactionData(step)\n    }\n  }\n}\n\nconst deleteFailedProcesses = (step: LiFiStepExtended) => {\n  if (step.execution) {\n    step.execution.process = step.execution.process.filter(\n      (process) => process.status === 'DONE'\n    )\n  }\n}\n\nconst deleteTransactionData = (step: LiFiStep) => {\n  step.transactionRequest = undefined\n}\n"],"names":[],"mappings":";;;AAGO,MAAM,cAAc,GAAG,KAAK,EAAE,KAAoB,EAAE,EAAE;IAC3D,IAAK,IAAI,KAAK,GAAG,CAAC,EAAE,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC,MAAM,EAAE,KAAK,EAAE,CAAE,CAAC;QACxD,MAAM,IAAI,GAAG,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,CAAA;QAC/B,MAAM,aAAa,GAAG,IAAI,CAAC,SAAS,EAAE,MAAM,KAAK,QAAQ,CAAA;QAEzD,IAAI,aAAa,EAAE,CAAC;YAClB,qBAAqB,CAAC,IAAI,CAAC,CAAA;YAC3B,qBAAqB,CAAC,IAAI,CAAC,CAAA;QAC7B,CAAC;IACH,CAAC;AACH,CAAC,CAAA;AAED,MAAM,qBAAqB,GAAG,CAAC,IAAsB,EAAE,EAAE;IACvD,IAAI,IAAI,CAAC,SAAS,EAAE,CAAC;QACnB,IAAI,CAAC,SAAS,CAAC,OAAO,GAAG,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,MAAM,CACpD,CAAC,OAAO,EAAE,CAAG,CAAD,MAAQ,CAAC,MAAM,KAAK,MAAM,CACvC,CAAA;IACH,CAAC;AACH,CAAC,CAAA;AAED,MAAM,qBAAqB,GAAG,CAAC,IAAc,EAAE,EAAE;IAC/C,IAAI,CAAC,kBAAkB,GAAG,SAAS,CAAA;AACrC,CAAC,CAAA","ignoreList":[0]}},
    {"offset": {"line": 4098, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4104, "column": 0}, "map": {"version":3,"file":"execution.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/core/execution.ts"],"sourcesContent":["import type { Route } from '@lifi/types'\nimport { config } from '../config.js'\nimport { executionState } from './executionState.js'\nimport { prepareRestart } from './prepareRestart.js'\nimport type { ExecutionOptions, RouteExtended } from './types.js'\n\n/**\n * Execute a route.\n * @param route - The route that should be executed. Cannot be an active route.\n * @param executionOptions - An object containing settings and callbacks.\n * @returns The executed route.\n * @throws {LiFiError} Throws a LiFiError if the execution fails.\n */\nexport const executeRoute = async (\n  route: Route,\n  executionOptions?: ExecutionOptions\n): Promise<RouteExtended> => {\n  // Deep clone to prevent side effects\n  const clonedRoute = structuredClone<Route>(route)\n\n  let executionPromise = executionState.get(clonedRoute.id)?.promise\n  // Check if route is already running\n  if (executionPromise) {\n    return executionPromise\n  }\n\n  executionState.create({ route: clonedRoute, executionOptions })\n  executionPromise = executeSteps(clonedRoute)\n  executionState.update({\n    route: clonedRoute,\n    promise: executionPromise,\n  })\n\n  return executionPromise\n}\n\n/**\n * Resume the execution of a route that has been stopped or had an error while executing.\n * @param route - The route that is to be executed. Cannot be an active route.\n * @param executionOptions - An object containing settings and callbacks.\n * @returns The executed route.\n * @throws {LiFiError} Throws a LiFiError if the execution fails.\n */\nexport const resumeRoute = async (\n  route: Route,\n  executionOptions?: ExecutionOptions\n): Promise<RouteExtended> => {\n  const execution = executionState.get(route.id)\n\n  if (execution) {\n    const executionHalted = execution.executors.some(\n      (executor) => !executor.allowExecution\n    )\n    if (!executionHalted) {\n      // Check if we want to resume route execution in the background\n      updateRouteExecution(route, {\n        executeInBackground: executionOptions?.executeInBackground,\n      })\n      if (!execution.promise) {\n        // We should never reach this point if we do clean-up properly\n        throw new Error('Route execution promise not found.')\n      }\n      return execution.promise\n    }\n  }\n\n  await prepareRestart(route)\n\n  return executeRoute(route, executionOptions)\n}\n\nconst executeSteps = async (route: RouteExtended): Promise<RouteExtended> => {\n  // Loop over steps and execute them\n  for (let index = 0; index < route.steps.length; index++) {\n    const execution = executionState.get(route.id)\n    // Check if execution has stopped in the meantime\n    if (!execution) {\n      break\n    }\n\n    const step = route.steps[index]\n    const previousStep = route.steps[index - 1]\n    // Check if the step is already done\n    //\n    if (step.execution?.status === 'DONE') {\n      continue\n    }\n\n    // Update step fromAmount using output of the previous step execution. In the future this should be handled by calling `updateRoute`\n    if (previousStep?.execution?.toAmount) {\n      step.action.fromAmount = previousStep.execution.toAmount\n      if (step.includedSteps?.length) {\n        step.includedSteps[0].action.fromAmount =\n          previousStep.execution.toAmount\n      }\n    }\n\n    try {\n      const fromAddress = step.action.fromAddress\n      if (!fromAddress) {\n        throw new Error('Action fromAddress is not specified.')\n      }\n\n      const provider = config\n        .get()\n        .providers.find((provider) => provider.isAddress(fromAddress))\n\n      if (!provider) {\n        throw new Error('SDK Execution Provider not found.')\n      }\n\n      const stepExecutor = await provider.getStepExecutor({\n        routeId: route.id,\n        executionOptions: execution.executionOptions,\n      })\n      execution.executors.push(stepExecutor)\n\n      // Check if we want to execute this step in the background\n      if (execution.executionOptions) {\n        updateRouteExecution(route, execution.executionOptions)\n      }\n\n      const executedStep = await stepExecutor.executeStep(step)\n\n      // We may reach this point if user interaction isn't allowed. We want to stop execution until we resume it\n      if (executedStep.execution?.status !== 'DONE') {\n        stopRouteExecution(route)\n      }\n\n      // Execution stopped during the current step, we don't want to continue to the next step so we return already\n      if (!stepExecutor.allowExecution) {\n        return route\n      }\n    } catch (e) {\n      stopRouteExecution(route)\n      throw e\n    }\n  }\n\n  // Clean up after the execution\n  executionState.delete(route.id)\n  return route\n}\n\n/**\n * Updates route execution to background or foreground state.\n * @param route - A route that is currently in execution.\n * @param options - An object with execution settings.\n */\nexport const updateRouteExecution = (\n  route: Route,\n  options: ExecutionOptions\n): void => {\n  const execution = executionState.get(route.id)\n  if (!execution) {\n    return\n  }\n\n  if ('executeInBackground' in options) {\n    for (const executor of execution.executors) {\n      executor.setInteraction({\n        allowInteraction: !options?.executeInBackground,\n        allowUpdates: true,\n      })\n    }\n  }\n  // Update active route settings so we know what the current state of execution is\n  execution.executionOptions = {\n    ...execution.executionOptions,\n    ...options,\n  }\n}\n\n/**\n * Stops the execution of an active route.\n * @param route - A route that is currently in execution.\n * @returns The stopped route.\n */\nexport const stopRouteExecution = (route: Route): Route => {\n  const execution = executionState.get(route.id)\n  if (!execution) {\n    return route\n  }\n\n  for (const executor of execution.executors) {\n    executor.setInteraction({\n      allowInteraction: false,\n      allowUpdates: false,\n      allowExecution: false,\n    })\n  }\n  executionState.delete(route.id)\n  return execution.route\n}\n\n/**\n * Get the list of active routes.\n * @returns A list of routes.\n */\nexport const getActiveRoutes = (): RouteExtended[] => {\n  return Object.values(executionState.state)\n    .map((dict) => dict?.route)\n    .filter(Boolean) as RouteExtended[]\n}\n\n/**\n * Return the current route information for given route. The route has to be active.\n * @param routeId - A route id.\n * @returns The updated route.\n */\nexport const getActiveRoute = (routeId: string): RouteExtended | undefined => {\n  return executionState.get(routeId)?.route\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4254, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4260, "column": 0}, "map": {"version":3,"file":"getNameServiceAddress.js","sources":["file:///Users/spectrum/Documents/nextjs/vizport-finance/vizport-finance/node_modules/%40lifi/sdk/src/services/getNameServiceAddress.ts"],"sourcesContent":["import type { ChainType } from '@lifi/types'\nimport { config } from '../config.js'\n\nexport const getNameServiceAddress = async (\n  name: string,\n  chainType?: ChainType\n): Promise<string | undefined> => {\n  try {\n    let providers = config.get().providers\n    if (chainType) {\n      providers = providers.filter((provider) => provider.type === chainType)\n    }\n    const resolvers = providers.map((provider) => provider.resolveAddress)\n    if (!resolvers.length) {\n      return\n    }\n    const result = await Promise.any(\n      resolvers.map(async (resolve) => {\n        const address = await resolve(name)\n        if (!address) {\n          throw undefined\n        }\n        return address\n      })\n    )\n    return result\n  } catch (_) {\n    return\n  }\n}\n"],"names":[],"mappings":";;;AACA,OAAO,EAAE,MAAM,EAAE,MAAM,cAAc,CAAA;;AAE9B,MAAM,qBAAqB,GAAG,KAAK,EACxC,IAAY,EACZ,SAAqB,EACQ,EAAE;IAC/B,IAAI,CAAC;QACH,IAAI,SAAS,0JAAG,SAAM,CAAC,GAAG,EAAE,CAAC,SAAS,CAAA;QACtC,IAAI,SAAS,EAAE,CAAC;YACd,SAAS,GAAG,SAAS,CAAC,MAAM,CAAC,CAAC,QAAQ,EAAE,CAAG,CAAD,OAAS,CAAC,IAAI,KAAK,SAAS,CAAC,CAAA;QACzE,CAAC;QACD,MAAM,SAAS,GAAG,SAAS,CAAC,GAAG,CAAC,CAAC,QAAQ,EAAE,CAAG,CAAD,OAAS,CAAC,cAAc,CAAC,CAAA;QACtE,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE,CAAC;YACtB,OAAM;QACR,CAAC;QACD,MAAM,MAAM,GAAG,MAAM,OAAO,CAAC,GAAG,CAC9B,SAAS,CAAC,GAAG,CAAC,KAAK,EAAE,OAAO,EAAE,EAAE;YAC9B,MAAM,OAAO,GAAG,MAAM,OAAO,CAAC,IAAI,CAAC,CAAA;YACnC,IAAI,CAAC,OAAO,EAAE,CAAC;gBACb,MAAM,SAAS,CAAA;YACjB,CAAC;YACD,OAAO,OAAO,CAAA;QAChB,CAAC,CAAC,CACH,CAAA;QACD,OAAO,MAAM,CAAA;IACf,CAAC,CAAC,OAAO,CAAC,EAAE,CAAC;QACX,OAAM;IACR,CAAC;AACH,CAAC,CAAA","ignoreList":[0]}},
    {"offset": {"line": 4287, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}