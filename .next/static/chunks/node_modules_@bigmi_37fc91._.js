(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_@bigmi_37fc91._.js", {

"[project]/node_modules/@bigmi/client/dist/esm/connectors/phantom.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "phantom": (()=>phantom)
});
(()=>{
    const e = new Error("Cannot find module 'wagmi'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/viem/_esm/errors/rpc.js [app-client] (ecmascript)");
;
;
phantom.type = 'UTXO';
function phantom(parameters = {}) {
    const { chainId, shimDisconnect = true } = parameters;
    let accountsChanged;
    return createConnector((config)=>({
            id: 'app.phantom.bitcoin',
            name: 'Phantom',
            type: phantom.type,
            icon: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTA4IiBoZWlnaHQ9IjEwOCIgdmlld0JveD0iMCAwIDEwOCAxMDgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxMDgiIGhlaWdodD0iMTA4IiByeD0iMjYiIGZpbGw9IiNBQjlGRjIiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00Ni41MjY3IDY5LjkyMjlDNDIuMDA1NCA3Ni44NTA5IDM0LjQyOTIgODUuNjE4MiAyNC4zNDggODUuNjE4MkMxOS41ODI0IDg1LjYxODIgMTUgODMuNjU2MyAxNSA3NS4xMzQyQzE1IDUzLjQzMDUgNDQuNjMyNiAxOS44MzI3IDcyLjEyNjggMTkuODMyN0M4Ny43NjggMTkuODMyNyA5NCAzMC42ODQ2IDk0IDQzLjAwNzlDOTQgNTguODI1OCA4My43MzU1IDc2LjkxMjIgNzMuNTMyMSA3Ni45MTIyQzcwLjI5MzkgNzYuOTEyMiA2OC43MDUzIDc1LjEzNDIgNjguNzA1MyA3Mi4zMTRDNjguNzA1MyA3MS41NzgzIDY4LjgyNzUgNzAuNzgxMiA2OS4wNzE5IDY5LjkyMjlDNjUuNTg5MyA3NS44Njk5IDU4Ljg2ODUgODEuMzg3OCA1Mi41NzU0IDgxLjM4NzhDNDcuOTkzIDgxLjM4NzggNDUuNjcxMyA3OC41MDYzIDQ1LjY3MTMgNzQuNDU5OEM0NS42NzEzIDcyLjk4ODQgNDUuOTc2OCA3MS40NTU2IDQ2LjUyNjcgNjkuOTIyOVpNODMuNjc2MSA0Mi41Nzk0QzgzLjY3NjEgNDYuMTcwNCA4MS41NTc1IDQ3Ljk2NTggNzkuMTg3NSA0Ny45NjU4Qzc2Ljc4MTYgNDcuOTY1OCA3NC42OTg5IDQ2LjE3MDQgNzQuNjk4OSA0Mi41Nzk0Qzc0LjY5ODkgMzguOTg4NSA3Ni43ODE2IDM3LjE5MzEgNzkuMTg3NSAzNy4xOTMxQzgxLjU1NzUgMzcuMTkzMSA4My42NzYxIDM4Ljk4ODUgODMuNjc2MSA0Mi41Nzk0Wk03MC4yMTAzIDQyLjU3OTVDNzAuMjEwMyA0Ni4xNzA0IDY4LjA5MTYgNDcuOTY1OCA2NS43MjE2IDQ3Ljk2NThDNjMuMzE1NyA0Ny45NjU4IDYxLjIzMyA0Ni4xNzA0IDYxLjIzMyA0Mi41Nzk1QzYxLjIzMyAzOC45ODg1IDYzLjMxNTcgMzcuMTkzMSA2NS43MjE2IDM3LjE5MzFDNjguMDkxNiAzNy4xOTMxIDcwLjIxMDMgMzguOTg4NSA3MC4yMTAzIDQyLjU3OTVaIiBmaWxsPSIjRkZGREY4Ii8+Cjwvc3ZnPgo=',
            async setup () {
            //
            },
            async getInternalProvider () {
                if (typeof window === 'undefined') {
                    return;
                }
                if ('phantom' in window) {
                    const anyWindow = window;
                    const internalProvider = anyWindow.phantom?.bitcoin;
                    if (internalProvider?.isPhantom) {
                        return internalProvider;
                    }
                }
            // TODO: https://docs.phantom.app/phantom-deeplinks/deeplinks-ios-and-android
            },
            async getProvider () {
                const internalProvider = await this.getInternalProvider();
                if (!internalProvider) {
                    return;
                }
                const provider = {
                    request: this.request.bind(internalProvider)
                };
                return provider;
            },
            async request ({ method, params }) {
                switch(method){
                    case 'signPsbt':
                        {
                            const { psbt, ...options } = params;
                            const psbtUint8Array = new Uint8Array(psbt.match(/.{1,2}/g).map((byte)=>Number.parseInt(byte, 16)));
                            const signedPsbt = await this.signPSBT(psbtUint8Array, {
                                inputsToSign: options.inputsToSign,
                                finalize: options.finalize
                            });
                            const signedPsbtHex = Array.from(signedPsbt, (byte)=>byte.toString(16).padStart(2, '0')).join('');
                            return signedPsbtHex;
                        }
                    default:
                        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MethodNotSupportedRpcError"](new Error(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MethodNotSupportedRpcError"].name), {
                            method
                        });
                }
            },
            async connect () {
                const provider = await this.getInternalProvider();
                if (!provider) {
                    throw new ProviderNotFoundError();
                }
                try {
                    const accounts = await this.getAccounts();
                    const chainId = await this.getChainId();
                    if (!accountsChanged) {
                        accountsChanged = this.onAccountsChanged.bind(this);
                        provider.on('accountsChanged', accountsChanged);
                    }
                    // Remove disconnected shim if it exists
                    if (shimDisconnect) {
                        await Promise.all([
                            config.storage?.setItem(`${this.id}.connected`, true),
                            config.storage?.removeItem(`${this.id}.disconnected`)
                        ]);
                    }
                    return {
                        accounts,
                        chainId
                    };
                } catch (error) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UserRejectedRequestError"]({
                        name: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UserRejectedRequestError"].name,
                        message: error.message
                    });
                }
            },
            async disconnect () {
                const provider = await this.getInternalProvider();
                if (accountsChanged) {
                    provider?.removeListener('accountsChanged', accountsChanged);
                    accountsChanged = undefined;
                }
                // Add shim signalling connector is disconnected
                if (shimDisconnect) {
                    await Promise.all([
                        config.storage?.setItem(`${this.id}.disconnected`, true),
                        config.storage?.removeItem(`${this.id}.connected`)
                    ]);
                }
            },
            async getAccounts () {
                const provider = await this.getInternalProvider();
                if (!provider) {
                    throw new ProviderNotFoundError();
                }
                const accounts = await provider.requestAccounts();
                return accounts.filter((account)=>account.purpose === 'payment').map((account)=>account.address);
            },
            async getChainId () {
                return chainId;
            },
            async isAuthorized () {
                try {
                    const isConnected = shimDisconnect && // If shim exists in storage, connector is disconnected
                    Boolean(await config.storage?.getItem(`${this.id}.connected`));
                    return isConnected;
                } catch  {
                    return false;
                }
            },
            async onAccountsChanged (accounts) {
                if (accounts.length === 0) {
                    this.onDisconnect();
                } else {
                    config.emitter.emit('change', {
                        accounts: accounts.filter((account)=>account.purpose === 'payment').map((account)=>account.address)
                    });
                }
            },
            onChainChanged (chain) {
                const chainId = Number(chain);
                config.emitter.emit('change', {
                    chainId
                });
            },
            async onDisconnect (_error) {
                // No need to remove `${this.id}.disconnected` from storage because `onDisconnect` is typically
                // only called when the wallet is disconnected through the wallet's interface, meaning the wallet
                // actually disconnected and we don't need to simulate it.
                config.emitter.emit('disconnect');
            }
        }));
} //# sourceMappingURL=phantom.js.map
}}),
"[project]/node_modules/@bigmi/client/dist/esm/connectors/xverse.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "xverse": (()=>xverse)
});
(()=>{
    const e = new Error("Cannot find module 'wagmi'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/viem/_esm/errors/rpc.js [app-client] (ecmascript)");
;
;
xverse.type = 'UTXO';
function xverse(parameters = {}) {
    const { chainId, shimDisconnect = true } = parameters;
    let accountChange;
    return createConnector((config)=>({
            id: 'XverseProviders.BitcoinProvider',
            name: 'Xverse Wallet',
            type: xverse.type,
            icon: 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI2MDAiIGhlaWdodD0iNjAwIj48ZyBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPjxwYXRoIGZpbGw9IiMxNzE3MTciIGQ9Ik0wIDBoNjAwdjYwMEgweiIvPjxwYXRoIGZpbGw9IiNGRkYiIGZpbGwtcnVsZT0ibm9uemVybyIgZD0iTTQ0MCA0MzUuNHYtNTFjMC0yLS44LTMuOS0yLjItNS4zTDIyMCAxNjIuMmE3LjYgNy42IDAgMCAwLTUuNC0yLjJoLTUxLjFjLTIuNSAwLTQuNiAyLTQuNiA0LjZ2NDcuM2MwIDIgLjggNCAyLjIgNS40bDc4LjIgNzcuOGE0LjYgNC42IDAgMCAxIDAgNi41bC03OSA3OC43Yy0xIC45LTEuNCAyLTEuNCAzLjJ2NTJjMCAyLjQgMiA0LjUgNC42IDQuNUgyNDljMi42IDAgNC42LTIgNC42LTQuNlY0MDVjMC0xLjIuNS0yLjQgMS40LTMuM2w0Mi40LTQyLjJhNC42IDQuNiAwIDAgMSA2LjQgMGw3OC43IDc4LjRhNy42IDcuNiAwIDAgMCA1LjQgMi4yaDQ3LjVjMi41IDAgNC42LTIgNC42LTQuNloiLz48cGF0aCBmaWxsPSIjRUU3QTMwIiBmaWxsLXJ1bGU9Im5vbnplcm8iIGQ9Ik0zMjUuNiAyMjcuMmg0Mi44YzIuNiAwIDQuNiAyLjEgNC42IDQuNnY0Mi42YzAgNCA1IDYuMSA4IDMuMmw1OC43LTU4LjVjLjgtLjggMS4zLTIgMS4zLTMuMnYtNTEuMmMwLTIuNi0yLTQuNi00LjYtNC42TDM4NCAxNjBjLTEuMiAwLTIuNC41LTMuMyAxLjNsLTU4LjQgNTguMWE0LjYgNC42IDAgMCAwIDMuMiA3LjhaIi8+PC9nPjwvc3ZnPg==',
            async setup () {
            //
            },
            async getInternalProvider () {
                if (typeof window === 'undefined') {
                    return undefined;
                }
                if ('XverseProviders' in window) {
                    const anyWindow = window;
                    const provider = anyWindow.XverseProviders.BitcoinProvider;
                    return provider;
                }
            },
            async getProvider () {
                const internalProvider = await this.getInternalProvider();
                if (!internalProvider) {
                    return;
                }
                const provider = {
                    request: this.request.bind(internalProvider)
                };
                return provider;
            },
            async request ({ method, params }) {
                switch(method){
                    case 'signPsbt':
                        {
                            const { psbt, ...options } = params;
                            const psbtBase64 = btoa(psbt.match(/.{1,2}/g).map((byte)=>String.fromCharCode(Number.parseInt(byte, 16))).join(''));
                            const signInputs = options.inputsToSign.reduce((signInputs, input)=>{
                                if (!signInputs[input.address]) {
                                    signInputs[input.address] = [];
                                }
                                signInputs[input.address].push(...input.signingIndexes);
                                return signInputs;
                            }, {});
                            const signedPsbt = await this.request('signPsbt', {
                                psbt: psbtBase64,
                                allowedSignHash: 1,
                                signInputs: signInputs,
                                broadcast: options.finalize
                            });
                            if (signedPsbt?.error) {
                                throw signedPsbt?.error;
                            }
                            return signedPsbt;
                        }
                    default:
                        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MethodNotSupportedRpcError"](new Error(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MethodNotSupportedRpcError"].name), {
                            method
                        });
                }
            },
            async connect ({ isReconnecting } = {}) {
                const provider = await this.getInternalProvider();
                if (!provider) {
                    throw new ProviderNotFoundError();
                }
                if (!isReconnecting) {
                    const connected = await provider.request('wallet_requestPermissions');
                    if (connected.error) {
                        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UserRejectedRequestError"]({
                            name: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UserRejectedRequestError"].name,
                            message: connected.error.message
                        });
                    }
                }
                const accounts = await this.getAccounts();
                const chainId = await this.getChainId();
                if (!accountChange) {
                    accountChange = this.onAccountsChanged.bind(this);
                    provider.addListener('accountChange', accountChange);
                }
                // Remove disconnected shim if it exists
                if (shimDisconnect) {
                    await Promise.all([
                        config.storage?.setItem(`${this.id}.connected`, true),
                        config.storage?.removeItem(`${this.id}.disconnected`)
                    ]);
                }
                return {
                    accounts,
                    chainId
                };
            },
            async disconnect () {
                const provider = await this.getInternalProvider();
                if (!provider) {
                    throw new ProviderNotFoundError();
                }
                if (accountChange) {
                    provider.removeListener?.('accountChange', accountChange);
                    accountChange = undefined;
                }
                // await provider.request('wallet_renouncePermissions').catch();
                // Add shim signalling connector is disconnected
                if (shimDisconnect) {
                    await Promise.all([
                        config.storage?.setItem(`${this.id}.disconnected`, true),
                        config.storage?.removeItem(`${this.id}.connected`)
                    ]);
                }
            },
            async getAccounts () {
                const provider = await this.getInternalProvider();
                if (!provider) {
                    throw new ProviderNotFoundError();
                }
                const accounts = await provider.request('getAddresses', {
                    purposes: [
                        'payment'
                    ]
                });
                if (!accounts.result) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UserRejectedRequestError"]({
                        name: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UserRejectedRequestError"].name,
                        message: accounts.error?.message
                    });
                }
                return accounts.result.addresses.map((account)=>account.address);
            },
            async getChainId () {
                return chainId;
            },
            async isAuthorized () {
                try {
                    const isConnected = shimDisconnect && // If shim exists in storage, connector is disconnected
                    Boolean(await config.storage?.getItem(`${this.id}.connected`));
                    return isConnected;
                } catch  {
                    return false;
                }
            },
            async onAccountsChanged () {
                const { accounts } = await this.connect();
                config.emitter.emit('change', {
                    accounts
                });
            },
            onChainChanged (chain) {
                const chainId = Number(chain);
                config.emitter.emit('change', {
                    chainId
                });
            },
            async onDisconnect (_error) {
                config.emitter.emit('disconnect');
            }
        }));
} //# sourceMappingURL=xverse.js.map
}}),
"[project]/node_modules/@bigmi/client/dist/esm/connectors/unisat.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "unisat": (()=>unisat)
});
(()=>{
    const e = new Error("Cannot find module 'wagmi'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/viem/_esm/errors/rpc.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$promise$2f$withRetry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/viem/_esm/utils/promise/withRetry.js [app-client] (ecmascript)");
;
;
unisat.type = 'UTXO';
function unisat(parameters = {}) {
    const { chainId, shimDisconnect = true } = parameters;
    let accountsChanged;
    return createConnector((config)=>({
            id: 'unisat',
            name: 'Unisat',
            type: unisat.type,
            icon: 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGRhdGEtbmFtZT0i5Zu+5bGCIDIiIHZpZXdCb3g9IjAgMCAxMTUuNzcgMTQ3LjciPjxkZWZzPjxsaW5lYXJHcmFkaWVudCBpZD0iYSIgeDE9IjMzNzkuMDMiIHgyPSIzNDE1LjQ4IiB5MT0iLTIxMDIiIHkyPSItMjE5OC4xMSIgZGF0YS1uYW1lPSLmnKrlkb3lkI3nmoTmuJDlj5ggNSIgZ3JhZGllbnRUcmFuc2Zvcm09InJvdGF0ZSgtMTM0LjczIDIxODcuNjY3IC0zNTMuNDI3KSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPjxzdG9wIG9mZnNldD0iMCIgc3RvcC1jb2xvcj0iIzIwMWMxYiIvPjxzdG9wIG9mZnNldD0iLjM2IiBzdG9wLWNvbG9yPSIjNzczOTBkIi8+PHN0b3Agb2Zmc2V0PSIuNjciIHN0b3AtY29sb3I9IiNlYTgxMDEiLz48c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNmNGI4NTIiLz48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD0iYiIgeDE9IjMzODQuMjMiIHgyPSIzMzMwLjY0IiB5MT0iLTIyMzEuNDIiIHkyPSItMjEzMS4yOSIgZGF0YS1uYW1lPSLmnKrlkb3lkI3nmoTmuJDlj5ggNCIgZ3JhZGllbnRUcmFuc2Zvcm09InJvdGF0ZSgtMTM0LjczIDIxODcuNjY3IC0zNTMuNDI3KSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPjxzdG9wIG9mZnNldD0iMCIgc3RvcC1jb2xvcj0iIzFmMWQxYyIvPjxzdG9wIG9mZnNldD0iLjM3IiBzdG9wLWNvbG9yPSIjNzczOTBkIi8+PHN0b3Agb2Zmc2V0PSIuNjciIHN0b3AtY29sb3I9IiNlYTgxMDEiLz48c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNmNGZiNTIiLz48L2xpbmVhckdyYWRpZW50PjxyYWRpYWxHcmFkaWVudCBpZD0iYyIgY3g9IjUzLjAxIiBjeT0iNDUuODQiIHI9IjExLjEzIiBkYXRhLW5hbWU9IuacquWRveWQjeeahOa4kOWPmCA2IiBmeD0iNTMuMDEiIGZ5PSI0NS44NCIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPjxzdG9wIG9mZnNldD0iMCIgc3RvcC1jb2xvcj0iI2Y0Yjg1MiIvPjxzdG9wIG9mZnNldD0iLjMzIiBzdG9wLWNvbG9yPSIjZWE4MTAxIi8+PHN0b3Agb2Zmc2V0PSIuNjQiIHN0b3AtY29sb3I9IiM3NzM5MGQiLz48c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiMyMTFjMWQiLz48L3JhZGlhbEdyYWRpZW50PjwvZGVmcz48ZyBkYXRhLW5hbWU9IuWbvuWxgiAxIj48cGF0aCBmaWxsPSJ1cmwoI2EpIiBkPSJtODEuNjYgMTMuMjkgMzAuMzEgMzAuMDJjMi41OCAyLjU1IDMuODUgNS4xMyAzLjgxIDcuNzMtLjA0IDIuNi0xLjE1IDQuOTctMy4zMiA3LjEyLTIuMjcgMi4yNS00LjcyIDMuMzktNy4zNCAzLjQ0LTIuNjIuMDQtNS4yMi0xLjIyLTcuOC0zLjc3bC0zMS0zMC43Yy0zLjUyLTMuNDktNi45Mi01Ljk2LTEwLjE5LTcuNDEtMy4yNy0xLjQ1LTYuNzEtMS42OC0xMC4zMS0uNjgtMy42MS45OS03LjQ4IDMuNTQtMTEuNjMgNy42NC01LjcyIDUuNjctOC40NSAxMC45OS04LjE3IDE1Ljk2LjI4IDQuOTcgMy4xMiAxMC4xMyA4LjUxIDE1LjQ2bDMxLjI1IDMwLjk2YzIuNjEgMi41OCAzLjg5IDUuMTYgMy44NSA3LjcyLS4wNCAyLjU3LTEuMTYgNC45NC0zLjM3IDcuMTMtMi4yIDIuMTgtNC42MyAzLjMyLTcuMjcgMy40MS0yLjY0LjA5LTUuMjctMS4xNi03Ljg3LTMuNzRMMjAuODEgNzMuNTZjLTQuOTMtNC44OC04LjQ5LTkuNS0xMC42OC0xMy44Ni0yLjE5LTQuMzYtMy4wMS05LjI5LTIuNDQtMTQuNzkuNTEtNC43MSAyLjAyLTkuMjcgNC41NC0xMy42OSAyLjUxLTQuNDIgNi4xMS04Ljk0IDEwLjc4LTEzLjU3IDUuNTYtNS41MSAxMC44Ny05LjczIDE1LjkzLTEyLjY3QzQzLjk5IDIuMDQgNDguODguNDEgNTMuNi4wN2M0LjczLS4zNCA5LjM5LjYgMTQgMi44MiA0LjYxIDIuMjIgOS4yOSA1LjY4IDE0LjA1IDEwLjRaIi8+PHBhdGggZmlsbD0idXJsKCNiKSIgZD0iTTM0LjExIDEzNC40MiAzLjgxIDEwNC40QzEuMjMgMTAxLjg0LS4wNCA5OS4yNyAwIDk2LjY3Yy4wNC0yLjYgMS4xNS00Ljk3IDMuMzItNy4xMiAyLjI3LTIuMjUgNC43Mi0zLjM5IDcuMzQtMy40NCAyLjYyLS4wNCA1LjIyIDEuMjEgNy44IDMuNzdsMzAuOTkgMzAuN2MzLjUzIDMuNDkgNi45MiA1Ljk2IDEwLjE5IDcuNDEgMy4yNyAxLjQ1IDYuNzEgMS42NyAxMC4zMi42OCAzLjYxLS45OSA3LjQ4LTMuNTQgMTEuNjMtNy42NSA1LjcyLTUuNjcgOC40NS0xMC45OSA4LjE3LTE1Ljk2LS4yOC00Ljk3LTMuMTItMTAuMTMtOC41MS0xNS40N0w2NC42IDczLjI0Yy0yLjYxLTIuNTgtMy44OS01LjE2LTMuODUtNy43Mi4wNC0yLjU3IDEuMTYtNC45NCAzLjM3LTcuMTMgMi4yLTIuMTggNC42My0zLjMyIDcuMjctMy40MSAyLjY0LS4wOSA1LjI3IDEuMTYgNy44NyAzLjc0bDE1LjcgMTUuNDFjNC45MyA0Ljg4IDguNDkgOS41IDEwLjY4IDEzLjg2IDIuMTkgNC4zNiAzLjAxIDkuMjkgMi40NCAxNC43OS0uNTEgNC43MS0yLjAyIDkuMjctNC41NCAxMy42OS0yLjUxIDQuNDItNi4xMSA4Ljk0LTEwLjc4IDEzLjU3LTUuNTYgNS41MS0xMC44NyA5LjczLTE1LjkzIDEyLjY3LTUuMDYgMi45NC05Ljk1IDQuNTgtMTQuNjggNC45Mi00LjczLjM0LTkuMzktLjYtMTQtMi44Mi00LjYxLTIuMjItOS4yOS01LjY4LTE0LjA1LTEwLjRaIi8+PGNpcmNsZSBjeD0iNTMuMDEiIGN5PSI0NS44MyIgcj0iMTEuMTMiIGZpbGw9InVybCgjYykiLz48L2c+PC9zdmc+',
            async setup () {
            //
            },
            async getInternalProvider () {
                if (typeof window === 'undefined') {
                    return;
                }
                if ('unisat' in window) {
                    const anyWindow = window;
                    return anyWindow.unisat;
                }
            },
            async getProvider () {
                const internalProvider = await this.getInternalProvider();
                if (!internalProvider) {
                    return;
                }
                const provider = {
                    request: this.request.bind(internalProvider)
                };
                return provider;
            },
            async request ({ method, params }) {
                switch(method){
                    case 'signPsbt':
                        {
                            const { psbt, ...options } = params;
                            const toSignInputs = options.inputsToSign.flatMap(({ sigHash, address, signingIndexes })=>signingIndexes.map((index)=>({
                                        index,
                                        address,
                                        sighashTypes: sigHash !== undefined ? [
                                            sigHash
                                        ] : undefined
                                    })));
                            const signedPsbt = await this.signPsbt(psbt, {
                                toSignInputs,
                                autoFinalized: options.finalize
                            });
                            return signedPsbt;
                        }
                    default:
                        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MethodNotSupportedRpcError"](new Error(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MethodNotSupportedRpcError"].name), {
                            method
                        });
                }
            },
            async connect () {
                const provider = await this.getInternalProvider();
                if (!provider) {
                    throw new ProviderNotFoundError();
                }
                try {
                    const accounts = await provider.requestAccounts();
                    const chainId = await this.getChainId();
                    if (!accountsChanged) {
                        accountsChanged = this.onAccountsChanged.bind(this);
                        provider.addListener('accountsChanged', accountsChanged);
                    }
                    // Remove disconnected shim if it exists
                    if (shimDisconnect) {
                        await Promise.all([
                            config.storage?.setItem(`${this.id}.connected`, true),
                            config.storage?.removeItem(`${this.id}.disconnected`)
                        ]);
                    }
                    return {
                        accounts,
                        chainId
                    };
                } catch (error) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UserRejectedRequestError"]({
                        name: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UserRejectedRequestError"].name,
                        message: error.message
                    });
                }
            },
            async disconnect () {
                const provider = await this.getInternalProvider();
                if (accountsChanged) {
                    provider?.removeListener('accountsChanged', accountsChanged);
                    accountsChanged = undefined;
                }
                // Add shim signalling connector is disconnected
                if (shimDisconnect) {
                    await Promise.all([
                        config.storage?.setItem(`${this.id}.disconnected`, true),
                        config.storage?.removeItem(`${this.id}.connected`)
                    ]);
                }
            },
            async getAccounts () {
                const provider = await this.getInternalProvider();
                if (!provider) {
                    throw new ProviderNotFoundError();
                }
                const accounts = await provider.getAccounts();
                return accounts;
            },
            async getChainId () {
                return chainId;
            },
            async isAuthorized () {
                try {
                    const isDisconnected = shimDisconnect && await config.storage?.getItem(`${this.id}.disconnected`);
                    if (isDisconnected) {
                        return false;
                    }
                    const accounts = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$promise$2f$withRetry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withRetry"])(()=>this.getAccounts());
                    return !!accounts.length;
                } catch  {
                    return false;
                }
            },
            async onAccountsChanged (accounts) {
                if (accounts.length === 0) {
                    this.onDisconnect();
                } else {
                    config.emitter.emit('change', {
                        accounts: accounts
                    });
                }
            },
            onChainChanged (chain) {
                const chainId = Number(chain);
                config.emitter.emit('change', {
                    chainId
                });
            },
            async onDisconnect (_error) {
                // No need to remove `${this.id}.disconnected` from storage because `onDisconnect` is typically
                // only called when the wallet is disconnected through the wallet's interface, meaning the wallet
                // actually disconnected and we don't need to simulate it.
                config.emitter.emit('disconnect');
            }
        }));
} //# sourceMappingURL=unisat.js.map
}}),
"[project]/node_modules/@bigmi/client/dist/esm/connectors/ctrl.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ctrl": (()=>ctrl)
});
(()=>{
    const e = new Error("Cannot find module 'wagmi'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/viem/_esm/errors/rpc.js [app-client] (ecmascript)");
;
;
ctrl.type = 'UTXO';
function ctrl(parameters = {}) {
    const { chainId, shimDisconnect = true } = parameters;
    let accountsChanged;
    return createConnector((config)=>({
            id: 'io.xdefi.bitcoin',
            name: 'XDEFI',
            type: ctrl.type,
            icon: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTEyIiBoZWlnaHQ9IjUxMiIgdmlld0JveD0iMCAwIDUxMiA1MTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxnIGNsaXAtcGF0aD0idXJsKCNjbGlwMF8yMTkxXzQyOTApIj4KPHJlY3Qgd2lkdGg9IjUxMiIgaGVpZ2h0PSI1MTIiIHJ4PSIxMDQiIGZpbGw9IiMzMzVERTUiLz4KPHBhdGggZD0iTTQ2My40MzggMjQxLjI0N0M0NjAuNzY1IDIwNS4xMzUgNDQ4LjU4IDE3MC4zMzggNDI4LjA4NyAxNDAuMjcxQzQwNy41OTkgMTEwLjIwOSAzNzkuNTA5IDg1LjkxODIgMzQ2LjU3OSA2OS43OTZDMzEzLjY1MyA1My42NzggMjc3LjAzMiA0Ni4yODA0IDI0MC4zMiA0OC4zMzYzQzIwMy42MDUgNTAuMzkyMSAxNjguMDY5IDYxLjgyNTUgMTM3LjIxMiA4MS41MjAxQzEwNi4zNTQgMTAxLjIxIDgxLjIzOTQgMTI4LjQ4IDY0LjMzODYgMTYwLjYzNkw2My41MzYgMTYyLjI1N0M1OC4xOTcxIDE3My4xMjYgNTQuNTg3OCAxODQuNzQ1IDUyLjg0MTEgMTk2LjY5N0M0Ny44NDU1IDIzMi4wMjEgNTUuNTkyIDI2My40NiA3NS44Mjc1IDI4Ny42NjdDOTcuOTU5OSAzMTQuMTM2IDEzMy45OTMgMzI5Ljg3OSAxNzcuMjE1IDMzMS45NDdDMjI5LjgzMiAzMzQuNTU1IDI4Mi4xNDggMzIwLjQzNCAzMTkuMjc1IDI5NC40NThMMzQxLjI4NyAzMDcuMzUzQzMyMC4yNTggMzI1LjI5MSAyNzEuNjM3IDM1Ny41OTQgMTkxLjExMiAzNjIuMDA5QzEwMC43MTkgMzY2LjkzIDYzLjA0MjUgMzM4LjAwMSA2Mi42OTA1IDMzNy43MDZMNTYuMzUxNyAzNDUuNDAzTDQ4IDM1NS4yNzNDNDkuNjAwOCAzNTYuNiA4NS43Mjg1IDM4NS4zMzUgMTcwLjU3NiAzODUuMzM1QzE3Ny41MiAzODUuMzM1IDE4NC44MTYgMzg1LjMzNSAxOTIuNDEyIDM4NC43NDZDMjg5Ljg3MyAzNzkuMzkxIDM0My40NzYgMzM3LjU3NSAzNjIuMjMxIDMxOS42MjlMMzgwLjY0MiAzMzAuNjM3QzM2OC4yNjEgMzQ2LjY1OCAzNTMuMDI1IDM2MC4zMzMgMzM1LjY3IDM3MC45ODJDMjc0LjUwNCA0MDkuODQ5IDE5Ni43MDggNDE0Ljg2NyAxNDIuMjQyIDQxMi4xNjJMMTQxLjA5NiA0MzQuODMxQzE1MC4yNDIgNDM1LjI3MyAxNTkuMDM1IDQzNS40NzEgMTY3LjU4IDQzNS40NzFDMzIxLjA0OCA0MzUuNDcxIDM4My4xMzIgMzY2LjcxOSA0MDAuNTM5IDM0Mi4wNjJMNDE0LjkyNSAzNTAuNDg3QzQwMS4xMzUgMzczLjYwMyAzODIuMzkzIDM5My41NjcgMzU5LjkzMSA0MDguOTM5QzMzMy4wMzQgNDI3LjM0NSAzMDEuNzM1IDQzOC41MzggMjY5LjExNCA0NDEuNDE1TDI3MS4xMTQgNDY0QzMwNy43MzkgNDYwLjc4NiAzNDIuODg4IDQ0OC4yMzYgMzczLjA4OSA0MjcuNTgxQzQwMy4yOSA0MDYuOTI2IDQyNy41MDggMzc4Ljg4MSA0NDMuMzQ5IDM0Ni4yMDdDNDU5LjE4NSAzMTMuNTI5IDQ2Ni4xMTYgMjc3LjM1OCA0NjMuNDM4IDI0MS4yNDdaTTM3NC44MSAyNDQuNzM5QzM2NC42MjYgMjQ0LjczOSAzNTYuMzY4IDIzNi42MTMgMzU2LjM2OCAyMjYuNTg2QzM1Ni4zNjggMjE2LjU2IDM2NC42MjEgMjA4LjQzMyAzNzQuODEgMjA4LjQzM0MzODQuOTkgMjA4LjQzMyAzOTMuMjQ3IDIxNi41NiAzOTMuMjQ3IDIyNi41ODZDMzkzLjI0NyAyMzYuNjEzIDM4NC45OTQgMjQ0LjczOSAzNzQuODEgMjQ0LjczOVoiIGZpbGw9IiNFQ0VDRUMiLz4KPC9nPgo8ZGVmcz4KPGNsaXBQYXRoIGlkPSJjbGlwMF8yMTkxXzQyOTAiPgo8cmVjdCB3aWR0aD0iNTEyIiBoZWlnaHQ9IjUxMiIgZmlsbD0id2hpdGUiLz4KPC9jbGlwUGF0aD4KPC9kZWZzPgo8L3N2Zz4K',
            async setup () {
            //
            },
            async getInternalProvider () {
                if (typeof window === 'undefined') {
                    return;
                }
                if ('xfi' in window) {
                    const anyWindow = window;
                    return anyWindow.xfi?.bitcoin;
                }
            },
            async getProvider () {
                const internalProvider = await this.getInternalProvider();
                if (!internalProvider) {
                    return;
                }
                const provider = {
                    request: this.request.bind(internalProvider)
                };
                return provider;
            },
            async request ({ method, params }) {
                switch(method){
                    case 'signPsbt':
                        {
                            const { psbt, ...options } = params;
                            const signedPsbt = await this.signPsbt(psbt, options.finalize);
                            return signedPsbt;
                        }
                    default:
                        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MethodNotSupportedRpcError"](new Error(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MethodNotSupportedRpcError"].name), {
                            method
                        });
                }
            },
            async connect () {
                const provider = await this.getInternalProvider();
                if (!provider) {
                    throw new ProviderNotFoundError();
                }
                try {
                    const accounts = await provider.requestAccounts();
                    const chainId = await this.getChainId();
                    if (!accountsChanged) {
                        accountsChanged = this.onAccountsChanged.bind(this);
                        provider.addListener('accountsChanged', accountsChanged);
                    }
                    // Remove disconnected shim if it exists
                    if (shimDisconnect) {
                        await Promise.all([
                            config.storage?.setItem(`${this.id}.connected`, true),
                            config.storage?.removeItem(`${this.id}.disconnected`)
                        ]);
                    }
                    return {
                        accounts,
                        chainId
                    };
                } catch (error) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UserRejectedRequestError"]({
                        name: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UserRejectedRequestError"].name,
                        message: error.message
                    });
                }
            },
            async disconnect () {
                const provider = await this.getInternalProvider();
                if (accountsChanged) {
                    provider?.removeListener('accountsChanged', accountsChanged);
                    accountsChanged = undefined;
                }
                // Add shim signalling connector is disconnected
                if (shimDisconnect) {
                    await Promise.all([
                        config.storage?.setItem(`${this.id}.disconnected`, true),
                        config.storage?.removeItem(`${this.id}.connected`)
                    ]);
                }
            },
            async getAccounts () {
                const provider = await this.getInternalProvider();
                if (!provider) {
                    throw new ProviderNotFoundError();
                }
                const accounts = await provider.getAccounts();
                return accounts;
            },
            async getChainId () {
                return chainId;
            },
            async isAuthorized () {
                try {
                    const isConnected = shimDisconnect && // If shim exists in storage, connector is disconnected
                    Boolean(await config.storage?.getItem(`${this.id}.connected`));
                    return isConnected;
                } catch  {
                    return false;
                }
            },
            async onAccountsChanged (accounts) {
                if (accounts.length === 0) {
                    this.onDisconnect();
                } else {
                    config.emitter.emit('change', {
                        accounts: accounts
                    });
                }
            },
            onChainChanged (chain) {
                const chainId = Number(chain);
                config.emitter.emit('change', {
                    chainId
                });
            },
            async onDisconnect (_error) {
                // No need to remove `${this.id}.disconnected` from storage because `onDisconnect` is typically
                // only called when the wallet is disconnected through the wallet's interface, meaning the wallet
                // actually disconnected and we don't need to simulate it.
                config.emitter.emit('disconnect');
            }
        }));
} //# sourceMappingURL=ctrl.js.map
}}),
"[project]/node_modules/@bigmi/client/dist/esm/connectors/okx.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "okx": (()=>okx)
});
(()=>{
    const e = new Error("Cannot find module 'wagmi'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/viem/_esm/errors/rpc.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$promise$2f$withRetry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/viem/_esm/utils/promise/withRetry.js [app-client] (ecmascript)");
;
;
okx.type = 'UTXO';
function okx(parameters = {}) {
    const { chainId, shimDisconnect = true } = parameters;
    let accountsChanged;
    return createConnector((config)=>({
            id: 'com.okex.wallet.bitcoin',
            name: 'OKX Wallet',
            type: okx.type,
            icon: 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMiIgaGVpZ2h0PSIzMiIgZmlsbD0ibm9uZSI+CiAgICA8cGF0aCBmaWxsPSIjMDAwIiBkPSJNMCAwaDMydjMySDB6Ii8+CiAgICA8cGF0aCBmaWxsPSIjZmZmIiBkPSJNMTIuNiA3SDcuNGEuNC40IDAgMCAwLS40LjR2NS4yYzAgLjIyLjE3OS40LjQuNGg1LjJhLjQuNCAwIDAgMCAuNC0uNFY3LjRhLjQuNCAwIDAgMC0uNC0uNE0xOC42MDIgMTMuMDAyaC01LjJhLjQuNCAwIDAgMC0uNC40djUuMmMwIC4yMi4xNzkuNC40LjRoNS4yYS40LjQgMCAwIDAgLjQtLjR2LTUuMmEuNC40IDAgMCAwLS40LS40TTE5LjQgN2g1LjJhLjQuNCAwIDAgMSAuNC40djUuMmEuNC40IDAgMCAxLS40LjRoLTUuMmEuNC40IDAgMCAxLS40LS40VjcuNGEuNC40IDAgMCAxIC40LS40TTEyLjYgMTlINy40YS40LjQgMCAwIDAtLjQuNHY1LjJjMCAuMjIuMTc5LjQuNC40aDUuMmEuNC40IDAgMCAwIC40LS40di01LjJhLjQuNCAwIDAgMC0uNC0uNE0xOS40IDE5aDUuMmEuNC40IDAgMCAxIC40LjR2NS4yYS40LjQgMCAwIDEtLjQuNGgtNS4yYS40LjQgMCAwIDEtLjQtLjR2LTUuMmEuNC40IDAgMCAxIC40LS40Ii8+Cjwvc3ZnPgo=',
            async setup () {
            //
            },
            async getInternalProvider () {
                if (typeof window === 'undefined') {
                    return;
                }
                if ('okxwallet' in window) {
                    const anyWindow = window;
                    const internalProvider = anyWindow.okxwallet?.bitcoin;
                    if (internalProvider?.isOkxWallet) {
                        return internalProvider;
                    }
                }
            },
            async getProvider () {
                const internalProvider = await this.getInternalProvider();
                if (!internalProvider) {
                    return;
                }
                const provider = {
                    request: this.request.bind(internalProvider)
                };
                return provider;
            },
            async request ({ method, params }) {
                switch(method){
                    case 'signPsbt':
                        {
                            const { psbt, ...options } = params;
                            const toSignInputs = options.inputsToSign.flatMap(({ sigHash, address, signingIndexes })=>signingIndexes.map((index)=>({
                                        index,
                                        address,
                                        sighashTypes: sigHash !== undefined ? [
                                            sigHash
                                        ] : undefined
                                    })));
                            const signedPsbt = await this.signPsbt(psbt, {
                                toSignInputs,
                                autoFinalized: options.finalize
                            });
                            return signedPsbt;
                        }
                    default:
                        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MethodNotSupportedRpcError"](new Error(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MethodNotSupportedRpcError"].name), {
                            method
                        });
                }
            },
            async connect () {
                const provider = await this.getInternalProvider();
                if (!provider) {
                    throw new ProviderNotFoundError();
                }
                try {
                    const accounts = await provider.requestAccounts();
                    const chainId = await this.getChainId();
                    if (!accountsChanged) {
                        accountsChanged = this.onAccountsChanged.bind(this);
                        provider.addListener('accountsChanged', accountsChanged);
                    }
                    // Remove disconnected shim if it exists
                    if (shimDisconnect) {
                        await Promise.all([
                            config.storage?.setItem(`${this.id}.connected`, true),
                            config.storage?.removeItem(`${this.id}.disconnected`)
                        ]);
                    }
                    return {
                        accounts,
                        chainId
                    };
                } catch (error) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UserRejectedRequestError"]({
                        name: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UserRejectedRequestError"].name,
                        message: error.message
                    });
                }
            },
            async disconnect () {
                const provider = await this.getInternalProvider();
                if (accountsChanged) {
                    provider?.removeListener('accountsChanged', accountsChanged);
                    accountsChanged = undefined;
                }
                // Add shim signalling connector is disconnected
                if (shimDisconnect) {
                    await Promise.all([
                        config.storage?.setItem(`${this.id}.disconnected`, true),
                        config.storage?.removeItem(`${this.id}.connected`)
                    ]);
                }
            },
            async getAccounts () {
                const provider = await this.getInternalProvider();
                if (!provider) {
                    throw new ProviderNotFoundError();
                }
                const accounts = await provider.getAccounts();
                return accounts;
            },
            async getChainId () {
                return chainId;
            },
            async isAuthorized () {
                try {
                    const isDisconnected = shimDisconnect && await config.storage?.getItem(`${this.id}.disconnected`);
                    if (isDisconnected) {
                        return false;
                    }
                    const accounts = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$promise$2f$withRetry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withRetry"])(()=>this.getAccounts());
                    return !!accounts.length;
                } catch  {
                    return false;
                }
            },
            async onAccountsChanged (accounts) {
                if (accounts.length === 0) {
                    this.onDisconnect();
                } else {
                    config.emitter.emit('change', {
                        accounts: accounts
                    });
                }
            },
            onChainChanged (chain) {
                const chainId = Number(chain);
                config.emitter.emit('change', {
                    chainId
                });
            },
            async onDisconnect (_error) {
                // No need to remove `${this.id}.disconnected` from storage because `onDisconnect` is typically
                // only called when the wallet is disconnected through the wallet's interface, meaning the wallet
                // actually disconnected and we don't need to simulate it.
                config.emitter.emit('disconnect');
            }
        }));
} //# sourceMappingURL=okx.js.map
}}),
"[project]/node_modules/@bigmi/client/dist/esm/connectors/leather.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "leather": (()=>leather)
});
(()=>{
    const e = new Error("Cannot find module 'wagmi'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/viem/_esm/errors/rpc.js [app-client] (ecmascript)");
;
;
leather.type = 'UTXO';
function leather(parameters = {}) {
    const { chainId, shimDisconnect = true } = parameters;
    return createConnector((config)=>({
            id: 'LeatherProvider',
            name: 'Leather',
            type: leather.type,
            icon: 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMjgiIGhlaWdodD0iMTI4IiBmaWxsPSJub25lIj4KICAgIDxwYXRoIGZpbGw9IiMxMjEwMEYiIGQ9Ik0wIDBoMTI4djEyOEgweiIvPgogICAgPHBhdGggZmlsbD0iI0Y1RjFFRCIgZD0iTTc0LjkxNyA1Mi43MTFjNy41Ni0xLjE3IDE4LjQ5Mi05LjEzIDE4LjQ5Mi0xNS4zMzUgMC0xLjg3My0xLjUxMi0zLjE2LTMuNzIyLTMuMTYtNC4xODcgMC0xMS4yOCA2LjMyLTE0Ljc3IDE4LjQ5NU0zOS45MTEgODMuNWMtOS44ODUgMC0xMC43IDkuODMzLS44MTQgOS44MzMgNC40MiAwIDkuNzctMS43NTYgMTIuNTYtNC45MTYtNC4wNy0zLjUxMi03LjQ0My00LjkxNy0xMS43NDYtNC45MTdtNjIuOTE4LTQuMjE0Yy41ODEgMTYuNTA2LTcuNzkyIDI1Ljc1NC0yMS45OCAyNS43NTQtOC4zNzQgMC0xMi41Ni0zLjE2MS0yMS41MTYtOS4wMTQtNC42NTIgNS4xNTEtMTMuNDkgOS4wMTQtMjAuODE4IDkuMDE0LTI1LjIzNiAwLTI0LjE5LTMyLjE5MyAxLjUxMi0zMi4xOTMgNS4zNSAwIDkuODg2IDEuNDA1IDE1LjcgNS4wMzRsMy44MzktMTMuNDYyQzQzLjc0OSA2MC4wODYgMzUuODQgNDcuOTEyIDQzLjYzMyAzMC40NjloMTIuNTZjLTYuOTc4IDExLjU5LTIuMjEgMjEuMTg5IDYuNjI5IDIyLjI0MkM2Ny41OSAzNS43MzcgNzcuODI1IDIyLjUxIDkxLjQzMiAyMi41MWM3LjY3NSAwIDEzLjcyMyA1LjAzNCAxMy43MjMgMTQuMTY1IDAgMTQuNjMzLTE5LjA3MyAyNi41NzMtMzMuNDk0IDI3Ljc0NEw2NS43MyA4NS4zNzJjNi43NDUgNy44NDMgMjUuNDY5IDE1LjQ1MiAyNS40NjktNi4wODd6Ii8+Cjwvc3ZnPg==',
            async setup () {
            //
            },
            async getInternalProvider () {
                if (typeof window === 'undefined') {
                    return undefined;
                }
                if ('LeatherProvider' in window) {
                    const anyWindow = window;
                    const provider = anyWindow.LeatherProvider;
                    return provider;
                }
            },
            async getProvider () {
                const internalProvider = await this.getInternalProvider();
                if (!internalProvider) {
                    return;
                }
                const provider = {
                    request: this.request.bind(internalProvider)
                };
                return provider;
            },
            async request ({ method, params }) {
                switch(method){
                    case 'signPsbt':
                        {
                            const { psbt, ...options } = params;
                            const signedPsbt = await this.request('signPsbt', {
                                psbt: psbt,
                                broadcast: options.finalize
                            });
                            if (signedPsbt?.error) {
                                throw signedPsbt?.error;
                            }
                            return signedPsbt;
                        }
                    default:
                        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MethodNotSupportedRpcError"](new Error(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MethodNotSupportedRpcError"].name), {
                            method
                        });
                }
            },
            async connect () {
                const provider = await this.getInternalProvider();
                if (!provider) {
                    throw new ProviderNotFoundError();
                }
                const accounts = await this.getAccounts();
                const chainId = await this.getChainId();
                // Remove disconnected shim if it exists
                if (shimDisconnect) {
                    await Promise.all([
                        config.storage?.setItem(`${this.id}.connected`, true),
                        config.storage?.removeItem(`${this.id}.disconnected`)
                    ]);
                }
                return {
                    accounts,
                    chainId
                };
            },
            async disconnect () {
                const provider = await this.getInternalProvider();
                if (!provider) {
                    throw new ProviderNotFoundError();
                }
                // Add shim signalling connector is disconnected
                if (shimDisconnect) {
                    await Promise.all([
                        config.storage?.setItem(`${this.id}.disconnected`, true),
                        config.storage?.removeItem(`${this.id}.connected`)
                    ]);
                }
            },
            async getAccounts () {
                const provider = await this.getInternalProvider();
                if (!provider) {
                    throw new ProviderNotFoundError();
                }
                const accounts = await provider.request('getAddresses');
                if (!accounts.result) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UserRejectedRequestError"]({
                        name: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UserRejectedRequestError"].name,
                        message: accounts.error?.message
                    });
                }
                return accounts.result.addresses.map((account)=>account.address);
            },
            async getChainId () {
                return chainId;
            },
            async isAuthorized () {
                try {
                    const isConnected = shimDisconnect && // If shim exists in storage, connector is disconnected
                    Boolean(await config.storage?.getItem(`${this.id}.connected`));
                    return isConnected;
                } catch  {
                    return false;
                }
            },
            async onAccountsChanged () {
                const { accounts } = await this.connect();
                config.emitter.emit('change', {
                    accounts
                });
            },
            onChainChanged (chain) {
                const chainId = Number(chain);
                config.emitter.emit('change', {
                    chainId
                });
            },
            async onDisconnect (_error) {
                config.emitter.emit('disconnect');
            }
        }));
} //# sourceMappingURL=leather.js.map
}}),
"[project]/node_modules/@bigmi/client/dist/esm/connectors/onekey.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "onekey": (()=>onekey)
});
(()=>{
    const e = new Error("Cannot find module 'wagmi'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/viem/_esm/errors/rpc.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$promise$2f$withRetry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/viem/_esm/utils/promise/withRetry.js [app-client] (ecmascript)");
;
;
onekey.type = 'UTXO';
function onekey(parameters = {}) {
    const { chainId, shimDisconnect = true } = parameters;
    let accountsChanged;
    return createConnector((config)=>({
            id: 'so.onekey.app.wallet.bitcoin',
            name: 'OneKey',
            type: onekey.type,
            icon: 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTYiIGN5PSIxNiIgcj0iMTMiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik0xNi4wMDAxIDIyLjkxMDhDMTcuNTMwOSAyMi45MTA4IDE4Ljc3MTggMjEuNjY5OSAxOC43NzE4IDIwLjEzOTFDMTguNzcxOCAxOC42MDg0IDE3LjUzMDkgMTcuMzY3NCAxNi4wMDAxIDE3LjM2NzRDMTQuNDY5MyAxNy4zNjc0IDEzLjIyODQgMTguNjA4NCAxMy4yMjg0IDIwLjEzOTFDMTMuMjI4NCAyMS42Njk5IDE0LjQ2OTMgMjIuOTEwOCAxNi4wMDAxIDIyLjkxMDhaIiBmaWxsPSJibGFjayIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTE2IDMyQzI3LjA0NTcgMzIgMzIgMjcuMDQ1NyAzMiAxNkMzMiA0Ljk1NDMgMjcuMDQ1NyAwIDE2IDBDNC45NTQzIDAgMCA0Ljk1NDMgMCAxNkMwIDI3LjA0NTcgNC45NTQzIDMyIDE2IDMyWk0xMi45OTQ1IDYuNzg0NTdIMTcuNDQ1NlYxNC4xMTk2SDE0LjY4NTlWOS4xNDU4M0gxMi4yMTM2TDEyLjk5NDUgNi43ODQ1N1pNMTYuMDAwMSAyNS4yMTU0QzE4LjgwMzcgMjUuMjE1NCAyMS4wNzY0IDIyLjk0MjcgMjEuMDc2NCAyMC4xMzkxQzIxLjA3NjQgMTcuMzM1NiAxOC44MDM3IDE1LjA2MjggMTYuMDAwMSAxNS4wNjI4QzEzLjE5NjUgMTUuMDYyOCAxMC45MjM4IDE3LjMzNTYgMTAuOTIzOCAyMC4xMzkxQzEwLjkyMzggMjIuOTQyNyAxMy4xOTY1IDI1LjIxNTQgMTYuMDAwMSAyNS4yMTU0WiIgZmlsbD0iYmxhY2siLz4KPC9zdmc+Cg==',
            async setup () {
            //
            },
            async getInternalProvider () {
                if (typeof window === 'undefined') {
                    return;
                }
                if ('$onekey' in window) {
                    const anyWindow = window;
                    return anyWindow.$onekey.btc;
                }
            },
            async getProvider () {
                const internalProvider = await this.getInternalProvider();
                if (!internalProvider) {
                    return;
                }
                const provider = {
                    request: this.request.bind(internalProvider)
                };
                return provider;
            },
            async request ({ method, params }) {
                switch(method){
                    case 'signPsbt':
                        {
                            const { psbt, ...options } = params;
                            const toSignInputs = options.inputsToSign.flatMap(({ sigHash, address, signingIndexes })=>signingIndexes.map((index)=>({
                                        index,
                                        address,
                                        sighashTypes: sigHash !== undefined ? [
                                            sigHash
                                        ] : undefined
                                    })));
                            const signedPsbt = await this.signPsbt(psbt, {
                                toSignInputs,
                                autoFinalized: options.finalize
                            });
                            return signedPsbt;
                        }
                    default:
                        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MethodNotSupportedRpcError"](new Error(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MethodNotSupportedRpcError"].name), {
                            method
                        });
                }
            },
            async connect () {
                const provider = await this.getInternalProvider();
                if (!provider) {
                    throw new ProviderNotFoundError();
                }
                try {
                    const accounts = await provider.requestAccounts();
                    const chainId = await this.getChainId();
                    if (!accountsChanged) {
                        accountsChanged = this.onAccountsChanged.bind(this);
                        provider.addListener('accountsChanged', accountsChanged);
                    }
                    // Remove disconnected shim if it exists
                    if (shimDisconnect) {
                        await Promise.all([
                            config.storage?.setItem(`${this.id}.connected`, true),
                            config.storage?.removeItem(`${this.id}.disconnected`)
                        ]);
                    }
                    return {
                        accounts,
                        chainId
                    };
                } catch (error) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UserRejectedRequestError"]({
                        name: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$rpc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UserRejectedRequestError"].name,
                        message: error.message
                    });
                }
            },
            async disconnect () {
                const provider = await this.getInternalProvider();
                if (accountsChanged) {
                    provider?.removeListener('accountsChanged', accountsChanged);
                    accountsChanged = undefined;
                }
                // Add shim signalling connector is disconnected
                if (shimDisconnect) {
                    await Promise.all([
                        config.storage?.setItem(`${this.id}.disconnected`, true),
                        config.storage?.removeItem(`${this.id}.connected`)
                    ]);
                }
            },
            async getAccounts () {
                const provider = await this.getInternalProvider();
                if (!provider) {
                    throw new ProviderNotFoundError();
                }
                const accounts = await provider.getAccounts();
                return accounts;
            },
            async getChainId () {
                return chainId;
            },
            async isAuthorized () {
                try {
                    const isDisconnected = shimDisconnect && await config.storage?.getItem(`${this.id}.disconnected`);
                    if (isDisconnected) {
                        return false;
                    }
                    const accounts = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$promise$2f$withRetry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withRetry"])(()=>this.getAccounts());
                    return !!accounts.length;
                } catch  {
                    return false;
                }
            },
            async onAccountsChanged (accounts) {
                if (accounts.length === 0) {
                    this.onDisconnect();
                } else {
                    config.emitter.emit('change', {
                        accounts: accounts
                    });
                }
            },
            onChainChanged (chain) {
                const chainId = Number(chain);
                config.emitter.emit('change', {
                    chainId
                });
            },
            async onDisconnect (_error) {
                // No need to remove `${this.id}.disconnected` from storage because `onDisconnect` is typically
                // only called when the wallet is disconnected through the wallet's interface, meaning the wallet
                // actually disconnected and we don't need to simulate it.
                config.emitter.emit('disconnect');
            }
        }));
} //# sourceMappingURL=onekey.js.map
}}),
"[project]/node_modules/@bigmi/client/dist/esm/createConfig.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "createConfig": (()=>createConfig)
});
(()=>{
    const e = new Error("Cannot find module 'wagmi'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
;
function createConfig(parameters) {
    return createWagmiConfig({
        storage: createStorage({
            key: 'bigmi',
            storage: typeof window !== 'undefined' && window.localStorage ? window.localStorage : noopStorage
        }),
        ...parameters
    });
} //# sourceMappingURL=createConfig.js.map
}}),
"[project]/node_modules/@bigmi/client/dist/esm/actions/getAddress.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "getAddress": (()=>getAddress)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$bigmi$2f$core$2f$dist$2f$esm$2f$utils$2f$isUTXOAddress$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@bigmi/core/dist/esm/utils/isUTXOAddress.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$address$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/viem/_esm/errors/address.js [app-client] (ecmascript)");
;
;
function getAddress(address) {
    if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$bigmi$2f$core$2f$dist$2f$esm$2f$utils$2f$isUTXOAddress$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isUTXOAddress"])(address)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$address$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["InvalidAddressError"]({
            address
        });
    }
    return address;
} //# sourceMappingURL=getAddress.js.map
}}),
"[project]/node_modules/@bigmi/client/dist/esm/actions/getConnectorClient.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "getConnectorClient": (()=>getConnectorClient)
});
(()=>{
    const e = new Error("Cannot find module 'wagmi'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$errors$2f$config$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@wagmi/core/dist/esm/errors/config.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$accounts$2f$utils$2f$parseAccount$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/viem/_esm/accounts/utils/parseAccount.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$bigmi$2f$client$2f$dist$2f$esm$2f$actions$2f$getAddress$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@bigmi/client/dist/esm/actions/getAddress.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$createClient$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/viem/_esm/clients/createClient.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$transports$2f$custom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/viem/_esm/clients/transports/custom.js [app-client] (ecmascript)");
;
;
;
;
;
async function getConnectorClient(config, parameters = {}) {
    // Get connection
    let connection;
    if (parameters.connector) {
        const { connector } = parameters;
        const [accounts, chainId] = await Promise.all([
            connector.getAccounts(),
            connector.getChainId()
        ]);
        connection = {
            accounts: accounts,
            chainId,
            connector
        };
    } else {
        connection = config.state.connections.get(config.state.current);
    }
    if (!connection) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$errors$2f$config$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ConnectorNotConnectedError"]();
    }
    const chainId = parameters.chainId ?? connection.chainId;
    // Check connector using same chainId as connection
    const connectorChainId = await connection.connector.getChainId();
    if (connectorChainId !== connection.chainId) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$wagmi$2f$core$2f$dist$2f$esm$2f$errors$2f$config$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ConnectorChainMismatchError"]({
            connectionChainId: connection.chainId,
            connectorChainId
        });
    }
    const connector = connection.connector;
    if (connector.getClient) {
        return connector.getClient({
            chainId
        });
    }
    // Default using `custom` transport
    const account = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$accounts$2f$utils$2f$parseAccount$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseAccount"])(parameters.account ?? connection.accounts[0]);
    account.address = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$bigmi$2f$client$2f$dist$2f$esm$2f$actions$2f$getAddress$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAddress"])(account.address);
    const chain = config.chains.find((chain)=>chain.id === chainId);
    const provider = await connection.connector.getProvider({
        chainId
    });
    // If account was provided, check that it exists on the connector
    if (parameters.account && !connection.accounts.some((x)=>x.toLowerCase() === account.address.toLowerCase())) {
        throw new ConnectorAccountNotFoundError({
            address: account.address,
            connector
        });
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$createClient$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createClient"])({
        account,
        chain,
        name: 'Connector Client',
        transport: (opts)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$transports$2f$custom$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["custom"])(provider)({
                ...opts,
                retryCount: 0
            })
    });
} //# sourceMappingURL=getConnectorClient.js.map
}}),
"[project]/node_modules/@bigmi/core/dist/esm/chains/bitcoin.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "bitcoin": (()=>bitcoin)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$chain$2f$defineChain$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/viem/_esm/utils/chain/defineChain.js [app-client] (ecmascript)");
;
const bitcoin = /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$chain$2f$defineChain$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["defineChain"])({
    id: 20000000000001,
    name: 'Bitcoin',
    nativeCurrency: {
        name: 'Bitcoin',
        symbol: 'BTC',
        decimals: 8
    },
    rpcUrls: {
        default: {
            http: [
                'https://node-router.thorswap.net/bitcoin'
            ]
        }
    },
    blockExplorers: {
        default: {
            name: 'Mempool',
            url: 'https://mempool.space/'
        }
    }
}); //# sourceMappingURL=bitcoin.js.map
}}),
"[project]/node_modules/@bigmi/core/dist/esm/utils/getUTXOAddress.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "UTXOAddressType": (()=>UTXOAddressType),
    "UTXONetwork": (()=>UTXONetwork),
    "getUTXOAddress": (()=>getUTXOAddress)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bech32$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/bech32/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bs58$2f$src$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/bs58/src/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha256$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@noble/hashes/esm/sha256.js [app-client] (ecmascript)");
;
;
;
var UTXONetwork;
(function(UTXONetwork) {
    UTXONetwork["Mainnet"] = "mainnet";
    UTXONetwork["Testnet"] = "testnet";
    UTXONetwork["Regtest"] = "regtest";
})(UTXONetwork || (UTXONetwork = {}));
var UTXOAddressType;
(function(UTXOAddressType) {
    UTXOAddressType["p2pkh"] = "p2pkh";
    UTXOAddressType["p2sh"] = "p2sh";
    UTXOAddressType["p2wpkh"] = "p2wpkh";
    UTXOAddressType["p2wsh"] = "p2wsh";
    UTXOAddressType["p2tr"] = "p2tr";
})(UTXOAddressType || (UTXOAddressType = {}));
const addressTypes = {
    0: {
        type: UTXOAddressType.p2pkh,
        network: UTXONetwork.Mainnet
    },
    111: {
        type: UTXOAddressType.p2pkh,
        network: UTXONetwork.Testnet
    },
    5: {
        type: UTXOAddressType.p2sh,
        network: UTXONetwork.Mainnet
    },
    196: {
        type: UTXOAddressType.p2sh,
        network: UTXONetwork.Testnet
    }
};
const parseBech32 = (address)=>{
    let decoded;
    try {
        if (address.startsWith('bc1p') || address.startsWith('tb1p') || address.startsWith('bcrt1p')) {
            decoded = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bech32$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bech32m"].decode(address);
        } else {
            decoded = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bech32$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bech32"].decode(address);
        }
    } catch (_error) {
        throw new Error('Invalid address');
    }
    const mapPrefixToNetwork = {
        bc: UTXONetwork.Mainnet,
        tb: UTXONetwork.Testnet,
        bcrt: UTXONetwork.Regtest
    };
    const network = mapPrefixToNetwork[decoded.prefix];
    if (network === undefined) {
        throw new Error('Invalid address');
    }
    const witnessVersion = decoded.words[0];
    if (witnessVersion < 0 || witnessVersion > 16) {
        throw new Error('Invalid address');
    }
    const data = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bech32$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bech32"].fromWords(decoded.words.slice(1));
    let type;
    if (data.length === 20) {
        type = UTXOAddressType.p2wpkh;
    } else if (witnessVersion === 1) {
        type = UTXOAddressType.p2tr;
    } else {
        type = UTXOAddressType.p2wsh;
    }
    return {
        bech32: true,
        network,
        address,
        type
    };
};
const getUTXOAddress = (address)=>{
    let decoded;
    const prefix = address.substring(0, 2).toLowerCase();
    if (prefix === 'bc' || prefix === 'tb') {
        return parseBech32(address);
    }
    try {
        decoded = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bs58$2f$src$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].decode(address);
    } catch (_error) {
        throw new Error('Invalid address');
    }
    const { length } = decoded;
    if (length !== 25) {
        throw new Error('Invalid address');
    }
    const version = decoded[0];
    const checksum = decoded.slice(length - 4, length);
    const body = decoded.slice(0, length - 4);
    const expectedChecksum = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha256$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sha256"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha256$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sha256"])(body)).slice(0, 4);
    if (checksum.some((value, index)=>value !== expectedChecksum[index])) {
        throw new Error('Invalid address');
    }
    const validVersions = Object.keys(addressTypes).map(Number);
    if (!validVersions.includes(version)) {
        throw new Error('Invalid address');
    }
    const addressType = addressTypes[version];
    return {
        ...addressType,
        address,
        bech32: false
    };
}; //# sourceMappingURL=getUTXOAddress.js.map
}}),
"[project]/node_modules/@bigmi/core/dist/esm/utils/isUTXOAddress.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "isUTXOAddress": (()=>isUTXOAddress)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$bigmi$2f$core$2f$dist$2f$esm$2f$utils$2f$getUTXOAddress$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@bigmi/core/dist/esm/utils/getUTXOAddress.js [app-client] (ecmascript)");
;
const isUTXOAddress = (address, network)=>{
    try {
        const utxoAddress = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$bigmi$2f$core$2f$dist$2f$esm$2f$utils$2f$getUTXOAddress$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getUTXOAddress"])(address);
        if (network) {
            return network === utxoAddress.network;
        }
        return true;
    } catch (_error) {
        return false;
    }
}; //# sourceMappingURL=isUTXOAddress.js.map
}}),
"[project]/node_modules/@bigmi/core/dist/esm/transports/getHttpRpcClient.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "getHttpRpcClient": (()=>getHttpRpcClient)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$promise$2f$withTimeout$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/viem/_esm/utils/promise/withTimeout.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$request$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/viem/_esm/errors/request.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$stringify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/viem/_esm/utils/stringify.js [app-client] (ecmascript)");
;
function getHttpRpcClient(url, options = {}) {
    return {
        async request (params) {
            const { body, onRequest = options.onRequest, onResponse = options.onResponse, timeout = options.timeout ?? 10000 } = params;
            const fetchOptions = {
                ...options.fetchOptions ?? {},
                ...params.fetchOptions ?? {}
            };
            const { headers, method, signal: signal_ } = fetchOptions;
            try {
                const response = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$promise$2f$withTimeout$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTimeout"])(async ({ signal })=>{
                    const init = {
                        ...fetchOptions,
                        body: body ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$stringify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringify"])(body) : undefined,
                        headers: {
                            ...method !== 'GET' ? {
                                'Content-Type': 'application/json'
                            } : undefined,
                            ...headers
                        },
                        method: method,
                        signal: signal_ || (timeout > 0 ? signal : null)
                    };
                    const request = new Request(params.url ?? url, init);
                    if (onRequest) {
                        await onRequest(request, init);
                    }
                    const response = await fetch(params.url ?? url, init);
                    return response;
                }, {
                    errorInstance: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$request$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TimeoutError"]({
                        body: body ?? {},
                        url
                    }),
                    timeout,
                    signal: true
                });
                if (onResponse) {
                    await onResponse(response);
                }
                let data;
                if (response.headers.get('Content-Type')?.startsWith('application/json')) {
                    data = await response.json();
                } else {
                    data = await response.text();
                    data = JSON.parse(data || '{}');
                }
                if (!response.ok) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$request$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HttpRequestError"]({
                        body,
                        details: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$stringify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringify"])(data.error) || response.statusText,
                        headers: response.headers,
                        status: response.status,
                        url
                    });
                }
                return data;
            } catch (err) {
                if (err instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$request$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HttpRequestError"]) {
                    throw err;
                }
                if (err instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$request$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TimeoutError"]) {
                    throw err;
                }
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$request$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HttpRequestError"]({
                    body,
                    cause: err,
                    url
                });
            }
        }
    };
} //# sourceMappingURL=getHttpRpcClient.js.map
}}),
"[project]/node_modules/@bigmi/core/dist/esm/transports/blockchair.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "blockchairMethods": (()=>blockchairMethods)
});
const blockchairMethods = {
    getBalance: async (client, baseUrl, { address })=>{
        const apiUrl = `${baseUrl}/addresses/balances/?addresses=${address}`;
        const response = await client.request({
            url: apiUrl,
            fetchOptions: {
                method: 'GET'
            }
        });
        if (response.context?.code !== 200) {
            return {
                error: {
                    code: response.context?.code,
                    message: response.context?.error
                }
            };
        }
        return {
            result: BigInt(response.data[address])
        };
    }
}; //# sourceMappingURL=blockchair.js.map
}}),
"[project]/node_modules/@bigmi/core/dist/esm/transports/ankr.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "ankrMethods": (()=>ankrMethods)
});
const ankrMethods = {
    getBalance: async (client, baseUrl, { address })=>{
        const apiUrl = `${baseUrl}/address/${address}?details=basic`;
        const response = await client.request({
            url: apiUrl,
            fetchOptions: {
                method: 'GET'
            }
        });
        if (response.error) {
            return {
                error: {
                    code: -1,
                    message: response.error
                }
            };
        }
        return {
            result: BigInt(response.balance)
        };
    }
}; //# sourceMappingURL=ankr.js.map
}}),
"[project]/node_modules/@bigmi/core/dist/esm/transports/blockcypher.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "blockcypherMethods": (()=>blockcypherMethods)
});
const blockcypherMethods = {
    getBalance: async (client, baseUrl, { address })=>{
        const apiUrl = `${baseUrl}/addrs/${address}`;
        const response = await client.request({
            url: apiUrl,
            fetchOptions: {
                method: 'GET'
            }
        });
        if (response.error) {
            return {
                error: {
                    code: -1,
                    message: response.error
                }
            };
        }
        return {
            result: BigInt(response.balance)
        };
    }
}; //# sourceMappingURL=blockcypher.js.map
}}),
"[project]/node_modules/@bigmi/core/dist/esm/transports/mempool.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "mempoolMethods": (()=>mempoolMethods)
});
const mempoolMethods = {
    getBalance: async (client, baseUrl, { address })=>{
        const apiUrl = `${baseUrl}/address/${address}`;
        const response = await client.request({
            url: apiUrl,
            fetchOptions: {
                method: 'GET'
            }
        });
        const balance = response.chain_stats.funded_txo_sum - response.chain_stats.spent_txo_sum;
        return {
            result: BigInt(balance)
        };
    }
}; //# sourceMappingURL=mempool.js.map
}}),
"[project]/node_modules/@bigmi/core/dist/esm/transports/getRpcProviderMethods.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "getRpcProviderMethods": (()=>getRpcProviderMethods)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$bigmi$2f$core$2f$dist$2f$esm$2f$transports$2f$blockchair$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@bigmi/core/dist/esm/transports/blockchair.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$bigmi$2f$core$2f$dist$2f$esm$2f$transports$2f$ankr$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@bigmi/core/dist/esm/transports/ankr.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$bigmi$2f$core$2f$dist$2f$esm$2f$transports$2f$blockcypher$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@bigmi/core/dist/esm/transports/blockcypher.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$bigmi$2f$core$2f$dist$2f$esm$2f$transports$2f$mempool$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@bigmi/core/dist/esm/transports/mempool.js [app-client] (ecmascript)");
;
;
;
;
function getRpcProviderMethods(key) {
    switch(key){
        case 'blockchair':
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$bigmi$2f$core$2f$dist$2f$esm$2f$transports$2f$blockchair$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["blockchairMethods"];
        case 'ankr':
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$bigmi$2f$core$2f$dist$2f$esm$2f$transports$2f$ankr$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ankrMethods"];
        case 'blockcypher':
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$bigmi$2f$core$2f$dist$2f$esm$2f$transports$2f$blockcypher$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["blockcypherMethods"];
        case 'mempool':
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$bigmi$2f$core$2f$dist$2f$esm$2f$transports$2f$mempool$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mempoolMethods"];
        default:
            return null;
    }
} //# sourceMappingURL=getRpcProviderMethods.js.map
}}),
"[project]/node_modules/@bigmi/core/dist/esm/transports/utxo.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "utxo": (()=>utxo)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$transport$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/viem/_esm/errors/transport.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$bigmi$2f$core$2f$dist$2f$esm$2f$transports$2f$getHttpRpcClient$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@bigmi/core/dist/esm/transports/getHttpRpcClient.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$bigmi$2f$core$2f$dist$2f$esm$2f$transports$2f$getRpcProviderMethods$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@bigmi/core/dist/esm/transports/getRpcProviderMethods.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$transports$2f$createTransport$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/viem/_esm/clients/transports/createTransport.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$request$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/viem/_esm/errors/request.js [app-client] (ecmascript)");
;
;
;
function utxo(url, config = {}) {
    const { fetchOptions, key = 'utxo', name = 'UTXO HTTP API', onFetchRequest, onFetchResponse, retryDelay } = config;
    return ({ chain, retryCount: retryCount_, timeout: timeout_ })=>{
        const retryCount = config.retryCount ?? retryCount_;
        const timeout = timeout_ ?? config.timeout ?? 10000;
        let url_ = url;
        if (config.includeChainToURL) {
            const chainName = chain?.name.replace(' ', '-').toLowerCase();
            url_ = `${url}${chainName ? `/${chainName}` : ''}`;
        }
        if (!url_) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$transport$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UrlRequiredError"]();
        }
        const client = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$bigmi$2f$core$2f$dist$2f$esm$2f$transports$2f$getHttpRpcClient$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getHttpRpcClient"])(url_, {
            fetchOptions,
            onRequest: onFetchRequest,
            onResponse: onFetchResponse,
            timeout
        });
        const rpcMethods = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$bigmi$2f$core$2f$dist$2f$esm$2f$transports$2f$getRpcProviderMethods$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getRpcProviderMethods"])(key);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$clients$2f$transports$2f$createTransport$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createTransport"])({
            key,
            name,
            async request ({ method, params }) {
                const body = {
                    method,
                    params
                };
                const methodHandler = rpcMethods?.[method];
                const { error, result } = await (methodHandler?.(client, url_, params) ?? client.request({
                    body
                }));
                if (error) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$request$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RpcRequestError"]({
                        body,
                        error,
                        url: url_
                    });
                }
                return result;
            },
            retryCount,
            retryDelay,
            timeout,
            type: 'http'
        }, {
            fetchOptions,
            url: url_
        });
    };
} //# sourceMappingURL=utxo.js.map
}}),
"[project]/node_modules/@bigmi/core/dist/esm/actions/getBalance.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "getBalance": (()=>getBalance)
});
async function getBalance(client, params) {
    const data = await client.request({
        method: 'getBalance',
        params
    }, {
        dedupe: true
    });
    return data;
} //# sourceMappingURL=getBalance.js.map
}}),
"[project]/node_modules/@bigmi/core/dist/esm/decorators/UTXOAPIActions.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "UTXOAPIActions": (()=>UTXOAPIActions)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$bigmi$2f$core$2f$dist$2f$esm$2f$actions$2f$getBalance$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@bigmi/core/dist/esm/actions/getBalance.js [app-client] (ecmascript)");
;
function UTXOAPIActions(client) {
    return {
        getBalance: (args)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$bigmi$2f$core$2f$dist$2f$esm$2f$actions$2f$getBalance$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBalance"])(client, args)
    };
} //# sourceMappingURL=UTXOAPIActions.js.map
}}),
"[project]/node_modules/@bigmi/core/dist/esm/actions/getBlockCount.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "getBlockCount": (()=>getBlockCount)
});
async function getBlockCount(client) {
    const data = await client.request({
        method: 'getblockcount',
        params: []
    }, {
        dedupe: true
    });
    return data;
} //# sourceMappingURL=getBlockCount.js.map
}}),
"[project]/node_modules/@bigmi/core/dist/esm/actions/sendUTXOTransaction.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "sendUTXOTransaction": (()=>sendUTXOTransaction)
});
async function sendUTXOTransaction(client, { hex, maxFeeRate }) {
    const params = [
        hex
    ];
    if (maxFeeRate) {
        params.push(maxFeeRate);
    }
    const data = await client.request({
        method: 'sendrawtransaction',
        params: params
    });
    return data;
} //# sourceMappingURL=sendUTXOTransaction.js.map
}}),
"[project]/node_modules/@bigmi/core/dist/esm/actions/getUTXOTransaction.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "getUTXOTransaction": (()=>getUTXOTransaction)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$transaction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/viem/_esm/errors/transaction.js [app-client] (ecmascript)");
;
async function getUTXOTransaction(client, { txId, blockHash }) {
    try {
        const params = [
            txId,
            true
        ];
        if (blockHash) {
            params.push(blockHash);
        }
        const data = await client.request({
            method: 'getrawtransaction',
            params: params
        });
        return data;
    } catch (_error) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$transaction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TransactionNotFoundError"]({
            blockHash: blockHash,
            hash: txId
        });
    }
} //# sourceMappingURL=getUTXOTransaction.js.map
}}),
"[project]/node_modules/@bigmi/core/dist/esm/decorators/UTXOActions.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "UTXOActions": (()=>UTXOActions)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$bigmi$2f$core$2f$dist$2f$esm$2f$actions$2f$getBlockCount$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@bigmi/core/dist/esm/actions/getBlockCount.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$bigmi$2f$core$2f$dist$2f$esm$2f$actions$2f$sendUTXOTransaction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@bigmi/core/dist/esm/actions/sendUTXOTransaction.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$bigmi$2f$core$2f$dist$2f$esm$2f$actions$2f$getUTXOTransaction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@bigmi/core/dist/esm/actions/getUTXOTransaction.js [app-client] (ecmascript)");
;
;
;
function UTXOActions(client) {
    return {
        getBlockCount: ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$bigmi$2f$core$2f$dist$2f$esm$2f$actions$2f$getBlockCount$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockCount"])(client),
        sendUTXOTransaction: (args)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$bigmi$2f$core$2f$dist$2f$esm$2f$actions$2f$sendUTXOTransaction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sendUTXOTransaction"])(client, args),
        getUTXOTransaction: (args)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$bigmi$2f$core$2f$dist$2f$esm$2f$actions$2f$getUTXOTransaction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getUTXOTransaction"])(client, args)
    };
} //# sourceMappingURL=UTXOActions.js.map
}}),
"[project]/node_modules/@bigmi/core/dist/esm/actions/signPsbt.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "signPsbt": (()=>signPsbt)
});
async function signPsbt(client, params) {
    const data = await client.request({
        method: 'signPsbt',
        params: params
    }, {
        dedupe: true
    });
    return data;
} //# sourceMappingURL=signPsbt.js.map
}}),
"[project]/node_modules/@bigmi/core/dist/esm/utils/observe.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
/** @internal */ __turbopack_esm__({
    "cleanupCache": (()=>cleanupCache),
    "listenersCache": (()=>listenersCache),
    "observe": (()=>observe)
});
const listenersCache = /*#__PURE__*/ new Map();
const cleanupCache = /*#__PURE__*/ new Map();
let callbackCount = 0;
function observe(observerId, callbacks, fn) {
    const callbackId = ++callbackCount;
    const getListeners = ()=>listenersCache.get(observerId) || [];
    const unsubscribe = ()=>{
        const listeners = getListeners();
        listenersCache.set(observerId, listeners.filter((cb)=>cb.id !== callbackId));
    };
    const unwatch = ()=>{
        const cleanup = cleanupCache.get(observerId);
        if (getListeners().length === 1 && cleanup) {
            cleanup();
        }
        unsubscribe();
    };
    const listeners = getListeners();
    listenersCache.set(observerId, [
        ...listeners,
        {
            id: callbackId,
            fns: callbacks
        }
    ]);
    if (listeners && listeners.length > 0) {
        return unwatch;
    }
    const emit = {};
    for(const key in callbacks){
        emit[key] = (...args)=>{
            const listeners = getListeners();
            if (listeners.length === 0) {
                return;
            }
            for (const listener of listeners){
                listener.fns[key]?.(...args);
            }
        };
    }
    const cleanup = fn(emit);
    if (typeof cleanup === 'function') {
        cleanupCache.set(observerId, cleanup);
    }
    return unwatch;
} //# sourceMappingURL=observe.js.map
}}),
"[project]/node_modules/@bigmi/core/dist/esm/utils/sleep.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "sleep": (()=>sleep)
});
function sleep(ms) {
    return new Promise((resolve)=>{
        setTimeout(()=>resolve(null), ms);
    });
} //# sourceMappingURL=sleep.js.map
}}),
"[project]/node_modules/@bigmi/core/dist/esm/utils/poll.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "poll": (()=>poll)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$bigmi$2f$core$2f$dist$2f$esm$2f$utils$2f$sleep$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@bigmi/core/dist/esm/utils/sleep.js [app-client] (ecmascript)");
;
function poll(fn, { emitOnBegin, initialWaitTime, interval }) {
    let active = true;
    const unwatch = ()=>{
        active = false;
    };
    const watch = async ()=>{
        let data = undefined;
        if (emitOnBegin) {
            data = await fn({
                unpoll: unwatch
            });
        }
        const initialWait = await initialWaitTime?.(data) ?? interval;
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$bigmi$2f$core$2f$dist$2f$esm$2f$utils$2f$sleep$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sleep"])(initialWait);
        const poll = async ()=>{
            if (!active) {
                return;
            }
            await fn({
                unpoll: unwatch
            });
            await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$bigmi$2f$core$2f$dist$2f$esm$2f$utils$2f$sleep$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sleep"])(interval);
            poll();
        };
        poll();
    };
    watch();
    return unwatch;
} //# sourceMappingURL=poll.js.map
}}),
"[project]/node_modules/@bigmi/core/dist/esm/actions/watchBlockNumber.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "watchBlockNumber": (()=>watchBlockNumber)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$stringify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/viem/_esm/utils/stringify.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$bigmi$2f$core$2f$dist$2f$esm$2f$utils$2f$observe$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@bigmi/core/dist/esm/utils/observe.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$bigmi$2f$core$2f$dist$2f$esm$2f$utils$2f$poll$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@bigmi/core/dist/esm/utils/poll.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$getAction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/viem/_esm/utils/getAction.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$bigmi$2f$core$2f$dist$2f$esm$2f$actions$2f$getBlockCount$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@bigmi/core/dist/esm/actions/getBlockCount.js [app-client] (ecmascript)");
;
;
;
;
;
function watchBlockNumber(client, { emitOnBegin = false, emitMissed = false, onBlockNumber, onError, pollingInterval = client.pollingInterval }) {
    let prevBlockNumber;
    const observerId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$stringify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringify"])([
        'watchBlockNumber',
        client.uid,
        emitOnBegin,
        emitMissed,
        pollingInterval
    ]);
    // TODO (edge cases):
    // 1) Stop iterating block numbers if we are happy with the result of one onBlockNumber execution but there is more in the queue.
    // 2) If we missed some time - user closed the page and came back when the block is already mined.
    // In this case we probably want to save the block when we send the transaction and track the currently checked blocks until we find the relevant one.
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$bigmi$2f$core$2f$dist$2f$esm$2f$utils$2f$observe$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["observe"])(observerId, {
        onBlockNumber,
        onError
    }, (emit)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$bigmi$2f$core$2f$dist$2f$esm$2f$utils$2f$poll$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["poll"])(async ()=>{
            try {
                const blockNumber = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$getAction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAction"])(client, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$bigmi$2f$core$2f$dist$2f$esm$2f$actions$2f$getBlockCount$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockCount"], 'getBlockCount')({
                    cacheTime: 0
                });
                if (prevBlockNumber) {
                    // If the current block number is the same as the previous,
                    // we can skip.
                    if (blockNumber === prevBlockNumber) {
                        return;
                    }
                    // If we have missed out on some previous blocks, and the
                    // `emitMissed` flag is truthy, let's emit those blocks.
                    if (blockNumber - prevBlockNumber > 1 && emitMissed) {
                        for(let i = prevBlockNumber + 1; i < blockNumber; i++){
                            await emit.onBlockNumber(i, prevBlockNumber);
                            prevBlockNumber = i;
                        }
                    }
                }
                // If the next block number is greater than the previous,
                // it is not in the past, and we can emit the new block number.
                if (!prevBlockNumber || blockNumber > prevBlockNumber) {
                    await emit.onBlockNumber(blockNumber, prevBlockNumber);
                    prevBlockNumber = blockNumber;
                }
            } catch (err) {
                emit.onError?.(err);
            }
        }, {
            emitOnBegin,
            interval: pollingInterval
        }));
} //# sourceMappingURL=watchBlockNumber.js.map
}}),
"[project]/node_modules/@bigmi/core/dist/esm/actions/getBlockStats.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "getBlockStats": (()=>getBlockStats)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$block$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/viem/_esm/errors/block.js [app-client] (ecmascript)");
;
async function getBlockStats(client, { blockHash, blockNumber, stats }) {
    const blockHashOrNumber = blockHash || blockNumber;
    if (!blockHashOrNumber) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$block$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BlockNotFoundError"]({
            blockHash,
            blockNumber
        });
    }
    try {
        const params = [
            blockHashOrNumber
        ];
        if (stats) {
            params.push(stats);
        }
        const data = await client.request({
            method: 'getblockstats',
            params: params
        }, {
            dedupe: true
        });
        return data;
    } catch (_error) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$block$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BlockNotFoundError"]({
            blockHash,
            blockNumber
        });
    }
} //# sourceMappingURL=getBlockStats.js.map
}}),
"[project]/node_modules/@bigmi/core/dist/esm/actions/getBlock.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "getBlock": (()=>getBlock)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bitcoinjs$2d$lib$2f$src$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/bitcoinjs-lib/src/esm/index.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$block$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/viem/_esm/errors/block.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bitcoinjs$2d$lib$2f$src$2f$esm$2f$block$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/bitcoinjs-lib/src/esm/block.js [app-client] (ecmascript)");
;
;
async function getBlock(client, { blockHash, blockNumber }) {
    let blockHex;
    try {
        let _blockHash = blockHash;
        if (!_blockHash && blockNumber) {
            _blockHash = await client.request({
                method: 'getblockhash',
                params: [
                    blockNumber
                ]
            }, {
                dedupe: true
            });
        }
        if (_blockHash) {
            blockHex = await client.request({
                method: 'getblock',
                params: [
                    _blockHash,
                    0
                ]
            }, {
                dedupe: true
            });
        }
    } catch (_error) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$block$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BlockNotFoundError"]({
            blockHash,
            blockNumber
        });
    }
    if (!blockHex) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$block$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["BlockNotFoundError"]({
            blockHash,
            blockNumber
        });
    }
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bitcoinjs$2d$lib$2f$src$2f$esm$2f$block$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Block"].fromHex(blockHex);
} //# sourceMappingURL=getBlock.js.map
}}),
"[project]/node_modules/@bigmi/core/dist/esm/actions/waitForTransaction.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, z: __turbopack_require_stub__ } = __turbopack_context__;
{
__turbopack_esm__({
    "waitForTransaction": (()=>waitForTransaction)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bitcoinjs$2d$lib$2f$src$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_import__("[project]/node_modules/bitcoinjs-lib/src/esm/index.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$stringify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/viem/_esm/utils/stringify.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$transaction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/viem/_esm/errors/transaction.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$bigmi$2f$core$2f$dist$2f$esm$2f$utils$2f$observe$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@bigmi/core/dist/esm/utils/observe.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$getAction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/viem/_esm/utils/getAction.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$bigmi$2f$core$2f$dist$2f$esm$2f$actions$2f$watchBlockNumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@bigmi/core/dist/esm/actions/watchBlockNumber.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$bigmi$2f$core$2f$dist$2f$esm$2f$actions$2f$getBlockStats$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@bigmi/core/dist/esm/actions/getBlockStats.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$promise$2f$withRetry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/viem/_esm/utils/promise/withRetry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$bigmi$2f$core$2f$dist$2f$esm$2f$actions$2f$getUTXOTransaction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@bigmi/core/dist/esm/actions/getUTXOTransaction.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bitcoinjs$2d$lib$2f$src$2f$esm$2f$transaction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/bitcoinjs-lib/src/esm/transaction.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$bigmi$2f$core$2f$dist$2f$esm$2f$actions$2f$getBlock$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_import__("[project]/node_modules/@bigmi/core/dist/esm/actions/getBlock.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bitcoinjs$2d$lib$2f$src$2f$esm$2f$address$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__address$3e$__ = __turbopack_import__("[project]/node_modules/bitcoinjs-lib/src/esm/address.js [app-client] (ecmascript) <export * as address>");
;
;
;
;
;
;
;
;
async function waitForTransaction(client, { confirmations = 1, txId, txHex, senderAddress, onReplaced, pollingInterval = client.pollingInterval, retryCount = 10, retryDelay = 3000, timeout }) {
    const observerId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$stringify$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringify"])([
        'waitForTransaction',
        client.uid,
        txId
    ]);
    let count = 0;
    let transaction;
    let replacedTransaction;
    let retrying = false;
    return new Promise((resolve, reject)=>{
        if (timeout) {
            setTimeout(()=>reject(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$transaction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WaitForTransactionReceiptTimeoutError"]({
                    hash: txId
                })), timeout);
        }
        const _unobserve = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$bigmi$2f$core$2f$dist$2f$esm$2f$utils$2f$observe$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["observe"])(observerId, {
            onReplaced,
            resolve,
            reject
        }, (emit)=>{
            const _unwatch = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$getAction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAction"])(client, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$bigmi$2f$core$2f$dist$2f$esm$2f$actions$2f$watchBlockNumber$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["watchBlockNumber"], 'watchBlockNumber')({
                emitMissed: true,
                emitOnBegin: true,
                pollingInterval,
                async onBlockNumber (blockNumber_) {
                    const done = (fn)=>{
                        _unwatch();
                        fn();
                        _unobserve();
                    };
                    let blockNumber = blockNumber_;
                    if (retrying) {
                        return;
                    }
                    if (count > retryCount) {
                        done(()=>emit.reject(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$transaction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WaitForTransactionReceiptTimeoutError"]({
                                hash: txId
                            })));
                    }
                    try {
                        // If we already have a valid receipt, let's check if we have enough
                        // confirmations. If we do, then we can resolve.
                        if (transaction?.blockhash) {
                            const blockStats = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$getAction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAction"])(client, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$bigmi$2f$core$2f$dist$2f$esm$2f$actions$2f$getBlockStats$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockStats"], 'getBlockStats')({
                                blockHash: transaction.blockhash,
                                stats: [
                                    'height'
                                ]
                            });
                            if (confirmations > 1 && (!blockStats.height || blockNumber - blockStats.height + 1 < confirmations)) {
                                return;
                            }
                            done(()=>emit.resolve(transaction));
                            return;
                        }
                        // Get the transaction to check if it's been replaced.
                        // We need to retry as some RPC Providers may be slow to sync
                        // up mined transactions.
                        retrying = true;
                        transaction = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$promise$2f$withRetry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withRetry"])(()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$getAction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAction"])(client, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$bigmi$2f$core$2f$dist$2f$esm$2f$actions$2f$getUTXOTransaction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getUTXOTransaction"], 'getUTXOTransaction')({
                                txId: transaction?.txid || txId
                            }), {
                            delay: retryDelay,
                            retryCount
                        });
                        if (transaction.blockhash) {
                            const blockStats = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$getAction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAction"])(client, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$bigmi$2f$core$2f$dist$2f$esm$2f$actions$2f$getBlockStats$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlockStats"], 'getBlockStats')({
                                blockHash: transaction.blockhash,
                                stats: [
                                    'height'
                                ]
                            });
                            if (blockStats.height) {
                                blockNumber = blockStats.height;
                            }
                        }
                        retrying = false;
                        // Check if transaction has been processed.
                        if (!transaction?.confirmations) {
                            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$transaction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TransactionReceiptNotFoundError"]({
                                hash: txId
                            });
                        }
                        // Check if we have enough confirmations. If not, continue polling.
                        if (transaction.confirmations < confirmations) {
                            return;
                        }
                        done(()=>emit.resolve(transaction));
                    } catch (err) {
                        // If the receipt is not found, the transaction will be pending.
                        // We need to check if it has potentially been replaced.
                        if (err instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$transaction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TransactionNotFoundError"] || err instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$errors$2f$transaction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TransactionReceiptNotFoundError"]) {
                            try {
                                replacedTransaction = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bitcoinjs$2d$lib$2f$src$2f$esm$2f$transaction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Transaction"].fromHex(transaction?.hex || txHex);
                                // Let's retrieve the transactions from the current block.
                                // We need to retry as some RPC Providers may be slow to sync
                                // up mined blocks.
                                retrying = true;
                                const block = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$promise$2f$withRetry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withRetry"])(()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$getAction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAction"])(client, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$bigmi$2f$core$2f$dist$2f$esm$2f$actions$2f$getBlock$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getBlock"], 'getBlock')({
                                        blockNumber
                                    }), {
                                    delay: retryDelay,
                                    retryCount
                                });
                                retrying = false;
                                // Create a set of input identifiers for mempool transaction
                                const replacedTransactionInputs = new Set();
                                for (const input of replacedTransaction.ins){
                                    const txid = Array.from(input.hash).reverse().map((byte)=>`00${byte.toString(16)}`.slice(-2)).join('');
                                    const vout = input.index;
                                    const inputId = `${txid}:${vout}`;
                                    replacedTransactionInputs.add(inputId);
                                }
                                let replacementTransaction;
                                for (const tx of block.transactions){
                                    if (tx.isCoinbase()) {
                                        continue;
                                    }
                                    // Check if any input of this transaction matches an input of mempool transaction
                                    for (const input of tx.ins){
                                        const txid = Array.from(input.hash).reverse().map((byte)=>`00${byte.toString(16)}`.slice(-2)).join('');
                                        const vout = input.index;
                                        const inputId = `${txid}:${vout}`;
                                        if (replacedTransactionInputs.has(inputId)) {
                                            replacementTransaction = tx;
                                            break;
                                        }
                                    }
                                    if (replacementTransaction) {
                                        break;
                                    }
                                }
                                // If we couldn't find a replacement transaction, continue polling.
                                if (!replacementTransaction) {
                                    return;
                                }
                                // If we found a replacement transaction, return it's receipt.
                                transaction = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$viem$2f$_esm$2f$utils$2f$getAction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAction"])(client, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$bigmi$2f$core$2f$dist$2f$esm$2f$actions$2f$getUTXOTransaction$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getUTXOTransaction"], 'getUTXOTransaction')({
                                    txId: replacementTransaction.getId()
                                });
                                // Check if we have enough confirmations. If not, continue polling.
                                if (transaction.confirmations && transaction.confirmations < confirmations) {
                                    return;
                                }
                                let reason = 'replaced';
                                // Function to get output addresses
                                function getOutputAddresses(tx) {
                                    const addresses = [];
                                    for (const output of tx.outs){
                                        try {
                                            const outputAddress = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bitcoinjs$2d$lib$2f$src$2f$esm$2f$address$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__address$3e$__["address"].fromOutputScript(output.script);
                                            addresses.push(outputAddress);
                                        } catch (_e) {
                                        // Handle non-standard scripts (e.g., OP_RETURN)
                                        }
                                    }
                                    return addresses;
                                }
                                // Get the recipient addresses from the original transaction
                                const originalOutputAddresses = getOutputAddresses(replacedTransaction);
                                // Get the recipient addresses from the replacement transaction
                                const replacementOutputAddresses = getOutputAddresses(replacementTransaction);
                                if (originalOutputAddresses.length === replacementOutputAddresses.length && originalOutputAddresses.every((address)=>replacementOutputAddresses.includes(address))) {
                                    reason = 'repriced';
                                } else if (senderAddress && replacementOutputAddresses.length === 1 && replacementOutputAddresses.includes(senderAddress)) {
                                    reason = 'cancelled';
                                }
                                done(()=>{
                                    emit.onReplaced?.({
                                        reason,
                                        replacedTransaction: replacedTransaction,
                                        transaction: transaction
                                    });
                                    emit.resolve(transaction);
                                });
                            } catch (err_) {
                                done(()=>emit.reject(err_));
                            }
                        } else {
                            done(()=>emit.reject(err));
                        }
                    } finally{
                        count++;
                    }
                }
            });
        });
    });
} //# sourceMappingURL=waitForTransaction.js.map
}}),
}]);

//# sourceMappingURL=node_modules_%40bigmi_37fc91._.js.map